------- FILE src/main.s LEVEL 1 PASS 3
      1  1c50 ????						; title screen program -- use hand-made compression method (esentially just RLE, see rleEncoding.py)
      2  1c50 ????				      processor	6502
      3  1c50 ????
      4 U000f ????				      seg.u	ZP
      5 U0000					      org	$0
      6 U0000
      7 U0000
      8 U0000		       00 00	   screen_cursor ds.w	1	; stores the current screen memory address
      9 U0002		       00 00	   color_cursor ds.w	1	; store current color memory address
     10 U0004		       00 00	   current_level ds.w	1
     11 U0006		       00 00	   next_level ds.w	1
     12 U0008		       00	   level_reset ds.b	1
     13 U0009		       00	   level_completed ds.b	1
     14 U000a		       00	   level_data_index ds.b	1	; for temporarily saving index registers
     15 U000b		       00	   temp       ds.b	1	; for temporarily saving index registers
     16 U000c		       00 00 00    current_time ds	3	; store only the last byte of the jiffy clock
     17 U000c		       1c 00	   character_set_begin =	$1c00
     18 U000f
     19  1c50 ????				      seg
     20  1c50 ????
     21  1c50 ????						; constants
     22  1c50 ????	       00 20	   BLANK_CHAR =	$20
     23  1c50 ????
     24  1c50 ????	       00 00	   SCREEN_CURSOR_BEGINNING_LOW_BYTE =	$00
     25  1c50 ????	       00 1e	   SCREEN_CURSOR_BEGINNING_HIGH_BYTE =	$1e
     26  1c50 ????
     27  1c50 ????						; last screen location
     28  1c50 ????	       00 fa	   END_OF_SCREEN_LOW_BYTE =	$fa
     29  1c50 ????	       00 1f	   END_OF_SCREEN_HIGH_BYTE =	$1f
     30  1c50 ????
     31  1c50 ????						; beginning of color memory
     32  1c50 ????	       00 00	   COLOR_CURSOR_BEGINNING_LOW_BYTE =	$00
     33  1c50 ????	       00 96	   COLOR_CURSOR_BEGINNING_HIGH_BYTE =	$96
     34  1c50 ????	       00 02	   RED_COLOR_CODE =	2
     35  1c50 ????	       00 20	   SPACE_KEY  =	$20
     36  1c50 ????
     37  1c50 ????	       00 0d	   SECRET_KEY =	$0d	; translates to "P"
     38  1c50 ????
     39  1c50 ????						; memory locations
     40  1c50 ????	       10 01	   user_memory_start =	$1001
     41  1c50 ????	       00 c5	   currently_pressed_key =	$c5
     42  1c50 ????	       00 a0	   jiffy_clock =	$A0
     43  1c50 ????	       90 05	   character_info_register =	$9005
     44  1c50 ????
     45  1c50 ????						; begin location counter at 4096 (user memory)
     46  1001					      org	user_memory_start
------- FILE stub.s LEVEL 2 PASS 3
      0  1001					      include	"stub.s"	; stub contains BASIC sys cmd to run the machine language code
      1  1001		       00 9e	   SYS_CMD_TOKEN =	$9e
      2  1001		       00 0a	   STUB_LINE_NUMBER =	10
      3  1001							; BASIC stub -- SYS cmd to run machine language 
      4  1001		       0b 10		      dc.w	nextstmt	; link; beginning of basic
      5  1003		       0a 00		      dc.w	STUB_LINE_NUMBER	; line number 
      6  1005		       9e 34 31 30*	      dc.b	SYS_CMD_TOKEN, [start]d, 0	; token for sys with operand as address to "start" label
      7  100b				   nextstmt
      8  100b		       00 00		      dc.w	0
------- FILE src/main.s
     48  100d
     49  100d				   start
     50  100d							; use combination of RAM (first 128 chars at 7168) & ROM character set
     51  100d		       a9 ff		      lda	#255
     52  100f		       8d 05 90 	      sta	character_info_register
     53  1012
     54  1012							; initialize some variables in the zero page
     55  1012		       a9 01		      lda	#1
     56  1014		       85 08		      sta	level_reset
     57  1016		       a9 00		      lda	#0
     58  1018		       85 09		      sta	level_completed
     59  101a
     60  101a		       a9 34		      lda	#<level_data_start
     61  101c		       85 04		      sta	current_level
     62  101e		       a9 12		      lda	#>level_data_start
     63  1020		       85 05		      sta	current_level+1
     64  1022
     65  1022		       a9 00		      lda	#0
     66  1024
     67  1024
------- FILE titleScreen.s LEVEL 2 PASS 3
      0  1024					      include	"titleScreen.s"
      1  1024				   display_title_screen
      2  1024		       a9 00		      lda	#SCREEN_CURSOR_BEGINNING_LOW_BYTE
      3  1026		       85 00		      sta	screen_cursor
      4  1028		       a9 1e		      lda	#SCREEN_CURSOR_BEGINNING_HIGH_BYTE	; store 1e in location 01
      5  102a		       85 01		      sta	screen_cursor+1
      6  102c
      7  102c		       a9 00		      lda	#COLOR_CURSOR_BEGINNING_LOW_BYTE
      8  102e		       85 02		      sta	color_cursor
      9  1030		       a9 96		      lda	#COLOR_CURSOR_BEGINNING_HIGH_BYTE
     10  1032		       85 03		      sta	color_cursor+1
     11  1034
     12  1034		       a0 00		      ldy	#$0	; to use for indirect indexed addressing
     13  1036		       a2 00		      ldx	#$0
     14  1038
     15  1038		       20 44 10 	      jsr	draw_title_screen_loop
     16  103b
     17  103b				   infinite_loop
     18  103b		       a5 c5		      lda	currently_pressed_key
     19  103d		       c9 20		      cmp	#SPACE_KEY
     20  103f		       f0 5c		      beq	gameLoop
     21  1041		       4c 3b 10 	      jmp	infinite_loop
     22  1044
     23  1044
     24  1044				   draw_title_screen_loop
     25  1044		       bd cc 11 	      lda	compressed_screen_data_start,X	; accumulator stores num times to repeat the byte
     26  1047		       20 52 10 	      jsr	draw_character	; draw the character that many times
     27  104a		       e8		      inx
     28  104b		       e8		      inx
     29  104c		       20 8d 10 	      jsr	check_if_screen_cursor_at_end
     30  104f		       90 f3		      bcc	draw_title_screen_loop
     31  1051		       60		      rts
     32  1052
     33  1052
     34  1052							; draw the character in Y register for (value of accumulator) number of times
     35  1052				   draw_character
     36  1052							; if accumulator == 0, return; otherwise, subtract 1 from accumulator and continue drawing the letter at Y
     37  1052		       f0 1d		      beq	draw_character_end
     38  1054		       38		      sec
     39  1055		       e9 01		      sbc	#1
     40  1057		       48		      pha		; push accumulator onto stack
     41  1058
     42  1058							; store current char at screen cursor location
     43  1058		       a0 00		      ldy	#0
     44  105a		       bd cd 11 	      lda	compressed_screen_data_start+1,X	; load cur char to draw
     45  105d		       18		      clc
     46  105e		       69 80		      adc	#128
     47  1060		       91 00		      sta	(screen_cursor),Y	; draw it on screen
     48  1062
     49  1062							; add color to the screen location if it's not a space
     50  1062							; because our title screen only has one color, and only displays it for characters that arent space, we can get away with this "optimization",
     51  1062							; and avoid adding color data
     52  1062		       c9 20		      cmp	#BLANK_CHAR
     53  1064		       f0 04		      beq	dont_color
     54  1066		       a9 02		      lda	#RED_COLOR_CODE
     55  1068		       91 02		      sta	(color_cursor),Y
     56  106a
     57  106a				   dont_color
     58  106a		       20 72 10 	      jsr	add_one_to_screen_cursor
     59  106d		       68		      pla		; put the current 'count' (remaining times to draw character) back on accumulator
     60  106e		       4c 52 10 	      jmp	draw_character
     61  1071
     62  1071				   draw_character_end
     63  1071		       60		      rts
     64  1072
     65  1072
     66  1072
     67  1072				   add_one_to_screen_cursor
     68  1072		       18		      clc
     69  1073		       a5 00		      lda	screen_cursor	; load and add to low byte
     70  1075		       69 01		      adc	#$1
     71  1077		       85 00		      sta	screen_cursor
     72  1079		       a5 01		      lda	screen_cursor+1
     73  107b		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
     74  107d		       85 01		      sta	screen_cursor+1
     75  107f
     76  107f							; add to color cursor as well
     77  107f		       18		      clc
     78  1080		       a5 02		      lda	color_cursor	; load and add to low byte
     79  1082		       69 01		      adc	#$1
     80  1084		       85 02		      sta	color_cursor
     81  1086		       a5 03		      lda	color_cursor+1
     82  1088		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
     83  108a		       85 03		      sta	color_cursor+1
     84  108c		       60		      rts
     85  108d
     86  108d				   check_if_screen_cursor_at_end		; set carry flag if screen_cursor at position $1ff9 (8185
     87  108d		       a5 00		      lda	screen_cursor	; load value at screen_cursor low byte
     88  108f		       c9 fa		      cmp	#END_OF_SCREEN_LOW_BYTE
     89  1091		       d0 06		      bne	check_if_screen_cursor_at_end_return_false	; if low byte doesnt match, return with carry flag as neg
     90  1093
     91  1093		       a5 01		      lda	screen_cursor+1
     92  1095		       c9 1f		      cmp	#END_OF_SCREEN_HIGH_BYTE
     93  1097		       f0 02		      beq	check_if_screen_cursor_at_end_return_true	; if high byte matches, set carry flag
     94  1099
     95  1099				   check_if_screen_cursor_at_end_return_false
     96  1099		       18		      clc
     97  109a		       60		      rts
     98  109b
     99  109b				   check_if_screen_cursor_at_end_return_true
    100  109b		       38		      sec
    101  109c		       60		      rts
------- FILE src/main.s
     69  109d
     70  109d
     71  109d							; title screen code jumps here once space pressed
     72  109d				   gameLoop
     73  109d		       20 d1 10 	      jsr	update_level
     74  10a0		       a9 00		      lda	#0
     75  10a2		       85 08		      sta	level_reset
     76  10a4
     77  10a4		       20 c2 10 	      jsr	check_for_secret_key
     78  10a7		       20 b9 10 	      jsr	wait_until_next_frame
     79  10aa		       20 b9 10 	      jsr	wait_until_next_frame
     80  10ad		       20 b9 10 	      jsr	wait_until_next_frame
     81  10b0		       20 b9 10 	      jsr	wait_until_next_frame
     82  10b3		       20 b9 10 	      jsr	wait_until_next_frame
     83  10b6		       4c 9d 10 	      JMP	gameLoop
     84  10b9
     85  10b9
     86  10b9				   wait_until_next_frame		; wait one jiffy before completing game loop
     87  10b9		       a5 a2		      lda	jiffy_clock+2
     88  10bb		       c5 0c		      cmp	current_time
     89  10bd		       f0 fa		      beq	wait_until_next_frame
     90  10bf		       85 0c		      sta	current_time
     91  10c1		       60		      rts
     92  10c2
     93  10c2							; update level_completed and level_reset if secret_key pressed
     94  10c2				   check_for_secret_key
     95  10c2		       a5 c5		      lda	currently_pressed_key
     96  10c4		       c9 0d		      cmp	#SECRET_KEY
     97  10c6		       d0 08		      bne	check_for_secret_key_return
     98  10c8		       a9 01		      lda	#1
     99  10ca		       85 09		      sta	level_completed
    100  10cc		       a9 01		      lda	#1
    101  10ce		       85 08		      sta	level_reset
    102  10d0
    103  10d0				   check_for_secret_key_return
    104  10d0		       60		      rts
    105  10d1
------- FILE updateLevel.s LEVEL 2 PASS 3
      0  10d1					      include	"updateLevel.s"
      1  10d1		       00 01	   LEVEL_IS_DONE =	1
      2  10d1		       00 00	   LEVEL_NOT_DONE =	0
      3  10d1		       00 01	   SHOULD_RESET =	1
      4  10d1		       00 00	   SHOULD_NOT_RESET =	0
      5  10d1
      6  10d1							; only first 4 bits really matter here; refer to readme for guide on lvl format
      7  10d1		       00 00	   BLANK_SPACE =	0	; 000000000
      8  10d1		       00 10	   STARTING_POINT =	16	; 00010000
      9  10d1		       00 20	   WALL       =	32	; 00100000
     10  10d1		       00 30	   BREAKABLE_WALL =	48	; 00110000
     11  10d1		       00 40	   LOCKED_WALL =	64	; 01000000
     12  10d1		       00 50	   LADDER     =	80	; 01010000
     13  10d1		       00 60	   EXIT       =	96	; 01100000
     14  10d1		       00 70	   PLATFORM   =	112	; 01110000
     15  10d1		       00 80	   KEY	      =	128	; 10000000
     16  10d1		       00 90	   SPIKE      =	144	; 10010000
     17  10d1		       00 a0	   BOOSTER    =	160	;  10100000
     18  10d1
     19  10d1		       00 00	   WALL_COLOR =	0
     20  10d1		       00 00	   BREAKABLE_WALL_COLOR =	0
     21  10d1		       00 00	   LOCKED_WALL_COLOR =	0
     22  10d1		       00 00	   LADDER_COLOR =	0
     23  10d1		       00 00	   EXIT_COLOR =	0
     24  10d1		       00 00	   PLATFORM_COLOR =	0
     25  10d1		       00 00	   KEY_COLOR  =	0
     26  10d1		       00 00	   SPIKE_COLOR =	0
     27  10d1		       00 00	   BOOSTER_COLOR =	0
     28  10d1
     29  10d1		       00 20	   BLANK_SPACE_CHAR =	$20
     30  10d1		       00 03	   WALL_CHAR  =	$3
     31  10d1		       00 07	   BREAKABLE_WALL_CHAR =	$7
     32  10d1		       00 06	   LOCKED_WALL_CHAR =	$6
     33  10d1		       00 00	   LADDER_CHAR =	$0
     34  10d1		       00 04	   EXIT_CHAR  =	$4
     35  10d1		       00 02	   PLATFORM_CHAR =	$2
     36  10d1		       00 05	   KEY_CHAR   =	$5
     37  10d1		       00 08	   SPIKE_CHAR =	$8
     38  10d1		       00 09	   BOOSTER_CHAR =	$9
     39  10d1
     40  10d1
     41  10d1				   update_level
     42  10d1							; check if the level is completed; set current_level to next_level if so
     43  10d1		       a5 09		      lda	level_completed
     44  10d3		       c9 01		      cmp	#LEVEL_IS_DONE	; (try optimizing later)
     45  10d5		       d0 0c		      bne	dont_update
     46  10d7
     47  10d7							; level is done; reset level completed
     48  10d7		       a9 00		      lda	#LEVEL_NOT_DONE
     49  10d9		       85 09		      sta	level_completed
     50  10db
     51  10db							; now set current_level to next_level
     52  10db		       a5 06		      lda	next_level
     53  10dd		       85 04		      sta	current_level
     54  10df		       a5 07		      lda	next_level+1
     55  10e1		       85 05		      sta	current_level+1
     56  10e3
     57  10e3				   dont_update
     58  10e3							; now check if level reset was set
     59  10e3		       a5 08		      lda	level_reset
     60  10e5		       c9 00		      cmp	#0
     61  10e7		       d0 01		      bne	continue_update	; if not, go back to game loop
     62  10e9		       60		      rts
     63  10ea
     64  10ea				   continue_update
     65  10ea							; if it was, update the level
     66  10ea		       a9 00		      lda	#SCREEN_CURSOR_BEGINNING_LOW_BYTE
     67  10ec		       85 00		      sta	screen_cursor
     68  10ee		       a9 1e		      lda	#SCREEN_CURSOR_BEGINNING_HIGH_BYTE
     69  10f0		       85 01		      sta	screen_cursor+1
     70  10f2
     71  10f2		       a9 00		      lda	#COLOR_CURSOR_BEGINNING_LOW_BYTE
     72  10f4		       85 02		      sta	color_cursor
     73  10f6		       a9 96		      lda	#COLOR_CURSOR_BEGINNING_HIGH_BYTE
     74  10f8		       85 03		      sta	color_cursor+1
     75  10fa
     76  10fa		       a2 00		      ldx	#0
     77  10fc		       a0 00		      ldy	#0
     78  10fe		       84 0a		      sty	level_data_index
     79  1100							; draw (or redraw) the current level
     80  1100				   draw_level_loop
     81  1100							; y stores our index in the current level data
     82  1100		       a4 0a		      ldy	level_data_index
     83  1102		       b1 04		      lda	(current_level),y	; accumulator stores the number of times to repeat the next byte  
     84  1104
     85  1104		       20 20 11 	      jsr	draw_sequence
     86  1107
     87  1107		       a4 0a		      ldy	level_data_index
     88  1109		       c8		      iny		; set y to point to next length byte (iterate 2 at a time)
     89  110a		       c8		      iny
     90  110b		       84 0a		      sty	level_data_index
     91  110d
     92  110d
     93  110d		       20 8d 10 	      jsr	check_if_screen_cursor_at_end
     94  1110		       90 ee		      bcc	draw_level_loop
     95  1112
     96  1112
     97  1112							; update next level pointer to point to byte after current level
     98  1112		       a5 04		      lda	current_level
     99  1114		       18		      clc
    100  1115		       65 0a		      adc	level_data_index
    101  1117		       85 06		      sta	next_level
    102  1119		       a5 05		      lda	current_level+1
    103  111b		       69 00		      adc	#0
    104  111d		       85 07		      sta	next_level+1
    105  111f		       60		      rts
    106  1120
    107  1120
    108  1120
    109  1120							; i love writing decompression code in assembly. i love writing decompression code in assembly. i love writing decompression code in assembly. 
    110  1120				   draw_sequence
    111  1120							; if acc == 0, return; otherwise subtract 1, draw the next 2 chars
    112  1120		       f0 1c		      beq	draw_sequence_end
    113  1122		       38		      sec
    114  1123		       e9 01		      sbc	#1
    115  1125		       48		      pha		; push accumulator onto stack
    116  1126
    117  1126		       a4 0a		      ldy	level_data_index
    118  1128		       c8		      iny		; (so we can access the "element" byte after the length byte)
    119  1129		       b1 04		      lda	(current_level),y	; get formatted byte (see squarebot doc)
    120  112b		       0a		      asl		; lol
    121  112c		       0a		      asl
    122  112d		       0a		      asl
    123  112e		       0a		      asl
    124  112f		       20 3f 11 	      jsr	draw_high_bits	; draw char represented by the 4 high bits
    125  1132
    126  1132		       a4 0a		      ldy	level_data_index
    127  1134		       c8		      iny
    128  1135
    129  1135		       b1 04		      lda	(current_level),y
    130  1137		       20 3f 11 	      jsr	draw_high_bits
    131  113a
    132  113a		       68		      pla
    133  113b		       4c 20 11 	      jmp	draw_sequence
    134  113e
    135  113e				   draw_sequence_end
    136  113e		       60		      rts
    137  113f
    138  113f
    139  113f							; put the character in the high 4 bits of accumulator on screen (see readme), and move the color and screen cursors ahead
    140  113f				   draw_high_bits
    141  113f		       29 f0		      and	#240	; shave off last 4 bits
    142  1141
    143  1141		       c9 00		      cmp	#BLANK_SPACE
    144  1143		       d0 08		      bne	check_if_starting_point
    145  1145		       a9 20		      lda	#BLANK_SPACE_CHAR	; todo; replace with actual chars
    146  1147		       a2 01		      ldx	#1
    147  1149		       20 c1 11 	      jsr	draw_char_in_accumulator
    148  114c		       60		      rts
    149  114d
    150  114d				   check_if_starting_point
    151  114d		       c9 10		      cmp	#STARTING_POINT
    152  114f		       d0 08		      bne	check_if_wall
    153  1151		       a9 01		      lda	#$1	; fix later will need to update squarre bot position
    154  1153		       a2 00		      ldx	#0
    155  1155		       20 c1 11 	      jsr	draw_char_in_accumulator
    156  1158		       60		      rts
    157  1159
    158  1159				   check_if_wall
    159  1159		       c9 20		      cmp	#WALL
    160  115b		       d0 08		      bne	check_if_breakable_wall
    161  115d		       a9 03		      lda	#WALL_CHAR
    162  115f		       a2 00		      ldx	#WALL_COLOR
    163  1161		       20 c1 11 	      jsr	draw_char_in_accumulator
    164  1164		       60		      rts
    165  1165
    166  1165				   check_if_breakable_wall
    167  1165		       c9 30		      cmp	#BREAKABLE_WALL
    168  1167		       d0 08		      bne	check_if_locked_wall
    169  1169		       a9 07		      lda	#BREAKABLE_WALL_CHAR
    170  116b		       a2 00		      ldx	#BREAKABLE_WALL_COLOR
    171  116d		       20 c1 11 	      jsr	draw_char_in_accumulator
    172  1170		       60		      rts
    173  1171
    174  1171				   check_if_locked_wall
    175  1171		       c9 40		      cmp	#LOCKED_WALL
    176  1173		       d0 08		      bne	check_if_ladder
    177  1175		       a9 06		      lda	#LOCKED_WALL_CHAR
    178  1177		       a2 00		      ldx	#LOCKED_WALL_COLOR
    179  1179		       20 c1 11 	      jsr	draw_char_in_accumulator
    180  117c		       60		      rts
    181  117d
    182  117d				   check_if_ladder
    183  117d		       c9 50		      cmp	#LADDER
    184  117f		       d0 08		      bne	check_if_exit
    185  1181		       a9 00		      lda	#LADDER_CHAR
    186  1183		       a2 00		      ldx	#LADDER_COLOR
    187  1185		       20 c1 11 	      jsr	draw_char_in_accumulator
    188  1188		       60		      rts
    189  1189
    190  1189				   check_if_exit
    191  1189		       c9 60		      cmp	#EXIT
    192  118b		       d0 08		      bne	check_if_platform
    193  118d		       a9 04		      lda	#EXIT_CHAR
    194  118f		       a2 00		      ldx	#EXIT_COLOR
    195  1191		       20 c1 11 	      jsr	draw_char_in_accumulator
    196  1194		       60		      rts
    197  1195
    198  1195				   check_if_platform
    199  1195		       c9 70		      cmp	#PLATFORM
    200  1197		       d0 08		      bne	check_if_key
    201  1199		       a9 02		      lda	#PLATFORM_CHAR
    202  119b		       a2 00		      ldx	#PLATFORM_COLOR
    203  119d		       20 c1 11 	      jsr	draw_char_in_accumulator
    204  11a0		       60		      rts
    205  11a1
    206  11a1
    207  11a1				   check_if_key
    208  11a1		       c9 80		      cmp	#KEY
    209  11a3		       d0 08		      bne	check_if_spike
    210  11a5		       a9 05		      lda	#KEY_CHAR
    211  11a7		       a2 00		      ldx	#KEY_COLOR
    212  11a9		       20 c1 11 	      jsr	draw_char_in_accumulator
    213  11ac		       60		      rts
    214  11ad
    215  11ad				   check_if_spike
    216  11ad		       c9 90		      cmp	#SPIKE
    217  11af		       d0 08		      bne	check_if_booster
    218  11b1		       a9 08		      lda	#SPIKE_CHAR
    219  11b3		       a2 00		      ldx	#SPIKE_COLOR
    220  11b5		       20 c1 11 	      jsr	draw_char_in_accumulator
    221  11b8		       60		      rts
    222  11b9
    223  11b9				   check_if_booster
    224  11b9		       a9 09		      lda	#BOOSTER_CHAR
    225  11bb		       a2 00		      ldx	#BOOSTER_COLOR
    226  11bd		       20 c1 11 	      jsr	draw_char_in_accumulator
    227  11c0		       60		      rts
    228  11c1
    229  11c1
    230  11c1							; char in accumulator goes in screen cursor, color in x register goes in color cursor, then update cursors
    231  11c1
    232  11c1				   draw_char_in_accumulator
    233  11c1		       a0 00		      ldy	#0
    234  11c3		       91 00		      sta	(screen_cursor),y
    235  11c5
    236  11c5		       8a		      txa
    237  11c6		       91 02		      sta	(color_cursor),y
    238  11c8
    239  11c8		       20 72 10 	      jsr	add_one_to_screen_cursor	; add to both screen and color cursor
    240  11cb		       60		      rts
------- FILE src/main.s
    107  11cc
    108  11cc
    109  11cc				   compressed_screen_data_start
    110  11cc					      incbin	"../data/titleScreenData_compressed"	; got via 'bsave ""'
    111  1234
    112  1234				   level_data_start
    113  1234					      incbin	"../data/levels/binary_levels/1"
    114  123c					      incbin	"../data/levels/binary_levels/2"
    115  1248					      incbin	"../data/levels/binary_levels/3"
    116  1266					      incbin	"../data/levels/binary_levels/4"
    117  128a
------- FILE memoryCheck.s LEVEL 2 PASS 3
      0  128a					      include	"memoryCheck.s"	; code to make sure the program isn't too large and enters screen memory
      1  128a		       02 89	   BYTES_USED =	.-$1001	; location counter minus starting location = total bytes used
      2  128a		       1e 00	   SCREEN_MEMORY_START =	$1e00
 649 bytes used
      3  128a					      echo	[BYTES_USED]d, "bytes used"
 Ending program at memory location (base 10):  4746
      4  128a					      echo	"Ending program at memory location (base 10): ", [.]d
      5  128a				  -	      if	. >= SCREEN_MEMORY_START	; if program entering screen memory
      6  128a				  -	      echo	"Throwing error because program is too large, and has entered screen memory!"
      7  128a				  -	      err
      8  128a					      endif
------- FILE src/main.s
    119  128a
    120  128a
    121  1c00					      org	character_set_begin
    122  1c00		       81 ff ff 81*	      BYTE.b	129,255,255,129,129,255,255,129	; ladder 0
    123  1c08		       ff 81 a5 81*	      BYTE.b	255,129,165,129,189,165,129,255	; squarebot 1
    124  1c10		       ff ff 00 00*	      BYTE.b	255,255,0,0,0,0,0,0	; platform 2
    125  1c18		       ff ff ff ff*	      BYTE.b	255,255,255,255,255,255,255,255	; wall 3
    126  1c20		       7e e7 81 81*	      BYTE.b	126,231,129,129,225,129,129,255	; exit (door) 4
    127  1c28		       18 24 18 18*	      BYTE.b	24,36,24,24,30,24,30,24	; key 5 
    128  1c30		       ff ff ef ef*	      BYTE.b	255,255,239,239,239,227,255,255	;locked wall 6
    129  1c38		       ff bd fd b7*	      BYTE.b	255,189,253,183,127,239,231,255	; breakable wall 7
    130  1c40		       00 00 18 3c*	      BYTE.b	0,0,24,60,126,126,0,0	; spike powerup 8
    131  1c48		       00 70 48 78*	      BYTE.b	0,112,72,120,72,72,112,0	; booster powerup 9
