------- FILE src/main.s LEVEL 1 PASS 3
      1  1c98 ????						; title screen program -- use hand-made compression method (esentially just RLE, see rleEncoding.py)
      2  1c98 ????				      processor	6502
      3  1c98 ????
      4 U001f ????				      seg.u	ZP
      5 U0000					      org	$0
      6 U0000
      7 U0000
      8 U0000		       00 00	   screen_cursor ds.w	1	; stores the current screen memory address
      9 U0002		       00 00	   color_cursor ds.w	1	; store current color memory address
     10 U0004		       00 00	   current_level ds.w	1
     11 U0006		       00 00	   next_level ds.w	1
     12 U0008		       00	   level_reset ds.b	1
     13 U0009		       00	   level_completed ds.b	1
     14 U000a		       00	   level_data_index ds.b	1	; for temporarily saving index registers
     15 U000b		       00 00	   new_position ds.w	1	; use to store position of (proposed) new location for squarebot
     16 U000d		       00 00	   new_color_position ds.w	1	; use to store position of (proposed) new location for squarebot
     17 U000f		       00	   current_time ds.b	1	; store only the last byte of the jiffy clock
     18 U0010		       00 00	   squarebot_position ds.w	1
     19 U0012		       00 00	   squarebot_color_position ds.w	1
     20 U0014		       00	   jump_info  ds.b	1	; split in half, first hex=jump direction 0=up 1=left 2=right, second half=jumps remaining
     21 U0015		       00 00 00    tileStore  ds.b	3	; UUUUDDDD LLLLRRRR 0000MMMM
     22 U0018							;colorStore ds.b 3 ; 0UUU0DDD 0LLL0RRR 00000MMM   not the most efficient storage but it needs to also be efficient to decompress
     23 U0018		       00 00	   attached_powerups ds.b	2	; 4 bits for each side, ordered U,D,L,R.
     24 U001a							; 0=none  1=readyBooster  2=activeBooster  3=key 4=spike(not implemented)  add more powerups here   8=ignitedBooster
     25 U001a		       00 00	   temp       ds.w	1	; for temporary storage of things. mainly used in updateGameState
     26 U001c		       00 00 00    charandr   ds.b	3	; for the incredibly complex operation of anding chars
     27  1c98 ????				      seg
     28  1c98 ????
     29  1c98 ????						; constants
     30  1c98 ????	       00 20	   BLANK_CHAR =	$20
     31  1c98 ????
     32  1c98 ????	       00 00	   SCREEN_CURSOR_BEGINNING_LOW_BYTE =	$00
     33  1c98 ????	       00 1e	   SCREEN_CURSOR_BEGINNING_HIGH_BYTE =	$1e
     34  1c98 ????
     35  1c98 ????						; last screen location
     36  1c98 ????	       00 fa	   END_OF_SCREEN_LOW_BYTE =	$fa
     37  1c98 ????	       00 1f	   END_OF_SCREEN_HIGH_BYTE =	$1f
     38  1c98 ????
     39  1c98 ????						; beginning of color memory
     40  1c98 ????	       00 00	   COLOR_CURSOR_BEGINNING_LOW_BYTE =	$00
     41  1c98 ????	       00 96	   COLOR_CURSOR_BEGINNING_HIGH_BYTE =	$96
     42  1c98 ????	       00 00	   RED_COLOR_CODE =	0
     43  1c98 ????
     44  1c98 ????	       00 20	   SPACE_KEY  =	$20
     45  1c98 ????	       00 30	   Q_KEY      =	$30
     46  1c98 ????	       00 09	   W_KEY      =	$09
     47  1c98 ????	       00 31	   E_KEY      =	$31
     48  1c98 ????	       00 11	   A_KEY      =	$11
     49  1c98 ????	       00 29	   S_KEY      =	$29
     50  1c98 ????	       00 12	   D_KEY      =	$12
     51  1c98 ????	       00 0d	   SECRET_KEY =	$0d	; press P to skip to next  level
     52  1c98 ????	       00 0a	   RESET_KEY  =	$0a	; press R to restart level i assume
     53  1c98 ????	       00 02	   JUMP_SIZE  =	$2	; number of characters a jump causes
     54  1c98 ????	       00 16	   ROW_SIZE   =	$16
     55  1c98 ????						; memory locations
     56  1c98 ????	       10 01	   user_memory_start =	$1001
     57  1c98 ????	       00 c5	   currently_pressed_key =	$c5
     58  1c98 ????	       00 a0	   jiffy_clock =	$A0
     59  1c98 ????	       90 05	   character_info_register =	$9005
     60  1c98 ????	       1c 00	   character_set_begin =	$1c00
     61  1c98 ????
     62  1c98 ????						; begin location counter at 4096 (user memory)
     63  1001					      org	user_memory_start
------- FILE stub.s LEVEL 2 PASS 3
      0  1001					      include	"stub.s"	; stub contains BASIC sys cmd to run the machine language code
      1  1001		       00 9e	   SYS_CMD_TOKEN =	$9e
      2  1001		       00 0a	   STUB_LINE_NUMBER =	10
      3  1001							; BASIC stub -- SYS cmd to run machine language
      4  1001		       0b 10		      dc.w	nextstmt	; link; beginning of basic
      5  1003		       0a 00		      dc.w	STUB_LINE_NUMBER	; line number
      6  1005		       9e 34 31 30*	      dc.b	SYS_CMD_TOKEN, [start]d, 0	; token for sys with operand as address to "start" label
      7  100b				   nextstmt
      8  100b		       00 00		      dc.w	0
------- FILE src/main.s
     65  100d
     66  100d				   start
     67  100d							; use combination of RAM (first 128 chars at 7168) & ROM character set
     68  100d		       a9 ff		      lda	#255
     69  100f		       8d 05 90 	      sta	character_info_register
     70  1012
     71  1012							; initialize some variables in the zero page
     72  1012		       a9 01		      lda	#1
     73  1014		       85 08		      sta	level_reset
     74  1016		       a9 00		      lda	#0
     75  1018		       85 09		      sta	level_completed
     76  101a
     77  101a		       a9 63		      lda	#<level_data_start
     78  101c		       85 04		      sta	current_level
     79  101e		       a9 19		      lda	#>level_data_start
     80  1020		       85 05		      sta	current_level+1
     81  1022
     82  1022		       a9 00		      lda	#0
     83  1024		       85 14		      sta	jump_info
     84  1026		       85 18		      sta	attached_powerups
     85  1028		       85 19		      sta	attached_powerups+1
     86  102a		       85 15		      sta	tileStore
     87  102c		       85 16		      sta	tileStore+1
     88  102e		       85 17		      sta	tileStore+2
     89  1030
------- FILE titleScreen.s LEVEL 2 PASS 3
      0  1030					      include	"titleScreen.s"
      1  1030				   display_title_screen
      2  1030		       a9 00		      lda	#SCREEN_CURSOR_BEGINNING_LOW_BYTE
      3  1032		       85 00		      sta	screen_cursor
      4  1034		       a9 1e		      lda	#SCREEN_CURSOR_BEGINNING_HIGH_BYTE	; store 1e in location 01
      5  1036		       85 01		      sta	screen_cursor+1
      6  1038
      7  1038		       a9 00		      lda	#COLOR_CURSOR_BEGINNING_LOW_BYTE
      8  103a		       85 02		      sta	color_cursor
      9  103c		       a9 96		      lda	#COLOR_CURSOR_BEGINNING_HIGH_BYTE
     10  103e		       85 03		      sta	color_cursor+1
     11  1040
     12  1040		       a0 00		      ldy	#$0	; to use for indirect indexed addressing
     13  1042		       a2 00		      ldx	#$0
     14  1044
     15  1044		       20 50 10 	      jsr	draw_title_screen_loop
     16  1047
     17  1047				   infinite_loop
     18  1047		       a5 c5		      lda	currently_pressed_key
     19  1049		       c9 20		      cmp	#SPACE_KEY
     20  104b		       f0 5c		      beq	gameLoop
     21  104d		       4c 47 10 	      jmp	infinite_loop
     22  1050
     23  1050
     24  1050				   draw_title_screen_loop
     25  1050		       bd fb 18 	      lda	compressed_screen_data_start,X	; accumulator stores num times to repeat the byte
     26  1053		       20 5e 10 	      jsr	draw_character	; draw the character that many times
     27  1056		       e8		      inx
     28  1057		       e8		      inx
     29  1058		       20 99 10 	      jsr	check_if_screen_cursor_at_end
     30  105b		       90 f3		      bcc	draw_title_screen_loop
     31  105d		       60		      rts
     32  105e
     33  105e
     34  105e							; draw the character in Y register for (value of accumulator) number of times
     35  105e				   draw_character
     36  105e							; if accumulator == 0, return; otherwise, subtract 1 from accumulator and continue drawing the letter at Y
     37  105e		       f0 1d		      beq	draw_character_end
     38  1060		       38		      sec
     39  1061		       e9 01		      sbc	#1
     40  1063		       48		      pha		; push accumulator onto stack
     41  1064
     42  1064							; store current char at screen cursor location
     43  1064		       a0 00		      ldy	#0
     44  1066		       bd fc 18 	      lda	compressed_screen_data_start+1,X	; load cur char to draw
     45  1069		       18		      clc
     46  106a		       69 80		      adc	#128
     47  106c		       91 00		      sta	(screen_cursor),Y	; draw it on screen
     48  106e
     49  106e							; add color to the screen location if it's not a space
     50  106e							; because our title screen only has one color, and only displays it for characters that arent space, we can get away with this "optimization",
     51  106e							; and avoid adding color data
     52  106e		       c9 20		      cmp	#BLANK_CHAR
     53  1070		       f0 04		      beq	dont_color
     54  1072		       a9 00		      lda	#RED_COLOR_CODE
     55  1074		       91 02		      sta	(color_cursor),Y
     56  1076
     57  1076				   dont_color
     58  1076		       20 7e 10 	      jsr	add_one_to_screen_cursor
     59  1079		       68		      pla		; put the current 'count' (remaining times to draw character) back on accumulator
     60  107a		       4c 5e 10 	      jmp	draw_character
     61  107d
     62  107d				   draw_character_end
     63  107d		       60		      rts
     64  107e
     65  107e
     66  107e
     67  107e				   add_one_to_screen_cursor
     68  107e		       18		      clc
     69  107f		       a5 00		      lda	screen_cursor	; load and add to low byte
     70  1081		       69 01		      adc	#$1
     71  1083		       85 00		      sta	screen_cursor
     72  1085		       a5 01		      lda	screen_cursor+1
     73  1087		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
     74  1089		       85 01		      sta	screen_cursor+1
     75  108b
     76  108b							; add to color cursor as well
     77  108b		       18		      clc
     78  108c		       a5 02		      lda	color_cursor	; load and add to low byte
     79  108e		       69 01		      adc	#$1
     80  1090		       85 02		      sta	color_cursor
     81  1092		       a5 03		      lda	color_cursor+1
     82  1094		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
     83  1096		       85 03		      sta	color_cursor+1
     84  1098		       60		      rts
     85  1099
     86  1099				   check_if_screen_cursor_at_end		; set carry flag if screen_cursor at position $1ff9 (8185
     87  1099		       a5 00		      lda	screen_cursor	; load value at screen_cursor low byte
     88  109b		       c9 fa		      cmp	#END_OF_SCREEN_LOW_BYTE
     89  109d		       d0 06		      bne	check_if_screen_cursor_at_end_return_false	; if low byte doesnt match, return with carry flag as neg
     90  109f
     91  109f		       a5 01		      lda	screen_cursor+1
     92  10a1		       c9 1f		      cmp	#END_OF_SCREEN_HIGH_BYTE
     93  10a3		       f0 02		      beq	check_if_screen_cursor_at_end_return_true	; if high byte matches, set carry flag
     94  10a5
     95  10a5				   check_if_screen_cursor_at_end_return_false
     96  10a5		       18		      clc
     97  10a6		       60		      rts
     98  10a7
     99  10a7				   check_if_screen_cursor_at_end_return_true
    100  10a7		       38		      sec
    101  10a8		       60		      rts
------- FILE src/main.s
     91  10a9
     92  10a9							; title screen code jumps here once space pressed
     93  10a9				   gameLoop
     94  10a9		       20 ee 10 	      jsr	update_level
     95  10ac		       a9 00		      lda	#0
     96  10ae		       85 08		      sta	level_reset
     97  10b0		       20 07 12 	      jsr	update_game_state
     98  10b3		       20 d4 10 	      jsr	check_for_secret_key
     99  10b6		       20 e3 10 	      jsr	check_for_reset_key
    100  10b9		       20 cb 10 	      jsr	wait_until_next_frame
    101  10bc		       20 cb 10 	      jsr	wait_until_next_frame
    102  10bf		       20 cb 10 	      jsr	wait_until_next_frame
    103  10c2		       20 cb 10 	      jsr	wait_until_next_frame
    104  10c5		       20 cb 10 	      jsr	wait_until_next_frame
    105  10c8		       4c a9 10 	      jmp	gameLoop
    106  10cb
    107  10cb
    108  10cb				   wait_until_next_frame		; wait one jiffy before completing game loop
    109  10cb		       a5 a2		      lda	jiffy_clock+2
    110  10cd		       c5 0f		      cmp	current_time
    111  10cf		       f0 fa		      beq	wait_until_next_frame
    112  10d1		       85 0f		      sta	current_time
    113  10d3		       60		      rts
    114  10d4
    115  10d4							; update level_completed and level_reset if secret_key pressed
    116  10d4				   check_for_secret_key
    117  10d4		       a5 c5		      lda	currently_pressed_key
    118  10d6		       c9 0d		      cmp	#SECRET_KEY
    119  10d8		       d0 08		      bne	check_for_secret_key_return
    120  10da		       a9 01		      lda	#1
    121  10dc		       85 09		      sta	level_completed
    122  10de		       a9 01		      lda	#1
    123  10e0		       85 08		      sta	level_reset
    124  10e2				   check_for_secret_key_return
    125  10e2		       60		      rts
    126  10e3
    127  10e3				   check_for_reset_key
    128  10e3		       a5 c5		      lda	currently_pressed_key
    129  10e5		       c9 0a		      cmp	#RESET_KEY
    130  10e7		       d0 f9		      bne	check_for_secret_key_return	; todo -- reset  a bunch of state (has_key, )
    131  10e9		       a9 01		      lda	#1
    132  10eb		       85 08		      sta	level_reset
    133  10ed				   check_for_reset_key_return
    134  10ed		       60		      rts
    135  10ee
------- FILE updateLevel.s LEVEL 2 PASS 3
      0  10ee					      include	"updateLevel.s"
      1  10ee		       00 01	   LEVEL_IS_DONE =	1
      2  10ee		       00 00	   LEVEL_NOT_DONE =	0
      3  10ee		       00 01	   SHOULD_RESET =	1
      4  10ee		       00 00	   SHOULD_NOT_RESET =	0
      5  10ee
      6  10ee							; only first 4 bits really matter here; refer to readme for guide on lvl format
      7  10ee		       00 00	   BLANK_SPACE =	0	; 000000000
      8  10ee		       00 10	   STARTING_POINT =	16	; 00010000
      9  10ee		       00 20	   WALL       =	32	; 00100000
     10  10ee		       00 30	   BREAKABLE_WALL =	48	; 00110000
     11  10ee		       00 40	   LOCKED_WALL =	64	; 01000000
     12  10ee		       00 50	   LADDER     =	80	; 01010000
     13  10ee		       00 60	   EXIT       =	96	; 01100000
     14  10ee		       00 70	   PLATFORM   =	112	; 01110000
     15  10ee		       00 80	   KEY	      =	128	; 10000000
     16  10ee		       00 90	   SPIKE      =	144	; 10010000
     17  10ee		       00 a0	   BOOSTER    =	160	; 10100000
     18  10ee
     19  10ee		       00 00	   WALL_COLOR =	0
     20  10ee		       00 00	   BREAKABLE_WALL_COLOR =	0
     21  10ee		       00 00	   LOCKED_WALL_COLOR =	0
     22  10ee		       00 00	   LADDER_COLOR =	0	;6
     23  10ee		       00 00	   EXIT_COLOR =	0	;6
     24  10ee		       00 00	   PLATFORM_COLOR =	0	;4
     25  10ee		       00 00	   SPIKE_COLOR =	0	;2
     26  10ee		       00 00	   KEY_P_COLOR =	0	;7
     27  10ee		       00 00	   SPIKE_P_COLOR =	0	;6
     28  10ee		       00 00	   BOOSTER_P_COLOR =	0	;6
     29  10ee		       00 02	   SQUAREBOT_COLOR =	2
     30  10ee
     31  10ee		       00 00	   BLANK_TILE_CHAR =	$00	; use this instead of BLANK_CHAR, allows me to save space with tileStore
     32  10ee		       00 01	   LADDER_CHAR =	$01
     33  10ee		       00 02	   PLATFORM_CHAR =	$02
     34  10ee		       00 03	   WALL_CHAR  =	$03
     35  10ee		       00 04	   EXIT_CHAR  =	$04
     36  10ee		       00 05	   LOCKED_WALL_CHAR =	$05
     37  10ee		       00 06	   BREAKABLE_WALL_CHAR =	$06
     38  10ee		       00 07	   BOOSTER_P_CHAR =	$07
     39  10ee		       00 08	   KEY_P_CHAR =	$08
     40  10ee		       00 09	   SPIKE_P_CHAR =	$09
     41  10ee		       00 0a	   BOOSTER_A_CHAR =	$0A
     42  10ee		       00 0b	   BOOSTER_AA_CHAR =	$0B
     43  10ee		       00 0c	   KEY_A_CHAR =	$0C
     44  10ee		       00 0d	   SPIKE_A_CHAR =	$0D
     45  10ee		       00 0e	   CHAR_U     =	$0E
     46  10ee		       00 0f	   CHAR_D     =	$0F
     47  10ee		       00 10	   CHAR_L     =	$10
     48  10ee		       00 11	   CHAR_R     =	$11
     49  10ee		       00 12	   SQUAREBOT_CHAR =	$12
     50  10ee
     51  10ee
     52  10ee				   update_level
     53  10ee							; check if the level is completed; set current_level to next_level if so
     54  10ee		       a5 09		      lda	level_completed
     55  10f0		       c9 01		      cmp	#LEVEL_IS_DONE	; (try optimizing later)
     56  10f2		       d0 0c		      bne	dont_update
     57  10f4
     58  10f4							; level is done; reset level completed
     59  10f4		       a9 00		      lda	#LEVEL_NOT_DONE
     60  10f6		       85 09		      sta	level_completed
     61  10f8
     62  10f8							; now set current_level to next_level
     63  10f8		       a5 06		      lda	next_level
     64  10fa		       85 04		      sta	current_level
     65  10fc		       a5 07		      lda	next_level+1
     66  10fe		       85 05		      sta	current_level+1
     67  1100
     68  1100				   dont_update
     69  1100							; now check if level reset was set
     70  1100		       a5 08		      lda	level_reset
     71  1102		       c9 00		      cmp	#0
     72  1104		       d0 01		      bne	continue_update	; if not, go back to game loop
     73  1106		       60		      rts
     74  1107
     75  1107				   continue_update
     76  1107							; if it was, update the level
     77  1107		       a9 00		      lda	#SCREEN_CURSOR_BEGINNING_LOW_BYTE
     78  1109		       85 00		      sta	screen_cursor
     79  110b		       a9 1e		      lda	#SCREEN_CURSOR_BEGINNING_HIGH_BYTE
     80  110d		       85 01		      sta	screen_cursor+1
     81  110f
     82  110f		       a9 00		      lda	#COLOR_CURSOR_BEGINNING_LOW_BYTE
     83  1111		       85 02		      sta	color_cursor
     84  1113		       a9 96		      lda	#COLOR_CURSOR_BEGINNING_HIGH_BYTE
     85  1115		       85 03		      sta	color_cursor+1
     86  1117
     87  1117		       a2 00		      ldx	#0
     88  1119		       a0 00		      ldy	#0
     89  111b		       84 0a		      sty	level_data_index
     90  111d
     91  111d		       a9 00		      lda	#0
     92  111f		       85 14		      sta	jump_info
     93  1121		       85 18		      sta	attached_powerups
     94  1123		       85 19		      sta	attached_powerups+1
     95  1125		       85 15		      sta	tileStore
     96  1127		       85 16		      sta	tileStore+1
     97  1129		       85 17		      sta	tileStore+2
     98  112b
     99  112b							; draw (or redraw on reset) the current level
    100  112b				   draw_level_loop
    101  112b							; y stores our index in the current level data
    102  112b		       a4 0a		      ldy	level_data_index
    103  112d		       b1 04		      lda	(current_level),y	; accumulator stores the number of times to repeat the next byte
    104  112f
    105  112f		       20 4b 11 	      jsr	draw_sequence
    106  1132
    107  1132		       a4 0a		      ldy	level_data_index
    108  1134		       c8		      iny		; set y to point to next length byte (iterate 2 at a time)
    109  1135		       c8		      iny
    110  1136		       84 0a		      sty	level_data_index
    111  1138
    112  1138
    113  1138		       20 99 10 	      jsr	check_if_screen_cursor_at_end
    114  113b		       90 ee		      bcc	draw_level_loop
    115  113d
    116  113d
    117  113d							; update next level pointer to point to byte after current level
    118  113d		       a5 04		      lda	current_level
    119  113f		       18		      clc
    120  1140		       65 0a		      adc	level_data_index
    121  1142		       85 06		      sta	next_level
    122  1144		       a5 05		      lda	current_level+1
    123  1146		       69 00		      adc	#0
    124  1148		       85 07		      sta	next_level+1
    125  114a		       60		      rts
    126  114b
    127  114b
    128  114b
    129  114b				   draw_sequence
    130  114b							; if acc == 0, return; otherwise subtract 1, draw the next 2 chars
    131  114b		       f0 1c		      beq	draw_sequence_end
    132  114d		       38		      sec
    133  114e		       e9 01		      sbc	#1
    134  1150		       48		      pha		; push accumulator onto stack
    135  1151
    136  1151		       a4 0a		      ldy	level_data_index
    137  1153		       c8		      iny		; (so we can access the "element" byte after the length byte)
    138  1154		       b1 04		      lda	(current_level),y	; get formatted byte (see squarebot doc)
    139  1156		       0a		      asl		; lol
    140  1157		       0a		      asl
    141  1158		       0a		      asl
    142  1159		       0a		      asl
    143  115a		       20 6a 11 	      jsr	draw_high_bits	; draw char represented by the 4 high bits
    144  115d
    145  115d		       a4 0a		      ldy	level_data_index
    146  115f		       c8		      iny
    147  1160
    148  1160		       b1 04		      lda	(current_level),y
    149  1162		       20 6a 11 	      jsr	draw_high_bits
    150  1165
    151  1165		       68		      pla
    152  1166		       4c 4b 11 	      jmp	draw_sequence
    153  1169
    154  1169				   draw_sequence_end
    155  1169		       60		      rts
    156  116a
    157  116a
    158  116a							; put the character in the high 4 bits of accumulator on screen (see readme), and move the color and screen cursors ahead
    159  116a				   draw_high_bits
    160  116a		       29 f0		      and	#240	; shave off last 4 bits
    161  116c
    162  116c		       c9 00		      cmp	#BLANK_SPACE
    163  116e		       d0 08		      bne	check_if_starting_point
    164  1170		       a9 00		      lda	#BLANK_TILE_CHAR	; todo; replace with actual chars
    165  1172		       a2 01		      ldx	#1
    166  1174		       20 fc 11 	      jsr	draw_char_in_accumulator
    167  1177		       60		      rts
    168  1178
    169  1178				   check_if_starting_point
    170  1178		       c9 10		      cmp	#STARTING_POINT
    171  117a		       d0 18		      bne	check_if_wall
    172  117c
    173  117c							; set squarebot to starting point
    174  117c		       a5 00		      lda	screen_cursor
    175  117e		       85 10		      sta	squarebot_position
    176  1180		       a5 01		      lda	screen_cursor+1
    177  1182		       85 11		      sta	squarebot_position+1
    178  1184
    179  1184		       a5 02		      lda	color_cursor
    180  1186		       85 12		      sta	squarebot_color_position
    181  1188		       a5 03		      lda	color_cursor+1
    182  118a		       85 13		      sta	squarebot_color_position+1
    183  118c
    184  118c		       a9 12		      lda	#SQUAREBOT_CHAR
    185  118e		       a2 02		      ldx	#SQUAREBOT_COLOR
    186  1190		       20 fc 11 	      jsr	draw_char_in_accumulator
    187  1193
    188  1193		       60		      rts
    189  1194
    190  1194
    191  1194				   check_if_wall
    192  1194		       c9 20		      cmp	#WALL
    193  1196		       d0 08		      bne	check_if_breakable_wall
    194  1198		       a9 03		      lda	#WALL_CHAR
    195  119a		       a2 00		      ldx	#WALL_COLOR
    196  119c		       20 fc 11 	      jsr	draw_char_in_accumulator
    197  119f		       60		      rts
    198  11a0
    199  11a0				   check_if_breakable_wall
    200  11a0		       c9 30		      cmp	#BREAKABLE_WALL
    201  11a2		       d0 08		      bne	check_if_locked_wall
    202  11a4		       a9 06		      lda	#BREAKABLE_WALL_CHAR
    203  11a6		       a2 00		      ldx	#BREAKABLE_WALL_COLOR
    204  11a8		       20 fc 11 	      jsr	draw_char_in_accumulator
    205  11ab		       60		      rts
    206  11ac
    207  11ac				   check_if_locked_wall
    208  11ac		       c9 40		      cmp	#LOCKED_WALL
    209  11ae		       d0 08		      bne	check_if_ladder
    210  11b0		       a9 05		      lda	#LOCKED_WALL_CHAR
    211  11b2		       a2 00		      ldx	#LOCKED_WALL_COLOR
    212  11b4		       20 fc 11 	      jsr	draw_char_in_accumulator
    213  11b7		       60		      rts
    214  11b8
    215  11b8				   check_if_ladder
    216  11b8		       c9 50		      cmp	#LADDER
    217  11ba		       d0 08		      bne	check_if_exit
    218  11bc		       a9 01		      lda	#LADDER_CHAR
    219  11be		       a2 00		      ldx	#LADDER_COLOR
    220  11c0		       20 fc 11 	      jsr	draw_char_in_accumulator
    221  11c3		       60		      rts
    222  11c4
    223  11c4				   check_if_exit
    224  11c4		       c9 60		      cmp	#EXIT
    225  11c6		       d0 08		      bne	check_if_platform
    226  11c8		       a9 04		      lda	#EXIT_CHAR
    227  11ca		       a2 00		      ldx	#EXIT_COLOR
    228  11cc		       20 fc 11 	      jsr	draw_char_in_accumulator
    229  11cf		       60		      rts
    230  11d0
    231  11d0				   check_if_platform
    232  11d0		       c9 70		      cmp	#PLATFORM
    233  11d2		       d0 08		      bne	check_if_key
    234  11d4		       a9 02		      lda	#PLATFORM_CHAR
    235  11d6		       a2 00		      ldx	#PLATFORM_COLOR
    236  11d8		       20 fc 11 	      jsr	draw_char_in_accumulator
    237  11db		       60		      rts
    238  11dc
    239  11dc				   check_if_key
    240  11dc		       c9 80		      cmp	#KEY
    241  11de		       d0 08		      bne	check_if_spike
    242  11e0		       a9 08		      lda	#KEY_P_CHAR
    243  11e2		       a2 00		      ldx	#KEY_P_COLOR
    244  11e4		       20 fc 11 	      jsr	draw_char_in_accumulator
    245  11e7		       60		      rts
    246  11e8
    247  11e8				   check_if_spike
    248  11e8		       c9 90		      cmp	#SPIKE
    249  11ea		       d0 08		      bne	check_if_booster
    250  11ec		       a9 09		      lda	#SPIKE_P_CHAR
    251  11ee		       a2 00		      ldx	#SPIKE_P_COLOR
    252  11f0		       20 fc 11 	      jsr	draw_char_in_accumulator
    253  11f3		       60		      rts
    254  11f4
    255  11f4				   check_if_booster
    256  11f4		       a9 07		      lda	#BOOSTER_P_CHAR
    257  11f6		       a2 00		      ldx	#BOOSTER_P_COLOR
    258  11f8		       20 fc 11 	      jsr	draw_char_in_accumulator
    259  11fb		       60		      rts
    260  11fc
    261  11fc
    262  11fc
    263  11fc							; char in accumulator goes in screen cursor, color in x register goes in color cursor, then update cursors
    264  11fc
    265  11fc				   draw_char_in_accumulator
    266  11fc		       a0 00		      ldy	#0
    267  11fe		       91 00		      sta	(screen_cursor),y
    268  1200
    269  1200		       8a		      txa
    270  1201		       91 02		      sta	(color_cursor),y
    271  1203
    272  1203		       20 7e 10 	      jsr	add_one_to_screen_cursor	; add to both screen and color cursor
    273  1206		       60		      rts
------- FILE src/main.s
------- FILE updateGameState_new.s LEVEL 2 PASS 3
      0  1207					      include	"updateGameState_new.s"
      1  1207		       00 e4	   START_OF_FIRST_ROW_LOW_BYTE =	$e4
      2  1207		       00 1f	   START_OF_FIRST_ROW_HIGH_BYTE =	$1f
      3  1207
      4  1207				   update_game_state
      5  1207		       a5 10		      lda	squarebot_position	; likely unnecessary
      6  1209		       85 0b		      sta	new_position
      7  120b		       a5 11		      lda	squarebot_position+1
      8  120d		       85 0c		      sta	new_position+1
      9  120f		       a5 12		      lda	squarebot_color_position
     10  1211		       85 0d		      sta	new_color_position
     11  1213		       a5 13		      lda	squarebot_color_position+1
     12  1215		       85 0e		      sta	new_color_position+1
     13  1217
     14  1217							;maybe we handle jumps first actually
     15  1217							;continue jumping if already jumping
     16  1217							;else check if we are on ground
     17  1217							;if not, fall
     18  1217							;if yes, check if we want to jump
     19  1217							;
     20  1217				   jump_logic
     21  1217		       20 0e 17 	      jsr	get_jump_num
     22  121a		       c9 00		      cmp	#0
     23  121c		       f0 26		      beq	fall_logic
     24  121e		       38		      sec
     25  121f		       e9 01		      sbc	#1
     26  1221		       20 1e 17 	      jsr	set_jump_num
     27  1224		       20 d5 12 	      jsr	move_up
     28  1227		       20 09 17 	      jsr	get_jump_dir
     29  122a				   j_left
     30  122a		       c9 10		      cmp	#$10
     31  122c		       d0 09		      bne	j_right
     32  122e		       20 cb 10 	      jsr	wait_until_next_frame
     33  1231		       20 b3 13 	      jsr	move_left
     34  1234		       4c 74 12 	      jmp	update_return
     35  1237				   j_right
     36  1237		       c9 20		      cmp	#$20
     37  1239		       d0 39		      bne	update_return
     38  123b		       20 cb 10 	      jsr	wait_until_next_frame
     39  123e		       20 17 14 	      jsr	move_right
     40  1241		       4c 74 12 	      jmp	update_return
     41  1244
     42  1244				   fall_logic
     43  1244		       20 35 17 	      jsr	get_down
     44  1247		       20 b4 14 	      jsr	fall_check
     45  124a		       90 29		      bcc	check_if_space_pressed
     46  124c		       20 42 13 	      jsr	move_down
     47  124f		       20 35 17 	      jsr	get_down
     48  1252		       20 b4 14 	      jsr	fall_check
     49  1255		       90 1d		      bcc	update_return	; don't move if we land
     50  1257		       20 09 17 	      jsr	get_jump_dir
     51  125a				   f_left
     52  125a		       c9 10		      cmp	#$10
     53  125c		       d0 09		      bne	f_right
     54  125e		       20 cb 10 	      jsr	wait_until_next_frame
     55  1261		       20 b3 13 	      jsr	move_left
     56  1264		       4c 74 12 	      jmp	update_return
     57  1267				   f_right
     58  1267		       c9 20		      cmp	#$20
     59  1269		       d0 09		      bne	update_return
     60  126b		       20 cb 10 	      jsr	wait_until_next_frame
     61  126e		       20 17 14 	      jsr	move_right
     62  1271		       4c 74 12 	      jmp	update_return
     63  1274
     64  1274				   update_return
     65  1274		       60		      rts
     66  1275
     67  1275				   check_if_space_pressed
     68  1275		       a5 c5		      lda	currently_pressed_key
     69  1277		       c9 20		      cmp	#SPACE_KEY
     70  1279		       d0 10		      bne	check_if_q_pressed
     71  127b		       a9 02		      lda	#JUMP_SIZE
     72  127d		       20 1e 17 	      jsr	set_jump_num
     73  1280		       a9 00		      lda	#00
     74  1282		       20 13 17 	      jsr	set_jump_dir
     75  1285		       20 d5 12 	      jsr	move_up
     76  1288		       4c 74 12 	      jmp	update_return
     77  128b
     78  128b				   check_if_q_pressed
     79  128b		       a5 c5		      lda	currently_pressed_key
     80  128d		       c9 30		      cmp	#Q_KEY
     81  128f		       d0 16		      bne	check_if_e_pressed
     82  1291		       a9 02		      lda	#JUMP_SIZE
     83  1293		       20 1e 17 	      jsr	set_jump_num
     84  1296		       a9 10		      lda	#$10
     85  1298		       20 13 17 	      jsr	set_jump_dir
     86  129b		       20 d5 12 	      jsr	move_up
     87  129e		       20 cb 10 	      jsr	wait_until_next_frame
     88  12a1		       20 b3 13 	      jsr	move_left
     89  12a4		       4c 74 12 	      jmp	update_return
     90  12a7
     91  12a7				   check_if_e_pressed
     92  12a7		       c9 31		      cmp	#E_KEY
     93  12a9		       d0 16		      bne	check_if_a_pressed
     94  12ab		       a9 02		      lda	#JUMP_SIZE
     95  12ad		       20 1e 17 	      jsr	set_jump_num
     96  12b0		       a9 20		      lda	#$20
     97  12b2		       20 13 17 	      jsr	set_jump_dir
     98  12b5		       20 d5 12 	      jsr	move_up
     99  12b8		       20 cb 10 	      jsr	wait_until_next_frame
    100  12bb		       20 17 14 	      jsr	move_right
    101  12be		       4c 74 12 	      jmp	update_return
    102  12c1
    103  12c1				   check_if_a_pressed
    104  12c1		       c9 11		      cmp	#A_KEY
    105  12c3		       d0 06		      bne	check_if_d_pressed
    106  12c5		       20 b3 13 	      jsr	move_left
    107  12c8		       4c 74 12 	      jmp	update_return
    108  12cb
    109  12cb				   check_if_d_pressed
    110  12cb		       c9 12		      cmp	#D_KEY
    111  12cd		       d0 a5		      bne	update_return
    112  12cf		       20 17 14 	      jsr	move_right
    113  12d2		       4c 74 12 	      jmp	update_return
    114  12d5
    115  12d5				   move_up
    116  12d5		       a9 00		      lda	#$0
    117  12d7		       85 1a		      sta	temp
    118  12d9		       20 3a 17 	      jsr	get_up
    119  12dc		       c9 04		      cmp	#EXIT_CHAR
    120  12de		       d0 09		      bne	cont_u
    121  12e0		       a9 01		      lda	#1
    122  12e2		       85 09		      sta	level_completed
    123  12e4		       85 08		      sta	level_reset
    124  12e6		       4c 38 13 	      jmp	return_u
    125  12e9				   cont_u
    126  12e9		       20 7b 14 	      jsr	collision_handler
    127  12ec		       90 4b		      bcc	remove_jumps
    128  12ee		       a5 1a		      lda	temp
    129  12f0		       c9 00		      cmp	#$0
    130  12f2		       f0 13		      beq	post_powerup_u
    131  12f4		       29 f0		      and	#$F0
    132  12f6		       85 1a		      sta	temp
    133  12f8		       a9 0f		      lda	#$0F
    134  12fa		       25 18		      and	attached_powerups
    135  12fc		       18		      clc
    136  12fd		       65 1a		      adc	temp
    137  12ff		       85 18		      sta	attached_powerups
    138  1301		       a9 0f		      lda	#$0F
    139  1303		       25 15		      and	tileStore
    140  1305		       85 15		      sta	tileStore
    141  1307				   post_powerup_u
    142  1307		       20 db 15 	      jsr	delete_squarebot
    143  130a		       20 b9 17 	      jsr	move_new_position_up
    144  130d		       20 5b 18 	      jsr	get_tiles_u
    145  1310		       a5 18		      lda	attached_powerups
    146  1312		       29 0f		      and	#$0F
    147  1314		       c9 01		      cmp	#$01
    148  1316		       d0 0c		      bne	no_booster_u
    149  1318		       a5 18		      lda	attached_powerups
    150  131a		       29 f0		      and	#$F0
    151  131c		       18		      clc
    152  131d		       69 08		      adc	#$08
    153  131f		       85 18		      sta	attached_powerups
    154  1321		       20 cb 14 	      jsr	apply_powerup_logic
    155  1324				   no_booster_u
    156  1324		       20 17 16 	      jsr	update_squarebot
    157  1327		       20 28 16 	      jsr	update_chars
    158  132a		       20 d0 16 	      jsr	draw_squarebot
    159  132d		       20 cb 10 	      jsr	wait_until_next_frame
    160  1330		       a5 18		      lda	attached_powerups
    161  1332		       29 0f		      and	#$0F
    162  1334		       c9 02		      cmp	#$02
    163  1336		       f0 9d		      beq	move_up
    164  1338				   return_u
    165  1338		       60		      rts
    166  1339				   remove_jumps
    167  1339		       a5 14		      lda	jump_info
    168  133b		       29 f0		      and	#$F0	;remove jumps_remaining since we hit a wall
    169  133d		       85 14		      sta	jump_info
    170  133f		       4c 38 13 	      jmp	return_u
    171  1342
    172  1342				   move_down
    173  1342		       a9 00		      lda	#$0
    174  1344		       85 1a		      sta	temp
    175  1346		       20 35 17 	      jsr	get_down
    176  1349		       c9 04		      cmp	#EXIT_CHAR
    177  134b		       d0 09		      bne	cont_d
    178  134d		       a9 01		      lda	#1
    179  134f		       85 09		      sta	level_completed
    180  1351		       85 08		      sta	level_reset
    181  1353		       4c a9 13 	      jmp	return_d
    182  1356				   cont_d
    183  1356		       c9 02		      cmp	#PLATFORM_CHAR	; collision_handler assumes we go through these otherwise
    184  1358		       f0 50		      beq	remove_fall
    185  135a		       20 7b 14 	      jsr	collision_handler
    186  135d		       90 4b		      bcc	remove_fall
    187  135f		       a5 1a		      lda	temp
    188  1361		       c9 00		      cmp	#$0
    189  1363		       f0 13		      beq	post_powerup_d
    190  1365		       29 0f		      and	#$0F
    191  1367		       85 1a		      sta	temp
    192  1369		       a9 f0		      lda	#$F0
    193  136b		       25 18		      and	attached_powerups
    194  136d		       18		      clc
    195  136e		       65 1a		      adc	temp
    196  1370		       85 18		      sta	attached_powerups
    197  1372		       a9 f0		      lda	#$F0
    198  1374		       25 15		      and	tileStore
    199  1376		       85 15		      sta	tileStore
    200  1378				   post_powerup_d
    201  1378		       20 db 15 	      jsr	delete_squarebot
    202  137b		       20 d4 17 	      jsr	move_new_position_down
    203  137e		       20 83 18 	      jsr	get_tiles_d
    204  1381		       a5 18		      lda	attached_powerups
    205  1383		       29 f0		      and	#$F0
    206  1385		       c9 10		      cmp	#$10
    207  1387		       d0 0c		      bne	no_booster_d
    208  1389		       a5 18		      lda	attached_powerups
    209  138b		       29 0f		      and	#$0F
    210  138d		       18		      clc
    211  138e		       69 80		      adc	#$80
    212  1390		       85 18		      sta	attached_powerups
    213  1392		       20 cb 14 	      jsr	apply_powerup_logic
    214  1395				   no_booster_d
    215  1395		       20 17 16 	      jsr	update_squarebot
    216  1398		       20 28 16 	      jsr	update_chars
    217  139b		       20 d0 16 	      jsr	draw_squarebot
    218  139e		       20 cb 10 	      jsr	wait_until_next_frame
    219  13a1		       a5 18		      lda	attached_powerups
    220  13a3		       29 f0		      and	#$F0
    221  13a5		       c9 20		      cmp	#$20
    222  13a7		       f0 99		      beq	move_down
    223  13a9				   return_d
    224  13a9		       60		      rts
    225  13aa				   remove_fall
    226  13aa		       a5 14		      lda	jump_info
    227  13ac		       29 00		      and	#$00	;landed on ground so we aren't jumping or falling
    228  13ae		       85 14		      sta	jump_info
    229  13b0		       4c a9 13 	      jmp	return_d
    230  13b3
    231  13b3				   move_left
    232  13b3		       a9 00		      lda	#$0
    233  13b5		       85 1a		      sta	temp	; preset temp to 0 here so collision_handler logic is simpler
    234  13b7		       20 2e 17 	      jsr	get_left
    235  13ba		       c9 04		      cmp	#EXIT_CHAR	; finish level check
    236  13bc		       d0 09		      bne	cont_l
    237  13be		       a9 01		      lda	#1	; finish level
    238  13c0		       85 09		      sta	level_completed
    239  13c2		       85 08		      sta	level_reset
    240  13c4		       4c 16 14 	      jmp	return_l
    241  13c7				   cont_l
    242  13c7		       20 7b 14 	      jsr	collision_handler	; check collision
    243  13ca		       90 4a		      bcc	return_l
    244  13cc		       a5 1a		      lda	temp
    245  13ce		       c9 00		      cmp	#$0
    246  13d0		       f0 13		      beq	post_powerup_l
    247  13d2		       29 f0		      and	#$F0	; save left
    248  13d4		       85 1a		      sta	temp
    249  13d6		       a9 0f		      lda	#$0F	; assume we hit a powerup
    250  13d8		       25 19		      and	attached_powerups+1
    251  13da		       18		      clc
    252  13db		       65 1a		      adc	temp
    253  13dd		       85 19		      sta	attached_powerups+1
    254  13df		       a9 0f		      lda	#$0F	; clear left of powerup
    255  13e1		       25 16		      and	tileStore+1
    256  13e3		       85 16		      sta	tileStore+1
    257  13e5				   post_powerup_l
    258  13e5		       20 db 15 	      jsr	delete_squarebot	; delete character
    259  13e8		       20 9e 17 	      jsr	move_new_position_left
    260  13eb		       20 ab 18 	      jsr	get_tiles_l
    261  13ee		       a5 19		      lda	attached_powerups+1
    262  13f0		       29 0f		      and	#$0F
    263  13f2		       c9 01		      cmp	#$01
    264  13f4		       d0 0c		      bne	no_booster_l
    265  13f6		       a5 19		      lda	attached_powerups+1
    266  13f8		       29 f0		      and	#$F0
    267  13fa		       18		      clc
    268  13fb		       69 08		      adc	#$08	; turn on the ignition
    269  13fd		       85 19		      sta	attached_powerups+1
    270  13ff		       20 cb 14 	      jsr	apply_powerup_logic
    271  1402				   no_booster_l
    272  1402		       20 17 16 	      jsr	update_squarebot	; update squarebot_position and its color pos
    273  1405		       20 28 16 	      jsr	update_chars	; redraw adjacent characters
    274  1408		       20 d0 16 	      jsr	draw_squarebot	; put squarebot on screen
    275  140b		       20 cb 10 	      jsr	wait_until_next_frame
    276  140e		       a5 19		      lda	attached_powerups+1	; booster time, if we activated booster we move again in the same frame before handling jump logic
    277  1410		       29 0f		      and	#$0F
    278  1412		       c9 02		      cmp	#$02
    279  1414		       f0 9d		      beq	move_left
    280  1416				   return_l
    281  1416		       60		      rts
    282  1417
    283  1417				   move_right
    284  1417		       a9 00		      lda	#$0
    285  1419		       85 1a		      sta	temp	; preset temp to 0 here so collision_handler logic is simpler
    286  141b		       20 29 17 	      jsr	get_right
    287  141e		       c9 04		      cmp	#EXIT_CHAR	; check here if we finish the level so we can rts to game loop
    288  1420		       d0 09		      bne	cont_r
    289  1422		       a9 01		      lda	#1	; finish level
    290  1424		       85 09		      sta	level_completed
    291  1426		       85 08		      sta	level_reset
    292  1428		       4c 7a 14 	      jmp	return_r
    293  142b				   cont_r
    294  142b		       20 7b 14 	      jsr	collision_handler	; check rest of collision
    295  142e		       90 4a		      bcc	return_r	; collided
    296  1430		       a5 1a		      lda	temp	; check for powerup (from collision_handler)
    297  1432		       c9 00		      cmp	#$0	; collision handler will put a 0 here unless we hit a powerup
    298  1434		       f0 13		      beq	post_powerup_r
    299  1436		       29 0f		      and	#$0F	; save right
    300  1438		       85 1a		      sta	temp
    301  143a		       a9 f0		      lda	#$F0	; its a powerup, add the powerup to attached_powerup
    302  143c		       25 19		      and	attached_powerups+1
    303  143e		       18		      clc
    304  143f		       65 1a		      adc	temp
    305  1441		       85 19		      sta	attached_powerups+1
    306  1443		       a9 f0		      lda	#$F0	; clear right of powerup
    307  1445		       25 16		      and	tileStore+1
    308  1447		       85 16		      sta	tileStore+1
    309  1449				   post_powerup_r
    310  1449		       20 db 15 	      jsr	delete_squarebot	; delete character
    311  144c		       20 83 17 	      jsr	move_new_position_right	; new position is where we want to move
    312  144f		       20 d3 18 	      jsr	get_tiles_r
    313  1452		       a5 19		      lda	attached_powerups+1	; if left powerup is readyBooster, change it to ignitedBooster, since apply_powerup_logic doesn't have directional context
    314  1454		       29 f0		      and	#$F0
    315  1456		       c9 10		      cmp	#$10
    316  1458		       d0 0c		      bne	no_booster_r
    317  145a		       a5 19		      lda	attached_powerups+1
    318  145c		       29 0f		      and	#$0F
    319  145e		       18		      clc
    320  145f		       69 80		      adc	#$80	; turn on the ignition
    321  1461		       85 19		      sta	attached_powerups+1
    322  1463		       20 cb 14 	      jsr	apply_powerup_logic
    323  1466				   no_booster_r
    324  1466		       20 17 16 	      jsr	update_squarebot	; update squarebot_position and its color pos
    325  1469		       20 28 16 	      jsr	update_chars	; redraw adjacent characters
    326  146c		       20 d0 16 	      jsr	draw_squarebot	; put squarebot on screen
    327  146f		       20 cb 10 	      jsr	wait_until_next_frame
    328  1472		       a5 19		      lda	attached_powerups+1	; booster time, if we activated booster we move again in the same frame before handling jump logic
    329  1474		       29 f0		      and	#$F0
    330  1476		       c9 20		      cmp	#$20
    331  1478		       f0 9d		      beq	move_right
    332  147a				   return_r
    333  147a		       60		      rts
    334  147b
    335  147b				   collision_handler		; accumulator is the character in the position that squarebot wants to move to
    336  147b							; set carry flag if we can move to this char, otherwise clear it
    337  147b							; if its a powerup, set temp to be the attached_powerup id + attached_powerup id <<4, otherwise return since temp is already 0
    338  147b		       c9 00		      cmp	#BLANK_TILE_CHAR
    339  147d		       f0 31		      beq	return_true
    340  147f		       c9 02		      cmp	#PLATFORM_CHAR
    341  1481		       f0 2d		      beq	return_true	; moving down will double check anyway
    342  1483							;I'll figure out ladders later
    343  1483		       c9 03		      cmp	#WALL_CHAR
    344  1485		       f0 2b		      beq	return_false
    345  1487		       c9 06		      cmp	#BREAKABLE_WALL_CHAR
    346  1489		       f0 27		      beq	return_false
    347  148b		       c9 05		      cmp	#LOCKED_WALL_CHAR
    348  148d		       f0 23		      beq	return_false
    349  148f							;else its a powerup
    350  148f		       c9 07		      cmp	#BOOSTER_P_CHAR
    351  1491		       d0 07		      bne	rpk
    352  1493		       a9 11		      lda	#$11	;set both hex characters to avoid dumb shifts taking up lots of space
    353  1495		       85 1a		      sta	temp
    354  1497		       4c b0 14 	      jmp	return_true
    355  149a				   rpk
    356  149a		       c9 08		      cmp	#KEY_P_CHAR
    357  149c		       d0 07		      bne	rps
    358  149e		       a9 33		      lda	#$33
    359  14a0		       85 1a		      sta	temp
    360  14a2		       4c b0 14 	      jmp	return_true
    361  14a5				   rps
    362  14a5		       c9 09		      cmp	#SPIKE_P_CHAR
    363  14a7		       d0 09		      bne	return_false
    364  14a9		       a9 44		      lda	#$44
    365  14ab		       85 1a		      sta	temp
    366  14ad		       4c b0 14 	      jmp	return_true
    367  14b0
    368  14b0				   return_true
    369  14b0		       38		      sec
    370  14b1		       60		      rts
    371  14b2
    372  14b2				   return_false
    373  14b2		       18		      clc
    374  14b3		       60		      rts
    375  14b4
    376  14b4				   fall_check
    377  14b4		       c9 02		      cmp	#PLATFORM_CHAR
    378  14b6		       f0 fa		      beq	return_false
    379  14b8		       c9 03		      cmp	#WALL_CHAR
    380  14ba		       f0 f6		      beq	return_false
    381  14bc		       c9 05		      cmp	#LOCKED_WALL_CHAR
    382  14be		       f0 f2		      beq	return_false
    383  14c0		       c9 06		      cmp	#BREAKABLE_WALL_CHAR
    384  14c2		       f0 ee		      beq	return_false
    385  14c4		       c9 01		      cmp	#LADDER_CHAR
    386  14c6		       f0 ea		      beq	return_false
    387  14c8		       4c b0 14 	      jmp	return_true	;
    388  14cb
    389  14cb				   apply_powerup_logic
    390  14cb							; ready bosoter: does nothing
    391  14cb							; ignited booster: breaks breakable walls and changes to active booster 
    392  14cb							; active booster: breaks breakable walls and changes to ready booster
    393  14cb							; key: spends itself to break locked walls
    394  14cb		       a5 18		      lda	attached_powerups
    395  14cd		       85 1a		      sta	temp
    396  14cf		       20 3a 17 	      jsr	get_up
    397  14d2		       0a		      asl
    398  14d3		       0a		      asl
    399  14d4		       0a		      asl
    400  14d5		       0a		      asl
    401  14d6		       85 1b		      sta	temp+1
    402  14d8		       20 35 17 	      jsr	get_down
    403  14db		       18		      clc
    404  14dc		       65 1b		      adc	temp+1
    405  14de		       85 1b		      sta	temp+1
    406  14e0		       20 24 15 	      jsr	power_pair_logic
    407  14e3		       a5 1a		      lda	temp
    408  14e5		       85 18		      sta	attached_powerups
    409  14e7		       a5 1b		      lda	temp+1
    410  14e9		       4a		      lsr
    411  14ea		       4a		      lsr
    412  14eb		       4a		      lsr
    413  14ec		       4a		      lsr
    414  14ed		       20 6e 17 	      jsr	set_up	; setting a tile effectively changes that character
    415  14f0		       a5 1b		      lda	temp+1
    416  14f2		       29 0f		      and	#$0F
    417  14f4		       20 62 17 	      jsr	set_down
    418  14f7
    419  14f7		       a5 19		      lda	attached_powerups+1
    420  14f9		       85 1a		      sta	temp
    421  14fb		       20 2e 17 	      jsr	get_left
    422  14fe		       0a		      asl
    423  14ff		       0a		      asl
    424  1500		       0a		      asl
    425  1501		       0a		      asl
    426  1502		       85 1b		      sta	temp+1
    427  1504		       20 29 17 	      jsr	get_right
    428  1507		       18		      clc
    429  1508		       65 1b		      adc	temp+1
    430  150a		       85 1b		      sta	temp+1
    431  150c		       20 24 15 	      jsr	power_pair_logic
    432  150f		       a5 1a		      lda	temp
    433  1511		       85 19		      sta	attached_powerups+1
    434  1513		       a5 1b		      lda	temp+1
    435  1515		       4a		      lsr
    436  1516		       4a		      lsr
    437  1517		       4a		      lsr
    438  1518		       4a		      lsr
    439  1519		       20 52 17 	      jsr	set_left
    440  151c		       a5 1b		      lda	temp+1
    441  151e		       29 0f		      and	#$0F
    442  1520		       20 46 17 	      jsr	set_right
    443  1523		       60		      rts
    444  1524
    445  1524				   power_pair_logic
    446  1524		       a5 1a		      lda	temp
    447  1526		       29 f0		      and	#$F0
    448  1528		       c9 80		      cmp	#$80	; check ignited booster
    449  152a		       d0 1a		      bne	ppl1b
    450  152c		       a5 1b		      lda	temp+1
    451  152e		       29 0f		      and	#$0F	; check opposite tile
    452  1530		       c9 06		      cmp	#BREAKABLE_WALL_CHAR
    453  1532		       d0 06		      bne	ppl1ab
    454  1534		       a5 1b		      lda	temp+1
    455  1536		       29 f0		      and	#$F0
    456  1538		       85 1b		      sta	temp+1	; delete wall
    457  153a				   ppl1ab
    458  153a		       a5 1a		      lda	temp
    459  153c		       29 0f		      and	#$0F
    460  153e		       18		      clc
    461  153f		       69 20		      adc	#$20	; set active booster
    462  1541		       85 1a		      sta	temp
    463  1543		       4c 7f 15 	      jmp	ppl2
    464  1546				   ppl1b
    465  1546		       c9 20		      cmp	#$20	; check active booster
    466  1548		       d0 1a		      bne	ppl1k
    467  154a		       a5 1b		      lda	temp+1
    468  154c		       29 0f		      and	#$0F	; check opposite tile
    469  154e		       c9 06		      cmp	#BREAKABLE_WALL_CHAR
    470  1550		       d0 06		      bne	ppl1rb
    471  1552		       a5 1b		      lda	temp+1
    472  1554		       29 f0		      and	#$F0
    473  1556		       85 1b		      sta	temp+1	; delete wall
    474  1558				   ppl1rb
    475  1558		       a5 1a		      lda	temp
    476  155a		       29 0f		      and	#$0F
    477  155c		       18		      clc
    478  155d		       69 10		      adc	#$10	; set ready booster
    479  155f		       85 1a		      sta	temp
    480  1561		       4c 7f 15 	      jmp	ppl2
    481  1564				   ppl1k
    482  1564		       c9 30		      cmp	#$30	; check key
    483  1566		       d0 17		      bne	ppl2
    484  1568		       a5 1b		      lda	temp+1
    485  156a		       29 f0		      and	#$F0
    486  156c		       c9 50		      cmp	#[LOCKED_WALL_CHAR << 4]
    487  156e		       d0 0f		      bne	ppl2
    488  1570		       a5 1a		      lda	temp
    489  1572		       29 0f		      and	#$0F
    490  1574		       85 1a		      sta	temp	; delete key
    491  1576		       a5 1b		      lda	temp+1
    492  1578		       29 0f		      and	#$0F
    493  157a		       85 1b		      sta	temp+1	; delete wall
    494  157c		       4c 7f 15 	      jmp	ppl2
    495  157f
    496  157f				   ppl2
    497  157f		       a5 1a		      lda	temp
    498  1581		       29 0f		      and	#$0F
    499  1583		       c9 08		      cmp	#$08	; check ignited booster
    500  1585		       d0 1a		      bne	ppl2b
    501  1587		       a5 1b		      lda	temp+1
    502  1589		       29 f0		      and	#$F0
    503  158b		       c9 60		      cmp	#[BREAKABLE_WALL_CHAR << 4]
    504  158d		       d0 06		      bne	ppl2ab
    505  158f		       a5 1b		      lda	temp+1
    506  1591		       29 0f		      and	#$0F
    507  1593		       85 1b		      sta	temp+1	; delete wall
    508  1595				   ppl2ab
    509  1595		       a5 1a		      lda	temp
    510  1597		       29 f0		      and	#$F0
    511  1599		       18		      clc
    512  159a		       69 02		      adc	#$02	; set active booster
    513  159c		       85 1a		      sta	temp
    514  159e		       4c da 15 	      jmp	pplend
    515  15a1				   ppl2b
    516  15a1		       c9 02		      cmp	#$02	; check active booster
    517  15a3		       d0 1a		      bne	ppl2k
    518  15a5		       a5 1b		      lda	temp+1
    519  15a7		       29 f0		      and	#$F0
    520  15a9		       c9 60		      cmp	#[BREAKABLE_WALL_CHAR << 4]
    521  15ab		       d0 06		      bne	ppl2rb
    522  15ad		       a5 1b		      lda	temp+1
    523  15af		       29 0f		      and	#$0F
    524  15b1		       85 1b		      sta	temp+1	; delete wall
    525  15b3				   ppl2rb
    526  15b3		       a5 1a		      lda	temp
    527  15b5		       29 f0		      and	#$F0
    528  15b7		       18		      clc
    529  15b8		       69 01		      adc	#$01	; set ready booster
    530  15ba		       85 1a		      sta	temp
    531  15bc		       4c da 15 	      jmp	pplend
    532  15bf				   ppl2k
    533  15bf		       c9 03		      cmp	#$03	; key
    534  15c1		       d0 17		      bne	pplend
    535  15c3		       a5 1b		      lda	temp+1
    536  15c5		       29 0f		      and	#$0F
    537  15c7		       c9 05		      cmp	#LOCKED_WALL_CHAR
    538  15c9		       d0 0f		      bne	pplend
    539  15cb		       a5 1a		      lda	temp
    540  15cd		       29 f0		      and	#$F0
    541  15cf		       85 1a		      sta	temp	; delete key
    542  15d1		       a5 1b		      lda	temp+1
    543  15d3		       29 f0		      and	#$F0
    544  15d5		       85 1b		      sta	temp+1	; delete wall
    545  15d7		       4c da 15 	      jmp	pplend
    546  15da
    547  15da				   pplend
    548  15da		       60		      rts
    549  15db
    550  15db
    551  15db				   delete_squarebot
    552  15db		       20 ef 17 	      jsr	get_squarebot_draw_position
    553  15de
    554  15de		       a0 17		      ldy	#[ROW_SIZE + 1]
    555  15e0		       20 41 17 	      jsr	get_mid
    556  15e3		       91 10		      sta	(squarebot_position),y
    557  15e5		       a9 00		      lda	#0
    558  15e7		       91 12		      sta	(squarebot_color_position),y
    559  15e9
    560  15e9		       a0 01		      ldy	#1
    561  15eb		       20 3a 17 	      jsr	get_up
    562  15ee		       91 10		      sta	(squarebot_position),y
    563  15f0		       a9 00		      lda	#0
    564  15f2		       91 12		      sta	(squarebot_color_position),y
    565  15f4
    566  15f4		       a0 2d		      ldy	#[[ROW_SIZE*2] + 1]
    567  15f6		       20 35 17 	      jsr	get_down
    568  15f9		       91 10		      sta	(squarebot_position),y
    569  15fb		       a9 00		      lda	#0
    570  15fd		       91 12		      sta	(squarebot_color_position),y
    571  15ff
    572  15ff		       a0 16		      ldy	#ROW_SIZE
    573  1601		       20 2e 17 	      jsr	get_left
    574  1604		       91 10		      sta	(squarebot_position),y
    575  1606		       a9 00		      lda	#0
    576  1608		       91 12		      sta	(squarebot_color_position),y
    577  160a
    578  160a		       a0 18		      ldy	#[ROW_SIZE + 2]
    579  160c		       20 29 17 	      jsr	get_right
    580  160f		       91 10		      sta	(squarebot_position),y
    581  1611		       a9 00		      lda	#0
    582  1613
    583  1613		       20 0a 18 	      jsr	get_squarebot_game_position
    584  1616
    585  1616		       60		      rts
    586  1617
    587  1617
    588  1617				   update_squarebot
    589  1617		       a5 0b		      lda	new_position
    590  1619		       85 10		      sta	squarebot_position
    591  161b		       a5 0c		      lda	new_position+1
    592  161d		       85 11		      sta	squarebot_position+1
    593  161f
    594  161f		       a5 0d		      lda	new_color_position
    595  1621		       85 12		      sta	squarebot_color_position
    596  1623		       a5 0e		      lda	new_color_position+1
    597  1625		       85 13		      sta	squarebot_color_position+1
    598  1627		       60		      rts
    599  1628
    600  1628
    601  1628				   update_chars
    602  1628		       20 3a 17 	      jsr	get_up
    603  162b		       0a		      asl
    604  162c		       0a		      asl
    605  162d		       0a		      asl		; multiply by 8
    606  162e		       85 1c		      sta	charandr
    607  1630
    608  1630		       a5 18		      lda	attached_powerups
    609  1632		       4a		      lsr
    610  1633		       4a		      lsr
    611  1634		       4a		      lsr
    612  1635		       4a		      lsr
    613  1636		       c9 00		      cmp	#0
    614  1638		       f0 06		      beq	update_blank_u
    615  163a		       18		      clc
    616  163b		       69 09		      adc	#9
    617  163d		       0a		      asl
    618  163e		       0a		      asl
    619  163f		       0a		      asl		; we could simplify this but at this rate a few more asls isn't going to be the main thing slowing down the code
    620  1640				   update_blank_u
    621  1640		       85 1d		      sta	charandr+1
    622  1642
    623  1642		       a9 70		      lda	#[CHAR_U << 3]
    624  1644		       85 1e		      sta	charandr+2
    625  1646
    626  1646		       20 a8 16 	      jsr	update_char
    627  1649							;keep in mind we haven't rotated it yet
    628  1649
    629  1649		       20 35 17 	      jsr	get_down
    630  164c		       0a		      asl
    631  164d		       0a		      asl
    632  164e		       0a		      asl
    633  164f		       85 1c		      sta	charandr
    634  1651
    635  1651		       a5 18		      lda	attached_powerups
    636  1653		       25 0f		      and	$0F
    637  1655		       c9 00		      cmp	#0
    638  1657		       f0 06		      beq	update_blank_d
    639  1659		       18		      clc
    640  165a		       69 09		      adc	#9
    641  165c		       0a		      asl
    642  165d		       0a		      asl
    643  165e		       0a		      asl
    644  165f				   update_blank_d
    645  165f		       85 1d		      sta	charandr+1
    646  1661
    647  1661		       a9 78		      lda	#[CHAR_D << 3]
    648  1663		       85 1e		      sta	charandr+2
    649  1665
    650  1665		       20 a8 16 	      jsr	update_char
    651  1668
    652  1668		       20 2e 17 	      jsr	get_left
    653  166b		       0a		      asl
    654  166c		       0a		      asl
    655  166d		       0a		      asl
    656  166e		       85 1c		      sta	charandr
    657  1670
    658  1670		       a5 19		      lda	attached_powerups+1
    659  1672		       4a		      lsr
    660  1673		       4a		      lsr
    661  1674		       4a		      lsr
    662  1675		       4a		      lsr
    663  1676		       c9 00		      cmp	#0
    664  1678		       f0 06		      beq	update_blank_l
    665  167a		       18		      clc
    666  167b		       69 09		      adc	#9
    667  167d		       0a		      asl
    668  167e		       0a		      asl
    669  167f		       0a		      asl
    670  1680				   update_blank_l
    671  1680		       85 1d		      sta	charandr+1
    672  1682
    673  1682		       a9 80		      lda	#[CHAR_L << 3]
    674  1684		       85 1e		      sta	charandr+2
    675  1686
    676  1686		       20 a8 16 	      jsr	update_char
    677  1689
    678  1689		       20 29 17 	      jsr	get_right
    679  168c		       0a		      asl
    680  168d		       0a		      asl
    681  168e		       0a		      asl
    682  168f		       85 1c		      sta	charandr
    683  1691
    684  1691		       a5 19		      lda	attached_powerups+1
    685  1693		       25 0f		      and	$0F
    686  1695		       c9 00		      cmp	#0
    687  1697		       f0 05		      beq	update_blank_r
    688  1699		       69 09		      adc	#9
    689  169b		       0a		      asl
    690  169c		       0a		      asl
    691  169d		       0a		      asl
    692  169e				   update_blank_r
    693  169e		       85 1d		      sta	charandr+1
    694  16a0
    695  16a0		       a9 88		      lda	#[CHAR_R << 3]
    696  16a2		       85 1e		      sta	charandr+2
    697  16a4
    698  16a4		       20 a8 16 	      jsr	update_char
    699  16a7
    700  16a7		       60		      rts		;casual 98 line function
    701  16a8
    702  16a8
    703  16a8				   update_char
    704  16a8		       a2 00		      ldx	#0
    705  16aa				   update_char_loop
    706  16aa		       8a		      txa
    707  16ab		       18		      clc
    708  16ac		       65 1c		      adc	charandr
    709  16ae		       a8		      tay
    710  16af		       b9 00 1c 	      lda	(#character_set_begin),y
    711  16b2		       85 1a		      sta	temp
    712  16b4
    713  16b4		       8a		      txa
    714  16b5		       18		      clc
    715  16b6		       65 1d		      adc	charandr+1
    716  16b8		       a8		      tay
    717  16b9		       b9 00 1c 	      lda	(#character_set_begin),y
    718  16bc		       45 1a		      eor	temp
    719  16be		       85 1a		      sta	temp
    720  16c0
    721  16c0		       8a		      txa
    722  16c1		       18		      clc
    723  16c2		       65 1e		      adc	charandr+2
    724  16c4		       a8		      tay
    725  16c5		       a5 1a		      lda	temp
    726  16c7		       99 00 1c 	      sta	(#character_set_begin),y
    727  16ca
    728  16ca		       e8		      inx
    729  16cb		       e0 08		      cpx	#8
    730  16cd		       d0 db		      bne	update_char_loop
    731  16cf		       60		      rts
    732  16d0
    733  16d0							; if there is a powerup:
    734  16d0							; for each of 8 bytes:
    735  16d0							; load tile byte
    736  16d0							; eor with powerup tile byte
    737  16d0							; store in char byte
    738  16d0
    739  16d0				   draw_squarebot
    740  16d0		       20 ef 17 	      jsr	get_squarebot_draw_position
    741  16d3
    742  16d3		       a9 0e		      lda	#CHAR_U
    743  16d5		       a0 01		      ldy	#1
    744  16d7		       91 10		      sta	(squarebot_position),y
    745  16d9		       a9 00		      lda	#0
    746  16db		       91 12		      sta	(squarebot_color_position),y
    747  16dd
    748  16dd		       a9 0f		      lda	#CHAR_D
    749  16df		       a0 2d		      ldy	#[[ROW_SIZE*2]+1]
    750  16e1		       91 10		      sta	(squarebot_position),y
    751  16e3		       a9 00		      lda	#0
    752  16e5		       91 12		      sta	(squarebot_color_position),y
    753  16e7
    754  16e7		       a9 10		      lda	#CHAR_L
    755  16e9		       a0 16		      ldy	#ROW_SIZE
    756  16eb		       91 10		      sta	(squarebot_position),y
    757  16ed		       a9 00		      lda	#0
    758  16ef		       91 12		      sta	(squarebot_color_position),y
    759  16f1
    760  16f1		       a9 11		      lda	#CHAR_R
    761  16f3		       a0 18		      ldy	#[ROW_SIZE+2]
    762  16f5		       91 10		      sta	(squarebot_position),y
    763  16f7		       a9 00		      lda	#0
    764  16f9		       91 12		      sta	(squarebot_color_position),y
    765  16fb
    766  16fb		       a9 12		      lda	#SQUAREBOT_CHAR
    767  16fd		       a0 17		      ldy	#[ROW_SIZE+1]
    768  16ff		       91 10		      sta	(squarebot_position),y
    769  1701		       a9 02		      lda	#SQUAREBOT_COLOR
    770  1703		       91 12		      sta	(squarebot_color_position),y
    771  1705
    772  1705		       20 0a 18 	      jsr	get_squarebot_game_position
    773  1708		       60		      rts
    774  1709
    775  1709							;real how it works:
    776  1709
    777  1709							;l/r movement:
    778  1709							;store l/r tile you want to move to
    779  1709							;if you win, win
    780  1709							;check collision:
    781  1709							;  store powerup in temp
    782  1709							;  return whether you can move or not
    783  1709							;if you can't move, goto j/f movement
    784  1709							;apply powerup
    785  1709							;get new position
    786  1709							;refresh tiles
    787  1709							;apply powerup logic
    788  1709							;delete old position
    789  1709							;update position
    790  1709							;redraw chars
    791  1709							;draw new position
    792  1709							;wait a jiffy maybe
    793  1709							;check booster
    794  1709							;
    795  1709							;j/f movement
    796  1709							;do similar thing
------- FILE src/main.s
------- FILE updateGameStateHelper.s LEVEL 2 PASS 3
      0  1709					      include	"updateGameStateHelper.s"
      1  1709							; Helper functions for updateGameState
      2  1709
      3  1709				   get_jump_dir
      4  1709		       a5 14		      lda	jump_info
      5  170b		       29 f0		      and	#$F0
      6  170d		       60		      rts
      7  170e
      8  170e				   get_jump_num
      9  170e		       a5 14		      lda	jump_info
     10  1710		       29 0f		      and	#$0F
     11  1712		       60		      rts
     12  1713
     13  1713				   set_jump_dir
     14  1713		       85 1a		      sta	temp
     15  1715		       20 0e 17 	      jsr	get_jump_num
     16  1718		       18		      clc
     17  1719		       65 1a		      adc	temp
     18  171b		       85 14		      sta	jump_info
     19  171d		       60		      rts
     20  171e
     21  171e				   set_jump_num
     22  171e		       85 1a		      sta	temp
     23  1720		       20 09 17 	      jsr	get_jump_dir
     24  1723		       18		      clc
     25  1724		       65 1a		      adc	temp
     26  1726		       85 14		      sta	jump_info
     27  1728		       60		      rts
     28  1729
     29  1729				   get_right
     30  1729		       a5 16		      lda	tileStore+1
     31  172b		       29 0f		      and	#$0F
     32  172d		       60		      rts
     33  172e
     34  172e				   get_left
     35  172e		       a5 16		      lda	tileStore+1
     36  1730		       4a		      lsr
     37  1731		       4a		      lsr
     38  1732		       4a		      lsr
     39  1733		       4a		      lsr
     40  1734		       60		      rts
     41  1735
     42  1735				   get_down
     43  1735		       a5 15		      lda	tileStore
     44  1737		       29 0f		      and	#$0F
     45  1739		       60		      rts
     46  173a
     47  173a				   get_up
     48  173a		       a5 15		      lda	tileStore
     49  173c		       4a		      lsr
     50  173d		       4a		      lsr
     51  173e		       4a		      lsr
     52  173f		       4a		      lsr
     53  1740		       60		      rts
     54  1741
     55  1741				   get_mid
     56  1741		       a5 17		      lda	tileStore+2
     57  1743		       25 0f		      and	$0F
     58  1745		       60		      rts
     59  1746
     60  1746
     61  1746				   set_right
     62  1746		       85 1a		      sta	temp
     63  1748		       a9 f0		      lda	#$F0
     64  174a		       25 16		      and	tileStore+1
     65  174c		       18		      clc
     66  174d		       65 1a		      adc	temp
     67  174f		       85 16		      sta	tileStore+1
     68  1751		       60		      rts
     69  1752
     70  1752				   set_left
     71  1752		       0a		      asl
     72  1753		       0a		      asl
     73  1754		       0a		      asl
     74  1755		       0a		      asl
     75  1756		       85 1a		      sta	temp
     76  1758		       a9 0f		      lda	#$0F
     77  175a		       25 16		      and	tileStore+1
     78  175c		       18		      clc
     79  175d		       65 1a		      adc	temp
     80  175f		       85 16		      sta	tileStore+1
     81  1761		       60		      rts
     82  1762
     83  1762				   set_down
     84  1762		       85 1a		      sta	temp
     85  1764		       a9 f0		      lda	#$F0
     86  1766		       25 15		      and	tileStore
     87  1768		       18		      clc
     88  1769		       65 1a		      adc	temp
     89  176b		       85 15		      sta	tileStore
     90  176d		       60		      rts
     91  176e
     92  176e				   set_up
     93  176e		       0a		      asl
     94  176f		       0a		      asl
     95  1770		       0a		      asl
     96  1771		       0a		      asl
     97  1772		       85 1a		      sta	temp
     98  1774		       a9 0f		      lda	#$0F
     99  1776		       25 15		      and	tileStore
    100  1778		       18		      clc
    101  1779		       65 1a		      adc	temp
    102  177b		       85 15		      sta	tileStore
    103  177d		       60		      rts
    104  177e
    105  177e				   set_mid
    106  177e		       29 0f		      and	#$0F
    107  1780		       85 17		      sta	tileStore+2
    108  1782		       60		      rts
    109  1783
    110  1783				   move_new_position_right
    111  1783		       18		      clc
    112  1784		       a5 0b		      lda	new_position	; load and add to low byte
    113  1786		       69 01		      adc	#$1
    114  1788		       85 0b		      sta	new_position
    115  178a		       a5 0c		      lda	new_position+1
    116  178c		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
    117  178e		       85 0c		      sta	new_position+1
    118  1790		       18		      clc
    119  1791		       a5 0d		      lda	new_color_position	; load and add to low byte
    120  1793		       69 01		      adc	#$1
    121  1795		       85 0d		      sta	new_color_position
    122  1797		       a5 0e		      lda	new_color_position+1
    123  1799		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
    124  179b		       85 0e		      sta	new_color_position+1
    125  179d		       60		      rts
    126  179e
    127  179e				   move_new_position_left
    128  179e		       38		      sec
    129  179f		       a5 0b		      lda	new_position
    130  17a1		       e9 01		      sbc	#$1
    131  17a3		       85 0b		      sta	new_position
    132  17a5		       a5 0c		      lda	new_position+1
    133  17a7		       e9 00		      sbc	#$0
    134  17a9		       85 0c		      sta	new_position+1
    135  17ab		       38		      sec
    136  17ac		       a5 0d		      lda	new_color_position
    137  17ae		       e9 01		      sbc	#$1
    138  17b0		       85 0d		      sta	new_color_position
    139  17b2		       a5 0e		      lda	new_color_position+1
    140  17b4		       e9 00		      sbc	#$0
    141  17b6		       85 0e		      sta	new_color_position+1
    142  17b8		       60		      rts
    143  17b9
    144  17b9
    145  17b9				   move_new_position_up
    146  17b9		       38		      sec
    147  17ba		       a5 0b		      lda	new_position
    148  17bc		       e9 16		      sbc	#ROW_SIZE
    149  17be		       85 0b		      sta	new_position
    150  17c0		       a5 0c		      lda	new_position+1
    151  17c2		       e9 00		      sbc	#$0
    152  17c4		       85 0c		      sta	new_position+1
    153  17c6		       38		      sec
    154  17c7		       a5 0d		      lda	new_color_position
    155  17c9		       e9 16		      sbc	#ROW_SIZE
    156  17cb		       85 0d		      sta	new_color_position
    157  17cd		       a5 0e		      lda	new_color_position+1
    158  17cf		       e9 00		      sbc	#$0
    159  17d1		       85 0e		      sta	new_color_position+1
    160  17d3		       60		      rts
    161  17d4
    162  17d4				   move_new_position_down
    163  17d4		       18		      clc
    164  17d5		       a5 0b		      lda	new_position	; load and add to low byte
    165  17d7		       69 16		      adc	#ROW_SIZE
    166  17d9		       85 0b		      sta	new_position
    167  17db		       a5 0c		      lda	new_position+1
    168  17dd		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
    169  17df		       85 0c		      sta	new_position+1
    170  17e1		       18		      clc
    171  17e2		       a5 0d		      lda	new_color_position	; load and add to low byte
    172  17e4		       69 16		      adc	#ROW_SIZE
    173  17e6		       85 0d		      sta	new_color_position
    174  17e8		       a5 0e		      lda	new_color_position+1
    175  17ea		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
    176  17ec		       85 0e		      sta	new_color_position+1
    177  17ee		       60		      rts
    178  17ef
    179  17ef				   get_squarebot_draw_position
    180  17ef		       38		      sec
    181  17f0		       a5 10		      lda	squarebot_position
    182  17f2		       e9 17		      sbc	#[ROW_SIZE+1]
    183  17f4		       85 10		      sta	squarebot_position
    184  17f6		       a5 11		      lda	squarebot_position+1
    185  17f8		       e9 00		      sbc	#0
    186  17fa		       85 11		      sta	squarebot_position+1
    187  17fc		       38		      sec
    188  17fd		       a5 12		      lda	squarebot_color_position
    189  17ff		       e9 17		      sbc	#[ROW_SIZE+1]
    190  1801		       85 12		      sta	squarebot_color_position
    191  1803		       a5 13		      lda	squarebot_color_position+1
    192  1805		       e9 00		      sbc	#0
    193  1807		       85 13		      sta	squarebot_color_position+1
    194  1809		       60		      rts
    195  180a
    196  180a				   get_squarebot_game_position
    197  180a		       18		      clc
    198  180b		       a5 10		      lda	squarebot_position
    199  180d		       69 17		      adc	#[ROW_SIZE+1]
    200  180f		       85 10		      sta	squarebot_position
    201  1811		       a5 11		      lda	squarebot_position+1
    202  1813		       69 00		      adc	#0
    203  1815		       85 11		      sta	squarebot_position+1
    204  1817		       18		      clc
    205  1818		       a5 12		      lda	squarebot_color_position
    206  181a		       69 17		      adc	#[ROW_SIZE+1]
    207  181c		       85 12		      sta	squarebot_color_position
    208  181e		       a5 13		      lda	squarebot_color_position+1
    209  1820		       69 00		      adc	#0
    210  1822		       85 13		      sta	squarebot_color_position+1
    211  1824		       60		      rts
    212  1825
    213  1825				   get_new_draw_position
    214  1825		       38		      sec
    215  1826		       a5 0b		      lda	new_position
    216  1828		       e9 17		      sbc	#[ROW_SIZE+1]
    217  182a		       85 0b		      sta	new_position
    218  182c		       a5 0c		      lda	new_position+1
    219  182e		       e9 00		      sbc	#0
    220  1830		       85 0c		      sta	new_position+1
    221  1832		       38		      sec
    222  1833		       a5 0d		      lda	new_color_position
    223  1835		       e9 17		      sbc	#[ROW_SIZE+1]
    224  1837		       85 0d		      sta	new_color_position
    225  1839		       a5 0e		      lda	new_color_position+1
    226  183b		       e9 00		      sbc	#0
    227  183d		       85 0e		      sta	new_color_position+1
    228  183f		       60		      rts
    229  1840
    230  1840				   get_new_game_position
    231  1840		       18		      clc
    232  1841		       a5 0b		      lda	new_position
    233  1843		       69 17		      adc	#[ROW_SIZE+1]
    234  1845		       85 0b		      sta	new_position
    235  1847		       a5 0c		      lda	new_position+1
    236  1849		       69 00		      adc	#0
    237  184b		       85 0c		      sta	new_position+1
    238  184d		       18		      clc
    239  184e		       a5 0d		      lda	new_color_position
    240  1850		       69 17		      adc	#[ROW_SIZE+1]
    241  1852		       85 0d		      sta	new_color_position
    242  1854		       a5 0e		      lda	new_color_position+1
    243  1856		       69 00		      adc	#0
    244  1858		       85 0e		      sta	new_color_position+1
    245  185a		       60		      rts
    246  185b
    247  185b				   get_tiles_u
    248  185b		       20 25 18 	      jsr	get_new_draw_position
    249  185e		       20 41 17 	      jsr	get_mid
    250  1861		       20 62 17 	      jsr	set_down
    251  1864		       20 3a 17 	      jsr	get_up
    252  1867		       20 7e 17 	      jsr	set_mid
    253  186a		       a0 16		      ldy	#ROW_SIZE
    254  186c		       b1 0b		      lda	(new_position),y
    255  186e		       20 52 17 	      jsr	set_left
    256  1871		       a0 18		      ldy	#[ROW_SIZE+2]
    257  1873		       b1 0b		      lda	(new_position),y
    258  1875		       20 46 17 	      jsr	set_right
    259  1878		       a0 01		      ldy	#1
    260  187a		       b1 0b		      lda	(new_position),y
    261  187c		       20 6e 17 	      jsr	set_up
    262  187f		       20 40 18 	      jsr	get_new_game_position
    263  1882		       60		      rts
    264  1883
    265  1883				   get_tiles_d
    266  1883		       20 25 18 	      jsr	get_new_draw_position
    267  1886		       20 41 17 	      jsr	get_mid
    268  1889		       20 6e 17 	      jsr	set_up
    269  188c		       20 35 17 	      jsr	get_down
    270  188f		       20 7e 17 	      jsr	set_mid
    271  1892		       a0 16		      ldy	#ROW_SIZE
    272  1894		       b1 0b		      lda	(new_position),y
    273  1896		       20 52 17 	      jsr	set_left
    274  1899		       a0 18		      ldy	#[ROW_SIZE+2]
    275  189b		       b1 0b		      lda	(new_position),y
    276  189d		       20 46 17 	      jsr	set_right
    277  18a0		       a0 2d		      ldy	#[[ROW_SIZE*2]+1]
    278  18a2		       b1 0b		      lda	(new_position),y
    279  18a4		       20 62 17 	      jsr	set_down
    280  18a7		       20 40 18 	      jsr	get_new_game_position
    281  18aa		       60		      rts
    282  18ab
    283  18ab				   get_tiles_l
    284  18ab		       20 25 18 	      jsr	get_new_draw_position
    285  18ae		       20 41 17 	      jsr	get_mid
    286  18b1		       20 46 17 	      jsr	set_right
    287  18b4		       20 2e 17 	      jsr	get_left
    288  18b7		       20 7e 17 	      jsr	set_mid
    289  18ba		       a0 01		      ldy	#1
    290  18bc		       b1 0b		      lda	(new_position),y
    291  18be		       20 6e 17 	      jsr	set_up
    292  18c1		       a0 2d		      ldy	#[[ROW_SIZE*2]+1]
    293  18c3		       b1 0b		      lda	(new_position),y
    294  18c5		       20 62 17 	      jsr	set_down
    295  18c8		       a0 16		      ldy	#ROW_SIZE
    296  18ca		       b1 0b		      lda	(new_position),y
    297  18cc		       20 52 17 	      jsr	set_left
    298  18cf		       20 40 18 	      jsr	get_new_game_position
    299  18d2		       60		      rts
    300  18d3
    301  18d3				   get_tiles_r
    302  18d3		       20 25 18 	      jsr	get_new_draw_position	; moves new_position and its color pos up and left one tile
    303  18d6		       20 41 17 	      jsr	get_mid
    304  18d9		       20 52 17 	      jsr	set_left
    305  18dc		       20 29 17 	      jsr	get_right
    306  18df		       20 7e 17 	      jsr	set_mid
    307  18e2		       a0 01		      ldy	#1
    308  18e4		       b1 0b		      lda	(new_position),y
    309  18e6		       20 6e 17 	      jsr	set_up
    310  18e9		       a0 2d		      ldy	#[[ROW_SIZE*2]+1]
    311  18eb		       b1 0b		      lda	(new_position),y
    312  18ed		       20 62 17 	      jsr	set_down
    313  18f0		       a0 18		      ldy	#[ROW_SIZE+2]
    314  18f2		       b1 0b		      lda	(new_position),y
    315  18f4		       20 46 17 	      jsr	set_right
    316  18f7		       20 40 18 	      jsr	get_new_game_position	; move new_position and its color pos back
    317  18fa		       60		      rts
------- FILE src/main.s
    139  18fb
    140  18fb				   compressed_screen_data_start
    141  18fb					      incbin	"../data/titleScreenData_compressed"	; got via 'bsave ""'
    142  1963
    143  1963				   level_data_start
    144  1963					      incbin	"../data/levels/binary_levels/jesse_1"
    145  19e7					      incbin	"../data/levels/binary_levels/booster_test"
    146  19f5					      incbin	"../data/levels/binary_levels/key_test"
    147  1a0b					      incbin	"../data/levels/binary_levels/2"
    148  1a23					      incbin	"../data/levels/binary_levels/3"
    149  1a7b					      incbin	"../data/levels/binary_levels/4"
    150  1aa7					      incbin	"../data/levels/binary_levels/5"
    151  1ad3					      incbin	"../data/levels/binary_levels/6"
    152  1b05
------- FILE memoryCheck.s LEVEL 2 PASS 3
      0  1b05					      include	"memoryCheck.s"	; code to make sure the program isn't too large and enters screen memory
      1  1b05		       0b 04	   BYTES_USED =	.-$1001	; location counter minus starting location = total bytes used
      2  1b05		       1e 00	   SCREEN_MEMORY_START =	$1e00
 2820 bytes used
      3  1b05					      echo	[BYTES_USED]d, "bytes used"
 Ending program at memory location (base 10):  6917
      4  1b05					      echo	"Ending program at memory location (base 10): ", [.]d
      5  1b05				  -	      if	. >= SCREEN_MEMORY_START	; if program entering screen memory
      6  1b05				  -	      echo	"Throwing error because program is too large, and has entered screen memory!"
      7  1b05				  -	      err
      8  1b05					      endif
------- FILE src/main.s
    154  1b05
    155  1b05
    156  1c00					      org	character_set_begin
    157  1c00		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; blank 0
    158  1c08		       7e 42 7e 42*	      BYTE.b	$7E, $42, $7E, $42, $7E, $42, $7E, $42	; ladder 1
    159  1c10		       ff 5a 00 00*	      BYTE.b	$FF, $5A, $00, $00, $00, $00, $00, $00	; platform 2
    160  1c18		       ff ff ff ff*	      BYTE.b	$FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF	; wall 3
    161  1c20		       ff 9d a3 ac*	      BYTE.b	$FF, $9D, $A3, $AC, $A5, $99, $C3, $FF	; exit (door) 4
    162  1c28		       ff ff c3 c3*	      BYTE.b	$FF, $FF, $C3, $C3, $E7, $E7, $E7, $FF	; locked wall 5
    163  1c30		       ff ee f1 ef*	      BYTE.b	$FF, $EE, $F1, $EF, $57, $8F, $F3, $FF	; breakable wall 6
    164  1c38		       3c 42 99 bd*	      BYTE.b	$3C, $42, $99, $BD, $89, $91, $42, $3C	; booster powerup 7
    165  1c40		       3c 42 99 99*	      BYTE.b	$3C, $42, $99, $99, $91, $99, $42, $3C	; key powerup 8
    166  1c48		       3c 42 91 99*	      BYTE.b	$3C, $42, $91, $99, $BD, $81, $42, $3C	; spike powerup 9
    167  1c50		       08 38 f0 f0*	      BYTE.b	$08, $38, $F0, $F0, $F0, $F0, $38, $08	; ready booster attachment (R) 10
    168  1c58		       08 38 f1 ff*	      BYTE.b	$08, $38, $F1, $FF, $FE, $F1, $38, $08	; active booster attachment (R) 11
    169  1c60		       00 00 fe fe*	      BYTE.b	$00, $00, $FE, $FE, $6A, $0A, $0E, $00	; key attachment (R) 12
    170  1c68		       80 c0 f0 fe*	      BYTE.b	$80, $C0, $F0, $FE, $F0, $C0, $80, $00	; spike attachment (R) 13
    171  1c70		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; charU 14
    172  1c78		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; charD 15
    173  1c80		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; charL 16
    174  1c88		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; charR 17
    175  1c90		       ff 81 a5 81*	      BYTE.b	$FF, $81, $A5, $81, $BD, $81, $81, $FF	; squarebot 18
