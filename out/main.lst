------- FILE src/main.s LEVEL 1 PASS 3
      1  1c98 ????						; title screen program -- use hand-made compression method (esentially just RLE, see rleEncoding.py)
      2  1c98 ????				      processor	6502
      3  1c98 ????
      4 U0027 ????				      seg.u	ZP
      5 U0000					      org	$0
      6 U0000
      7 U0000
      8 U0000		       00 00	   screen_cursor ds.w	1	; stores the current screen memory address
      9 U0002		       00 00	   color_cursor ds.w	1	; store current color memory address
     10 U0004		       00 00	   current_level ds.w	1
     11 U0006		       00 00	   next_level ds.w	1
     12 U0008		       00	   level_reset ds.b	1
     13 U0009		       00	   level_completed ds.b	1
     14 U000a		       00	   level_data_index ds.b	1	; for temporarily saving index registers
     15 U000b		       00 00	   new_position ds.w	1	; use to store position of (proposed) new location for squarebot
     16 U000d		       00 00	   new_color_position ds.w	1	; use to store position of (proposed) new location for squarebot
     17 U000f		       00	   current_time ds.b	1	; store only the last byte of the jiffy clock
     18 U0010		       00 00	   squarebot_position ds.w	1
     19 U0012		       00 00	   squarebot_color_position ds.w	1
     20 U0014		       00	   jump_dir   ds.b	1	; 0 = up, 1=left, 2=right
     21 U0015		       00	   jump_num   ds.b	1
     22 U0016		       00 00 00 00*tile_store ds.b	5
     23 U001b							;colorStore ds.b 5 ; U, D, L, R, M  not the most efficient storage but it needs to also be efficient to decompress
     24 U001b		       00 00 00 00 attached_powerups ds.b	4
     25 U001f							; $0=none  $1=ignitedBooster $A=readyBooster  $B=activeBooster  $C=key  $D=spike(change into shield)
     26 U001f		       00 00 00 00 temp       ds.b	4	; for temporary storage of things. mainly used in updateGameState
     27 U0023		       00	   move_dir_store ds.b	1	; exclusively for move_dir and related subroutines
     28 U0024		       00 00 00    chareor    ds.b	3	; for the incredibly complex operation of eoring chars
     29  1c98 ????				      seg
     30  1c98 ????
     31  1c98 ????						; constants
     32  1c98 ????	       00 20	   BLANK_CHAR =	$20
     33  1c98 ????
     34  1c98 ????	       00 00	   SCREEN_CURSOR_BEGINNING_LOW_BYTE =	$00
     35  1c98 ????	       00 1e	   SCREEN_CURSOR_BEGINNING_HIGH_BYTE =	$1e
     36  1c98 ????
     37  1c98 ????						; last screen location
     38  1c98 ????	       00 fa	   END_OF_SCREEN_LOW_BYTE =	$fa
     39  1c98 ????	       00 1f	   END_OF_SCREEN_HIGH_BYTE =	$1f
     40  1c98 ????
     41  1c98 ????						; beginning of color memory
     42  1c98 ????	       00 00	   COLOR_CURSOR_BEGINNING_LOW_BYTE =	$00
     43  1c98 ????	       00 96	   COLOR_CURSOR_BEGINNING_HIGH_BYTE =	$96
     44  1c98 ????	       00 00	   RED_COLOR_CODE =	0
     45  1c98 ????
     46  1c98 ????	       00 20	   SPACE_KEY  =	$20
     47  1c98 ????	       00 30	   Q_KEY      =	$30
     48  1c98 ????	       00 09	   W_KEY      =	$09
     49  1c98 ????	       00 31	   E_KEY      =	$31
     50  1c98 ????	       00 11	   A_KEY      =	$11
     51  1c98 ????	       00 29	   S_KEY      =	$29
     52  1c98 ????	       00 12	   D_KEY      =	$12
     53  1c98 ????	       00 0d	   SECRET_KEY =	$0d	; press P to skip to next  level
     54  1c98 ????	       00 0a	   RESET_KEY  =	$0a	; press R to restart level i assume
     55  1c98 ????	       00 01	   JUMP_SIZE  =	$01	; number of characters a jump causes
     56  1c98 ????	       00 16	   ROW_SIZE   =	$16
     57  1c98 ????
     58  1c98 ????	       00 01	   DELTA_U    =	$01	;1
     59  1c98 ????	       00 33	   DELTA_D    =	$33	;rowsize+rowsize+1
     60  1c98 ????	       00 16	   DELTA_L    =	$16	;rowsize
     61  1c98 ????	       00 18	   DELTA_R    =	$18	;rowsize+2
     62  1c98 ????	       00 17	   DELTA_M    =	$17	;rowsize+1
     63  1c98 ????						; memory locations
     64  1c98 ????	       10 01	   user_memory_start =	$1001
     65  1c98 ????	       00 c5	   currently_pressed_key =	$c5
     66  1c98 ????	       00 a0	   jiffy_clock =	$A0
     67  1c98 ????	       90 05	   character_info_register =	$9005
     68  1c98 ????	       1c 00	   character_set_begin =	$1c00
     69  1c98 ????
     70  1c98 ????						; begin location counter at 4096 (user memory)
     71  1001					      org	user_memory_start
------- FILE stub.s LEVEL 2 PASS 3
      0  1001					      include	"stub.s"	; stub contains BASIC sys cmd to run the machine language code
      1  1001		       00 9e	   SYS_CMD_TOKEN =	$9e
      2  1001		       00 0a	   STUB_LINE_NUMBER =	10
      3  1001							; BASIC stub -- SYS cmd to run machine language
      4  1001		       0b 10		      dc.w	nextstmt	; link; beginning of basic
      5  1003		       0a 00		      dc.w	STUB_LINE_NUMBER	; line number
      6  1005		       9e 34 31 30*	      dc.b	SYS_CMD_TOKEN, [start]d, 0	; token for sys with operand as address to "start" label
      7  100b				   nextstmt
      8  100b		       00 00		      dc.w	0
------- FILE src/main.s
     73  100d
     74  100d				   start
     75  100d							; use combination of RAM (first 128 chars at 7168) & ROM character set
     76  100d		       a9 ff		      lda	#255
     77  100f		       8d 05 90 	      sta	character_info_register
     78  1012
     79  1012							; initialize some variables in the zero page
     80  1012		       a9 01		      lda	#1
     81  1014		       85 08		      sta	level_reset
     82  1016		       a9 00		      lda	#0
     83  1018		       85 09		      sta	level_completed
     84  101a
     85  101a		       a9 69		      lda	#<level_data_start
     86  101c		       85 04		      sta	current_level
     87  101e		       a9 16		      lda	#>level_data_start
     88  1020		       85 05		      sta	current_level+1
     89  1022
     90  1022		       a9 00		      lda	#0
     91  1024		       85 15		      sta	jump_num
     92  1026		       85 14		      sta	jump_dir
     93  1028		       85 1b		      sta	attached_powerups
     94  102a		       85 1c		      sta	attached_powerups+1
     95  102c		       85 1d		      sta	attached_powerups+2
     96  102e		       85 1e		      sta	attached_powerups+3
     97  1030		       85 16		      sta	tile_store
     98  1032		       85 17		      sta	tile_store+1
     99  1034		       85 18		      sta	tile_store+2
    100  1036		       85 19		      sta	tile_store+3
    101  1038		       85 1a		      sta	tile_store+4
    102  103a		       85 1f		      sta	temp
    103  103c		       85 20		      sta	temp+1
    104  103e		       85 21		      sta	temp+2
    105  1040		       85 22		      sta	temp+3
    106  1042
------- FILE titleScreen.s LEVEL 2 PASS 3
      0  1042					      include	"titleScreen.s"
      1  1042				   display_title_screen
      2  1042		       a9 00		      lda	#SCREEN_CURSOR_BEGINNING_LOW_BYTE
      3  1044		       85 00		      sta	screen_cursor
      4  1046		       a9 1e		      lda	#SCREEN_CURSOR_BEGINNING_HIGH_BYTE	; store 1e in location 01
      5  1048		       85 01		      sta	screen_cursor+1
      6  104a
      7  104a		       a9 00		      lda	#COLOR_CURSOR_BEGINNING_LOW_BYTE
      8  104c		       85 02		      sta	color_cursor
      9  104e		       a9 96		      lda	#COLOR_CURSOR_BEGINNING_HIGH_BYTE
     10  1050		       85 03		      sta	color_cursor+1
     11  1052
     12  1052		       a0 00		      ldy	#$0	; to use for indirect indexed addressing
     13  1054		       a2 00		      ldx	#$0
     14  1056
     15  1056		       20 62 10 	      jsr	draw_title_screen_loop
     16  1059
     17  1059				   infinite_loop
     18  1059		       a5 c5		      lda	currently_pressed_key
     19  105b		       c9 20		      cmp	#SPACE_KEY
     20  105d		       f0 5c		      beq	gameLoop
     21  105f		       4c 59 10 	      jmp	infinite_loop
     22  1062
     23  1062
     24  1062				   draw_title_screen_loop
     25  1062		       bd 01 16 	      lda	compressed_screen_data_start,X	; accumulator stores num times to repeat the byte
     26  1065		       20 70 10 	      jsr	draw_character	; draw the character that many times
     27  1068		       e8		      inx
     28  1069		       e8		      inx
     29  106a		       20 ab 10 	      jsr	check_if_screen_cursor_at_end
     30  106d		       90 f3		      bcc	draw_title_screen_loop
     31  106f		       60		      rts
     32  1070
     33  1070
     34  1070							; draw the character in Y register for (value of accumulator) number of times
     35  1070				   draw_character
     36  1070							; if accumulator == 0, return; otherwise, subtract 1 from accumulator and continue drawing the letter at Y
     37  1070		       f0 1d		      beq	draw_character_end
     38  1072		       38		      sec
     39  1073		       e9 01		      sbc	#1
     40  1075		       48		      pha		; push accumulator onto stack
     41  1076
     42  1076							; store current char at screen cursor location
     43  1076		       a0 00		      ldy	#0
     44  1078		       bd 02 16 	      lda	compressed_screen_data_start+1,X	; load cur char to draw
     45  107b		       18		      clc
     46  107c		       69 80		      adc	#128
     47  107e		       91 00		      sta	(screen_cursor),Y	; draw it on screen
     48  1080
     49  1080							; add color to the screen location if it's not a space
     50  1080							; because our title screen only has one color, and only displays it for characters that arent space, we can get away with this "optimization",
     51  1080							; and avoid adding color data
     52  1080		       c9 20		      cmp	#BLANK_CHAR
     53  1082		       f0 04		      beq	dont_color
     54  1084		       a9 00		      lda	#RED_COLOR_CODE
     55  1086		       91 02		      sta	(color_cursor),Y
     56  1088
     57  1088				   dont_color
     58  1088		       20 90 10 	      jsr	add_one_to_screen_cursor
     59  108b		       68		      pla		; put the current 'count' (remaining times to draw character) back on accumulator
     60  108c		       4c 70 10 	      jmp	draw_character
     61  108f
     62  108f				   draw_character_end
     63  108f		       60		      rts
     64  1090
     65  1090
     66  1090
     67  1090				   add_one_to_screen_cursor
     68  1090		       18		      clc
     69  1091		       a5 00		      lda	screen_cursor	; load and add to low byte
     70  1093		       69 01		      adc	#$1
     71  1095		       85 00		      sta	screen_cursor
     72  1097		       a5 01		      lda	screen_cursor+1
     73  1099		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
     74  109b		       85 01		      sta	screen_cursor+1
     75  109d
     76  109d							; add to color cursor as well
     77  109d		       18		      clc
     78  109e		       a5 02		      lda	color_cursor	; load and add to low byte
     79  10a0		       69 01		      adc	#$1
     80  10a2		       85 02		      sta	color_cursor
     81  10a4		       a5 03		      lda	color_cursor+1
     82  10a6		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
     83  10a8		       85 03		      sta	color_cursor+1
     84  10aa		       60		      rts
     85  10ab
     86  10ab				   check_if_screen_cursor_at_end		; set carry flag if screen_cursor at position $1ff9 (8185
     87  10ab		       a5 00		      lda	screen_cursor	; load value at screen_cursor low byte
     88  10ad		       c9 fa		      cmp	#END_OF_SCREEN_LOW_BYTE
     89  10af		       d0 06		      bne	check_if_screen_cursor_at_end_return_false	; if low byte doesnt match, return with carry flag as neg
     90  10b1
     91  10b1		       a5 01		      lda	screen_cursor+1
     92  10b3		       c9 1f		      cmp	#END_OF_SCREEN_HIGH_BYTE
     93  10b5		       f0 02		      beq	check_if_screen_cursor_at_end_return_true	; if high byte matches, set carry flag
     94  10b7
     95  10b7				   check_if_screen_cursor_at_end_return_false
     96  10b7		       18		      clc
     97  10b8		       60		      rts
     98  10b9
     99  10b9				   check_if_screen_cursor_at_end_return_true
    100  10b9		       38		      sec
    101  10ba		       60		      rts
------- FILE src/main.s
    108  10bb
    109  10bb							; title screen code jumps here once space pressed
    110  10bb				   gameLoop
    111  10bb		       20 00 11 	      jsr	update_level
    112  10be		       a9 00		      lda	#0
    113  10c0		       85 08		      sta	level_reset
    114  10c2		       20 2b 12 	      jsr	update_game_state
    115  10c5		       20 e6 10 	      jsr	check_for_secret_key
    116  10c8		       20 f5 10 	      jsr	check_for_reset_key
    117  10cb		       20 dd 10 	      jsr	wait_until_next_frame
    118  10ce		       20 dd 10 	      jsr	wait_until_next_frame
    119  10d1		       20 dd 10 	      jsr	wait_until_next_frame
    120  10d4		       20 dd 10 	      jsr	wait_until_next_frame
    121  10d7		       20 dd 10 	      jsr	wait_until_next_frame
    122  10da		       4c bb 10 	      jmp	gameLoop
    123  10dd
    124  10dd
    125  10dd				   wait_until_next_frame		; wait one jiffy before completing game loop
    126  10dd		       a5 a2		      lda	jiffy_clock+2
    127  10df		       c5 0f		      cmp	current_time
    128  10e1		       f0 fa		      beq	wait_until_next_frame
    129  10e3		       85 0f		      sta	current_time
    130  10e5		       60		      rts
    131  10e6
    132  10e6							; update level_completed and level_reset if secret_key pressed
    133  10e6				   check_for_secret_key
    134  10e6		       a5 c5		      lda	currently_pressed_key
    135  10e8		       c9 0d		      cmp	#SECRET_KEY
    136  10ea		       d0 08		      bne	check_for_secret_key_return
    137  10ec		       a9 01		      lda	#1
    138  10ee		       85 09		      sta	level_completed
    139  10f0		       a9 01		      lda	#1
    140  10f2		       85 08		      sta	level_reset
    141  10f4				   check_for_secret_key_return
    142  10f4		       60		      rts
    143  10f5
    144  10f5				   check_for_reset_key
    145  10f5		       a5 c5		      lda	currently_pressed_key
    146  10f7		       c9 0a		      cmp	#RESET_KEY
    147  10f9		       d0 f9		      bne	check_for_secret_key_return	; todo -- reset  a bunch of state (has_key, )
    148  10fb		       a9 01		      lda	#1
    149  10fd		       85 08		      sta	level_reset
    150  10ff				   check_for_reset_key_return
    151  10ff		       60		      rts
    152  1100
------- FILE updateLevel.s LEVEL 2 PASS 3
      0  1100					      include	"updateLevel.s"
      1  1100		       00 01	   LEVEL_IS_DONE =	1
      2  1100		       00 00	   LEVEL_NOT_DONE =	0
      3  1100		       00 01	   SHOULD_RESET =	1
      4  1100		       00 00	   SHOULD_NOT_RESET =	0
      5  1100
      6  1100							; only first 4 bits really matter here; refer to readme for guide on lvl format
      7  1100		       00 00	   BLANK_SPACE =	0	; 000000000
      8  1100		       00 10	   STARTING_POINT =	16	; 00010000
      9  1100		       00 20	   WALL       =	32	; 00100000
     10  1100		       00 30	   BREAKABLE_WALL =	48	; 00110000
     11  1100		       00 40	   LOCKED_WALL =	64	; 01000000
     12  1100		       00 50	   LADDER     =	80	; 01010000
     13  1100		       00 60	   EXIT       =	96	; 01100000
     14  1100		       00 70	   PLATFORM   =	112	; 01110000
     15  1100		       00 80	   KEY	      =	128	; 10000000
     16  1100		       00 90	   SPIKE      =	144	; 10010000
     17  1100		       00 a0	   BOOSTER    =	160	; 10100000
     18  1100
     19  1100		       00 00	   WALL_COLOR =	0
     20  1100		       00 00	   BREAKABLE_WALL_COLOR =	0
     21  1100		       00 00	   LOCKED_WALL_COLOR =	0
     22  1100		       00 00	   LADDER_COLOR =	0	;6
     23  1100		       00 00	   EXIT_COLOR =	0	;6
     24  1100		       00 00	   PLATFORM_COLOR =	0	;4
     25  1100		       00 00	   SPIKE_COLOR =	0	;2
     26  1100		       00 00	   KEY_P_COLOR =	0	;7
     27  1100		       00 00	   SPIKE_P_COLOR =	0	;6
     28  1100		       00 00	   BOOSTER_P_COLOR =	0	;6
     29  1100		       00 02	   SQUAREBOT_COLOR =	2
     30  1100
     31  1100		       00 00	   BLANK_TILE_CHAR =	$00	; use this instead of BLANK_CHAR, allows me to save space with tileStore
     32  1100		       00 01	   LADDER_CHAR =	$01
     33  1100		       00 02	   PLATFORM_CHAR =	$02
     34  1100		       00 03	   WALL_CHAR  =	$03
     35  1100		       00 04	   EXIT_CHAR  =	$04
     36  1100		       00 05	   LOCKED_WALL_CHAR =	$05
     37  1100		       00 06	   BREAKABLE_WALL_CHAR =	$06
     38  1100		       00 07	   BOOSTER_P_CHAR =	$07
     39  1100		       00 08	   KEY_P_CHAR =	$08
     40  1100		       00 09	   SPIKE_P_CHAR =	$09
     41  1100		       00 0a	   BOOSTER_A_CHAR =	$0A
     42  1100		       00 0b	   BOOSTER_AA_CHAR =	$0B
     43  1100		       00 0c	   KEY_A_CHAR =	$0C
     44  1100		       00 0d	   SPIKE_A_CHAR =	$0D
     45  1100		       00 0e	   CHAR_U     =	$0E
     46  1100		       00 0f	   CHAR_D     =	$0F
     47  1100		       00 10	   CHAR_L     =	$10
     48  1100		       00 11	   CHAR_R     =	$11
     49  1100		       00 12	   SQUAREBOT_CHAR =	$12
     50  1100
     51  1100
     52  1100				   update_level
     53  1100							; check if the level is completed; set current_level to next_level if so
     54  1100		       a5 09		      lda	level_completed
     55  1102		       c9 01		      cmp	#LEVEL_IS_DONE	; (try optimizing later)
     56  1104		       d0 0c		      bne	dont_update
     57  1106
     58  1106							; level is done; reset level completed
     59  1106		       a9 00		      lda	#LEVEL_NOT_DONE
     60  1108		       85 09		      sta	level_completed
     61  110a
     62  110a							; now set current_level to next_level
     63  110a		       a5 06		      lda	next_level
     64  110c		       85 04		      sta	current_level
     65  110e		       a5 07		      lda	next_level+1
     66  1110		       85 05		      sta	current_level+1
     67  1112
     68  1112				   dont_update
     69  1112							; now check if level reset was set
     70  1112		       a5 08		      lda	level_reset
     71  1114		       c9 00		      cmp	#0
     72  1116		       d0 01		      bne	continue_update	; if not, go back to game loop
     73  1118		       60		      rts
     74  1119
     75  1119				   continue_update
     76  1119							; if it was, update the level
     77  1119		       a9 00		      lda	#SCREEN_CURSOR_BEGINNING_LOW_BYTE
     78  111b		       85 00		      sta	screen_cursor
     79  111d		       a9 1e		      lda	#SCREEN_CURSOR_BEGINNING_HIGH_BYTE
     80  111f		       85 01		      sta	screen_cursor+1
     81  1121
     82  1121		       a9 00		      lda	#COLOR_CURSOR_BEGINNING_LOW_BYTE
     83  1123		       85 02		      sta	color_cursor
     84  1125		       a9 96		      lda	#COLOR_CURSOR_BEGINNING_HIGH_BYTE
     85  1127		       85 03		      sta	color_cursor+1
     86  1129
     87  1129		       a2 00		      ldx	#0
     88  112b		       a0 00		      ldy	#0
     89  112d		       84 0a		      sty	level_data_index
     90  112f
     91  112f		       a9 00		      lda	#0
     92  1131		       85 15		      sta	jump_num
     93  1133		       85 14		      sta	jump_dir
     94  1135		       85 1b		      sta	attached_powerups
     95  1137		       85 1c		      sta	attached_powerups+1
     96  1139		       85 1d		      sta	attached_powerups+2
     97  113b		       85 1e		      sta	attached_powerups+3
     98  113d		       85 16		      sta	tile_store
     99  113f		       85 17		      sta	tile_store+1
    100  1141		       85 18		      sta	tile_store+2
    101  1143		       85 19		      sta	tile_store+3
    102  1145		       85 1a		      sta	tile_store+4
    103  1147		       85 1f		      sta	temp
    104  1149		       85 20		      sta	temp+1
    105  114b		       85 21		      sta	temp+2
    106  114d		       85 22		      sta	temp+3
    107  114f
    108  114f							; draw (or redraw on reset) the current level
    109  114f				   draw_level_loop
    110  114f							; y stores our index in the current level data
    111  114f		       a4 0a		      ldy	level_data_index
    112  1151		       b1 04		      lda	(current_level),y	; accumulator stores the number of times to repeat the next byte
    113  1153
    114  1153		       20 6f 11 	      jsr	draw_sequence
    115  1156
    116  1156		       a4 0a		      ldy	level_data_index
    117  1158		       c8		      iny		; set y to point to next length byte (iterate 2 at a time)
    118  1159		       c8		      iny
    119  115a		       84 0a		      sty	level_data_index
    120  115c
    121  115c
    122  115c		       20 ab 10 	      jsr	check_if_screen_cursor_at_end
    123  115f		       90 ee		      bcc	draw_level_loop
    124  1161
    125  1161
    126  1161							; update next level pointer to point to byte after current level
    127  1161		       a5 04		      lda	current_level
    128  1163		       18		      clc
    129  1164		       65 0a		      adc	level_data_index
    130  1166		       85 06		      sta	next_level
    131  1168		       a5 05		      lda	current_level+1
    132  116a		       69 00		      adc	#0
    133  116c		       85 07		      sta	next_level+1
    134  116e		       60		      rts
    135  116f
    136  116f
    137  116f
    138  116f				   draw_sequence
    139  116f							; if acc == 0, return; otherwise subtract 1, draw the next 2 chars
    140  116f		       f0 1c		      beq	draw_sequence_end
    141  1171		       38		      sec
    142  1172		       e9 01		      sbc	#1
    143  1174		       48		      pha		; push accumulator onto stack
    144  1175
    145  1175		       a4 0a		      ldy	level_data_index
    146  1177		       c8		      iny		; (so we can access the "element" byte after the length byte)
    147  1178		       b1 04		      lda	(current_level),y	; get formatted byte (see squarebot doc)
    148  117a		       0a		      asl		; lol
    149  117b		       0a		      asl
    150  117c		       0a		      asl
    151  117d		       0a		      asl
    152  117e		       20 8e 11 	      jsr	draw_high_bits	; draw char represented by the 4 high bits
    153  1181
    154  1181		       a4 0a		      ldy	level_data_index
    155  1183		       c8		      iny
    156  1184
    157  1184		       b1 04		      lda	(current_level),y
    158  1186		       20 8e 11 	      jsr	draw_high_bits
    159  1189
    160  1189		       68		      pla
    161  118a		       4c 6f 11 	      jmp	draw_sequence
    162  118d
    163  118d				   draw_sequence_end
    164  118d		       60		      rts
    165  118e
    166  118e
    167  118e							; put the character in the high 4 bits of accumulator on screen (see readme), and move the color and screen cursors ahead
    168  118e				   draw_high_bits
    169  118e		       29 f0		      and	#240	; shave off last 4 bits
    170  1190
    171  1190		       c9 00		      cmp	#BLANK_SPACE
    172  1192		       d0 08		      bne	check_if_starting_point
    173  1194		       a9 00		      lda	#BLANK_TILE_CHAR	; todo; replace with actual chars
    174  1196		       a2 01		      ldx	#1
    175  1198		       20 20 12 	      jsr	draw_char_in_accumulator
    176  119b		       60		      rts
    177  119c
    178  119c				   check_if_starting_point
    179  119c		       c9 10		      cmp	#STARTING_POINT
    180  119e		       d0 18		      bne	check_if_wall
    181  11a0
    182  11a0							; set squarebot to starting point
    183  11a0		       a5 00		      lda	screen_cursor
    184  11a2		       85 10		      sta	squarebot_position
    185  11a4		       a5 01		      lda	screen_cursor+1
    186  11a6		       85 11		      sta	squarebot_position+1
    187  11a8
    188  11a8		       a5 02		      lda	color_cursor
    189  11aa		       85 12		      sta	squarebot_color_position
    190  11ac		       a5 03		      lda	color_cursor+1
    191  11ae		       85 13		      sta	squarebot_color_position+1
    192  11b0
    193  11b0		       a9 12		      lda	#SQUAREBOT_CHAR
    194  11b2		       a2 02		      ldx	#SQUAREBOT_COLOR
    195  11b4		       20 20 12 	      jsr	draw_char_in_accumulator
    196  11b7		       60		      rts
    197  11b8
    198  11b8				   check_if_wall
    199  11b8		       c9 20		      cmp	#WALL
    200  11ba		       d0 08		      bne	check_if_breakable_wall
    201  11bc		       a9 03		      lda	#WALL_CHAR
    202  11be		       a2 00		      ldx	#WALL_COLOR
    203  11c0		       20 20 12 	      jsr	draw_char_in_accumulator
    204  11c3		       60		      rts
    205  11c4
    206  11c4				   check_if_breakable_wall
    207  11c4		       c9 30		      cmp	#BREAKABLE_WALL
    208  11c6		       d0 08		      bne	check_if_locked_wall
    209  11c8		       a9 06		      lda	#BREAKABLE_WALL_CHAR
    210  11ca		       a2 00		      ldx	#BREAKABLE_WALL_COLOR
    211  11cc		       20 20 12 	      jsr	draw_char_in_accumulator
    212  11cf		       60		      rts
    213  11d0
    214  11d0				   check_if_locked_wall
    215  11d0		       c9 40		      cmp	#LOCKED_WALL
    216  11d2		       d0 08		      bne	check_if_ladder
    217  11d4		       a9 05		      lda	#LOCKED_WALL_CHAR
    218  11d6		       a2 00		      ldx	#LOCKED_WALL_COLOR
    219  11d8		       20 20 12 	      jsr	draw_char_in_accumulator
    220  11db		       60		      rts
    221  11dc
    222  11dc				   check_if_ladder
    223  11dc		       c9 50		      cmp	#LADDER
    224  11de		       d0 08		      bne	check_if_exit
    225  11e0		       a9 01		      lda	#LADDER_CHAR
    226  11e2		       a2 00		      ldx	#LADDER_COLOR
    227  11e4		       20 20 12 	      jsr	draw_char_in_accumulator
    228  11e7		       60		      rts
    229  11e8
    230  11e8				   check_if_exit
    231  11e8		       c9 60		      cmp	#EXIT
    232  11ea		       d0 08		      bne	check_if_platform
    233  11ec		       a9 04		      lda	#EXIT_CHAR
    234  11ee		       a2 00		      ldx	#EXIT_COLOR
    235  11f0		       20 20 12 	      jsr	draw_char_in_accumulator
    236  11f3		       60		      rts
    237  11f4
    238  11f4				   check_if_platform
    239  11f4		       c9 70		      cmp	#PLATFORM
    240  11f6		       d0 08		      bne	check_if_key
    241  11f8		       a9 02		      lda	#PLATFORM_CHAR
    242  11fa		       a2 00		      ldx	#PLATFORM_COLOR
    243  11fc		       20 20 12 	      jsr	draw_char_in_accumulator
    244  11ff		       60		      rts
    245  1200
    246  1200				   check_if_key
    247  1200		       c9 80		      cmp	#KEY
    248  1202		       d0 08		      bne	check_if_spike
    249  1204		       a9 08		      lda	#KEY_P_CHAR
    250  1206		       a2 00		      ldx	#KEY_P_COLOR
    251  1208		       20 20 12 	      jsr	draw_char_in_accumulator
    252  120b		       60		      rts
    253  120c
    254  120c				   check_if_spike
    255  120c		       c9 90		      cmp	#SPIKE
    256  120e		       d0 08		      bne	check_if_booster
    257  1210		       a9 09		      lda	#SPIKE_P_CHAR
    258  1212		       a2 00		      ldx	#SPIKE_P_COLOR
    259  1214		       20 20 12 	      jsr	draw_char_in_accumulator
    260  1217		       60		      rts
    261  1218
    262  1218				   check_if_booster
    263  1218		       a9 07		      lda	#BOOSTER_P_CHAR
    264  121a		       a2 00		      ldx	#BOOSTER_P_COLOR
    265  121c		       20 20 12 	      jsr	draw_char_in_accumulator
    266  121f		       60		      rts
    267  1220
    268  1220
    269  1220
    270  1220							; char in accumulator goes in screen cursor, color in x register goes in color cursor, then update cursors
    271  1220
    272  1220				   draw_char_in_accumulator
    273  1220		       a0 00		      ldy	#0
    274  1222		       91 00		      sta	(screen_cursor),y
    275  1224
    276  1224		       8a		      txa
    277  1225		       91 02		      sta	(color_cursor),y
    278  1227
    279  1227		       20 90 10 	      jsr	add_one_to_screen_cursor	; add to both screen and color cursor
    280  122a		       60		      rts
------- FILE src/main.s
------- FILE updateGameState_new.s LEVEL 2 PASS 3
      0  122b					      include	"updateGameState_new.s"
      1  122b		       00 e4	   START_OF_FIRST_ROW_LOW_BYTE =	$e4
      2  122b		       00 1f	   START_OF_FIRST_ROW_HIGH_BYTE =	$1f
      3  122b
      4  122b							; main logic until line 113:
      5  122b				   update_game_state
      6  122b		       a5 10		      lda	squarebot_position	; likely unnecessary
      7  122d		       85 0b		      sta	new_position
      8  122f		       a5 11		      lda	squarebot_position+1
      9  1231		       85 0c		      sta	new_position+1
     10  1233		       a5 12		      lda	squarebot_color_position
     11  1235		       85 0d		      sta	new_color_position
     12  1237		       a5 13		      lda	squarebot_color_position+1
     13  1239		       85 0e		      sta	new_color_position+1
     14  123b
     15  123b				   jump_logic
     16  123b		       a5 15		      lda	jump_num
     17  123d		       c9 00		      cmp	#$00
     18  123f		       f0 31		      beq	fall_logic
     19  1241		       a0 00		      ldy	#0	; up
     20  1243		       20 26 13 	      jsr	move_dir
     21  1246		       b0 07		      bcs	j_cont	; jump successful
     22  1248		       a9 00		      lda	#$00	; jump failed
     23  124a		       85 15		      sta	jump_num
     24  124c		       4c ac 12 	      jmp	update_return
     25  124f				   j_cont
     26  124f		       38		      sec
     27  1250		       c6 15		      dec	jump_num
     28  1252				   j_left
     29  1252		       a5 14		      lda	jump_dir
     30  1254		       c9 01		      cmp	#$01
     31  1256		       d0 0b		      bne	j_right
     32  1258		       20 dd 10 	      jsr	wait_until_next_frame
     33  125b		       a0 02		      ldy	#2	; left
     34  125d		       20 26 13 	      jsr	move_dir
     35  1260		       4c ac 12 	      jmp	update_return
     36  1263				   j_right
     37  1263		       c9 02		      cmp	#$02
     38  1265		       d0 45		      bne	update_return
     39  1267		       20 dd 10 	      jsr	wait_until_next_frame
     40  126a		       a0 03		      ldy	#3	; right
     41  126c		       20 26 13 	      jsr	move_dir
     42  126f		       4c ac 12 	      jmp	update_return
     43  1272
     44  1272				   fall_logic
     45  1272		       a5 17		      lda	tile_store+1	; down
     46  1274		       20 c5 13 	      jsr	fall_check	; check if we hit the ground, different from collision_handler since platforms are included
     47  1277		       90 3f		      bcc	check_if_space_pressed
     48  1279		       a0 01		      ldy	#1	; down
     49  127b		       20 26 13 	      jsr	move_dir
     50  127e		       a5 17		      lda	tile_store+1	; check if we hit ground again, if we didn't we can move in the jump_dir
     51  1280		       20 c5 13 	      jsr	fall_check
     52  1283		       b0 07		      bcs	f_left
     53  1285		       a9 00		      lda	#$00	; otherwise we stay still
     54  1287		       85 14		      sta	jump_dir
     55  1289		       4c ac 12 	      jmp	update_return
     56  128c				   f_left
     57  128c		       a5 14		      lda	jump_dir
     58  128e		       c9 01		      cmp	#$01
     59  1290		       d0 0b		      bne	f_right
     60  1292		       20 dd 10 	      jsr	wait_until_next_frame
     61  1295		       a0 02		      ldy	#2	; left
     62  1297		       20 26 13 	      jsr	move_dir
     63  129a		       4c ac 12 	      jmp	update_return
     64  129d				   f_right
     65  129d		       c9 02		      cmp	#$02
     66  129f		       d0 0b		      bne	update_return
     67  12a1		       20 dd 10 	      jsr	wait_until_next_frame
     68  12a4		       a0 03		      ldy	#3	; right
     69  12a6		       20 26 13 	      jsr	move_dir
     70  12a9		       4c ac 12 	      jmp	update_return
     71  12ac
     72  12ac				   update_return
     73  12ac		       18		      clc		; reset numbers that should be
     74  12ad		       a9 00		      lda	#0
     75  12af		       85 1f		      sta	temp
     76  12b1		       85 20		      sta	temp+1
     77  12b3		       85 21		      sta	temp+2
     78  12b5		       85 22		      sta	temp+3
     79  12b7		       60		      rts
     80  12b8
     81  12b8				   check_if_space_pressed
     82  12b8		       a5 c5		      lda	currently_pressed_key
     83  12ba		       c9 20		      cmp	#SPACE_KEY
     84  12bc		       d0 12		      bne	check_if_q_pressed
     85  12be		       a0 00		      ldy	#0	; up
     86  12c0		       20 26 13 	      jsr	move_dir
     87  12c3		       90 e7		      bcc	update_return	; jump failed
     88  12c5		       a9 01		      lda	#JUMP_SIZE
     89  12c7		       85 15		      sta	jump_num
     90  12c9		       a9 00		      lda	#$00
     91  12cb		       85 14		      sta	jump_dir
     92  12cd		       4c ac 12 	      jmp	update_return
     93  12d0
     94  12d0				   check_if_q_pressed
     95  12d0		       a5 c5		      lda	currently_pressed_key
     96  12d2		       c9 30		      cmp	#Q_KEY
     97  12d4		       d0 1a		      bne	check_if_e_pressed
     98  12d6		       a0 00		      ldy	#0	; up
     99  12d8		       20 26 13 	      jsr	move_dir
    100  12db		       90 cf		      bcc	update_return	; jump failed
    101  12dd		       a9 01		      lda	#JUMP_SIZE
    102  12df		       85 15		      sta	jump_num
    103  12e1		       a9 01		      lda	#$01
    104  12e3		       85 14		      sta	jump_dir
    105  12e5		       20 dd 10 	      jsr	wait_until_next_frame
    106  12e8		       a0 02		      ldy	#2	; left
    107  12ea		       20 26 13 	      jsr	move_dir
    108  12ed		       4c ac 12 	      jmp	update_return
    109  12f0
    110  12f0				   check_if_e_pressed
    111  12f0		       c9 31		      cmp	#E_KEY
    112  12f2		       d0 1a		      bne	check_if_a_pressed
    113  12f4		       a0 00		      ldy	#0	; up
    114  12f6		       20 26 13 	      jsr	move_dir
    115  12f9		       90 b1		      bcc	update_return	; jump failed
    116  12fb		       a9 01		      lda	#JUMP_SIZE
    117  12fd		       85 15		      sta	jump_num
    118  12ff		       a9 02		      lda	#$02
    119  1301		       85 14		      sta	jump_dir
    120  1303		       20 dd 10 	      jsr	wait_until_next_frame
    121  1306		       a0 03		      ldy	#3	; right
    122  1308		       20 26 13 	      jsr	move_dir
    123  130b		       4c ac 12 	      jmp	update_return
    124  130e
    125  130e				   check_if_a_pressed
    126  130e		       c9 11		      cmp	#A_KEY
    127  1310		       d0 08		      bne	check_if_d_pressed
    128  1312		       a0 02		      ldy	#2	; left
    129  1314		       20 26 13 	      jsr	move_dir
    130  1317		       4c ac 12 	      jmp	update_return
    131  131a
    132  131a				   check_if_d_pressed
    133  131a		       c9 12		      cmp	#D_KEY
    134  131c		       d0 8e		      bne	update_return
    135  131e		       a0 03		      ldy	#3	; right
    136  1320		       20 26 13 	      jsr	move_dir
    137  1323		       4c ac 12 	      jmp	update_return
    138  1326
    139  1326							; The rest is subroutines
    140  1326
    141  1326							;current bugs:
    142  1326							;attached powerup sprites are not working
    143  1326							;jump direction is not reset properly
    144  1326							;platforms get deleted sometimes
    145  1326							;need to replace end screen
    146  1326
    147  1326
    148  1326
    149  1326							;store tile you are moving to
    150  1326							;if you win, win
    151  1326							;check collision:
    152  1326							;  store powerup in temp
    153  1326							;  return whether you can move or not
    154  1326							;if you can't move, return false
    155  1326							;apply powerups you moved into
    156  1326							;get new position
    157  1326							;refresh tiles
    158  1326							;apply powerup logic
    159  1326							;delete old position
    160  1326							;update position
    161  1326							;redraw chars
    162  1326							;draw new position
    163  1326							;wait a jiffy maybe
    164  1326							;check booster if we move again
    165  1326				   move_dir
    166  1326		       84 23		      sty	move_dir_store
    167  1328		       b1 16		      lda	(tile_store),y	; load colliding tile
    168  132a		       c9 04		      cmp	#EXIT_CHAR
    169  132c		       d0 09		      bne	cont_move
    170  132e		       a9 01		      lda	#1	; level complete
    171  1330		       85 09		      sta	level_completed
    172  1332		       85 08		      sta	level_reset
    173  1334		       4c 80 13 	      jmp	return_false_move
    174  1337				   cont_move
    175  1337		       20 82 13 	      jsr	collision_handler
    176  133a		       90 44		      bcc	return_false_move
    177  133c		       a5 1f		      lda	temp	; if we hit a powerup this will be its id
    178  133e		       c9 00		      cmp	#$00
    179  1340		       f0 06		      beq	post_powerup_move
    180  1342		       91 1b		      sta	(attached_powerups),y	; attach powerup
    181  1344		       a9 00		      lda	#$00
    182  1346		       91 16		      sta	(tile_store),y	; remove the powerup tile from the level
    183  1348				   post_powerup_move
    184  1348		       20 dc 13 	      jsr	delete_squarebot
    185  134b		       a4 23		      ldy	move_dir_store
    186  134d		       20 13 14 	      jsr	move_new_position
    187  1350		       20 32 14 	      jsr	get_tiles
    188  1353		       a9 01		      lda	#$01	; eor y with 1 to get opposite side
    189  1355		       45 23		      eor	move_dir_store
    190  1357		       a8		      tay
    191  1358		       b1 1b		      lda	(attached_powerups),y	; ignite ready booster
    192  135a		       c9 0a		      cmp	#$0A
    193  135c		       d0 04		      bne	post_booster
    194  135e		       a9 01		      lda	#$01
    195  1360		       91 1b		      sta	(attached_powerups),y
    196  1362				   post_booster
    197  1362		       20 71 14 	      jsr	apply_powerup_logic
    198  1365		       20 fe 14 	      jsr	update_squarebot
    199  1368		       20 0f 15 	      jsr	update_chars
    200  136b		       20 5c 15 	      jsr	draw_squarebot
    201  136e		       20 dd 10 	      jsr	wait_until_next_frame
    202  1371		       a9 01		      lda	#$01	; eor y with 1 to get opposite side
    203  1373		       45 23		      eor	move_dir_store
    204  1375		       a8		      tay
    205  1376		       b1 1b		      lda	(attached_powerups),y
    206  1378		       c9 0b		      cmp	#$0B
    207  137a		       a4 23		      ldy	move_dir_store
    208  137c		       f0 a8		      beq	move_dir	; if booster activated go again
    209  137e		       38		      sec
    210  137f		       60		      rts		; return true move
    211  1380				   return_false_move
    212  1380		       18		      clc
    213  1381		       60		      rts
    214  1382
    215  1382							;-----
    216  1382				   collision_handler		; accumulator is the character in the position that squarebot wants to move to
    217  1382							; set carry flag if we can move to this char, otherwise clear it
    218  1382							; if its a powerup, set temp to be the attached_powerup id + attached_powerup id <<4, otherwise return since temp is already 0
    219  1382		       a5 16		      lda	tile_store
    220  1384		       85 00		      sta	0
    221  1386		       b1 16		      lda	(tile_store),y
    222  1388		       c9 00		      cmp	#BLANK_TILE_CHAR
    223  138a		       f0 35		      beq	return_true
    224  138c		       c9 02		      cmp	#PLATFORM_CHAR
    225  138e		       f0 31		      beq	return_true	; moving down will double check anyway
    226  1390		       c9 01		      cmp	#LADDER_CHAR
    227  1392		       f0 2d		      beq	return_true	; not fully implemented though
    228  1394		       c9 03		      cmp	#WALL_CHAR
    229  1396		       f0 2b		      beq	return_false
    230  1398		       c9 06		      cmp	#BREAKABLE_WALL_CHAR
    231  139a		       f0 27		      beq	return_false
    232  139c		       c9 05		      cmp	#LOCKED_WALL_CHAR
    233  139e		       f0 23		      beq	return_false
    234  13a0							;else its a powerup
    235  13a0		       c9 07		      cmp	#BOOSTER_P_CHAR
    236  13a2		       d0 07		      bne	rpk
    237  13a4		       a9 0a		      lda	#$0A	;set both hex characters to avoid dumb shifts taking up lots of space
    238  13a6		       85 1f		      sta	temp
    239  13a8		       4c c1 13 	      jmp	return_true
    240  13ab				   rpk
    241  13ab		       c9 08		      cmp	#KEY_P_CHAR
    242  13ad		       d0 07		      bne	rps
    243  13af		       a9 0c		      lda	#$0C
    244  13b1		       85 1f		      sta	temp
    245  13b3		       4c c1 13 	      jmp	return_true
    246  13b6				   rps
    247  13b6		       c9 09		      cmp	#SPIKE_P_CHAR	; not functional
    248  13b8		       d0 09		      bne	return_false
    249  13ba		       a9 0d		      lda	#$0D
    250  13bc		       85 1f		      sta	temp
    251  13be		       4c c1 13 	      jmp	return_true
    252  13c1
    253  13c1				   return_true
    254  13c1		       38		      sec
    255  13c2		       60		      rts
    256  13c3
    257  13c3				   return_false
    258  13c3		       18		      clc
    259  13c4		       60		      rts
    260  13c5
    261  13c5							;-----
    262  13c5				   fall_check
    263  13c5		       c9 02		      cmp	#PLATFORM_CHAR
    264  13c7		       f0 fa		      beq	return_false
    265  13c9		       c9 03		      cmp	#WALL_CHAR
    266  13cb		       f0 f6		      beq	return_false
    267  13cd		       c9 05		      cmp	#LOCKED_WALL_CHAR
    268  13cf		       f0 f2		      beq	return_false
    269  13d1		       c9 06		      cmp	#BREAKABLE_WALL_CHAR
    270  13d3		       f0 ee		      beq	return_false
    271  13d5		       c9 01		      cmp	#LADDER_CHAR
    272  13d7		       f0 ea		      beq	return_false
    273  13d9		       4c c1 13 	      jmp	return_true	;
    274  13dc
    275  13dc							;-----
    276  13dc				   delete_squarebot
    277  13dc		       20 95 15 	      jsr	get_squarebot_draw_position
    278  13df
    279  13df		       a0 01		      ldy	#DELTA_U
    280  13e1		       a5 16		      lda	tile_store	; up
    281  13e3		       91 10		      sta	(squarebot_position),y
    282  13e5		       a9 00		      lda	#0
    283  13e7		       91 12		      sta	(squarebot_color_position),y
    284  13e9
    285  13e9		       a0 33		      ldy	#DELTA_D
    286  13eb		       a5 17		      lda	tile_store+1	;down
    287  13ed		       91 10		      sta	(squarebot_position),y
    288  13ef		       a9 00		      lda	#0
    289  13f1		       91 12		      sta	(squarebot_color_position),y
    290  13f3
    291  13f3		       a0 16		      ldy	#DELTA_L
    292  13f5		       a5 18		      lda	tile_store+2	; left
    293  13f7		       91 10		      sta	(squarebot_position),y
    294  13f9		       a9 00		      lda	#0
    295  13fb		       91 12		      sta	(squarebot_color_position),y
    296  13fd
    297  13fd		       a0 18		      ldy	#DELTA_R
    298  13ff		       a5 19		      lda	tile_store+3	;right
    299  1401		       91 10		      sta	(squarebot_position),y
    300  1403		       a9 00		      lda	#0
    301  1405
    302  1405		       a0 17		      ldy	#DELTA_M
    303  1407		       a5 1a		      lda	tile_store+4	; mid
    304  1409		       91 10		      sta	(squarebot_position),y
    305  140b		       a9 00		      lda	#0
    306  140d		       91 12		      sta	(squarebot_color_position),y
    307  140f
    308  140f		       20 b0 15 	      jsr	get_squarebot_game_position
    309  1412		       60		      rts
    310  1413
    311  1413							;-----
    312  1413				   move_new_position
    313  1413		       20 cb 15 	      jsr	get_new_draw_position
    314  1416
    315  1416		       18		      clc
    316  1417		       a5 0b		      lda	new_position
    317  1419		       71 01		      adc	(DELTA_U),y	; y is the index of the move_dir
    318  141b		       85 0b		      sta	new_position
    319  141d		       a5 0c		      lda	new_position+1
    320  141f		       69 00		      adc	#0
    321  1421		       85 0c		      sta	new_position+1
    322  1423		       18		      clc
    323  1424		       a5 0d		      lda	new_color_position
    324  1426		       71 01		      adc	(DELTA_U),y
    325  1428		       85 0d		      sta	new_color_position
    326  142a		       a5 0e		      lda	new_color_position+1
    327  142c		       69 00		      adc	#0
    328  142e		       85 0c		      sta	new_position+1
    329  1430		       18		      clc
    330  1431		       60		      rts		; no need to undo get_new_draw_position
    331  1432
    332  1432							;-----
    333  1432				   get_tiles
    334  1432		       20 cb 15 	      jsr	get_new_draw_position
    335  1435
    336  1435		       a5 1a		      lda	tile_store+4	; get mid
    337  1437		       a9 01		      lda	#$01	; eor move_dir with 1 to get opposite side
    338  1439		       45 23		      eor	move_dir_store
    339  143b		       a8		      tay
    340  143c		       91 16		      sta	(tile_store),y	; set opposite dir
    341  143e
    342  143e		       a4 23		      ldy	move_dir_store
    343  1440		       b1 16		      lda	(tile_store),y	;get dir
    344  1442		       85 1a		      sta	tile_store+4	; set mid
    345  1444
    346  1444		       b1 01		      lda	(DELTA_U),y
    347  1446		       a8		      tay
    348  1447		       b1 0b		      lda	(new_position),y	; get tile_dir
    349  1449		       a4 23		      ldy	move_dir_store
    350  144b		       91 16		      sta	(tile_store),y	; set tile_dir
    351  144d
    352  144d		       a9 02		      lda	#$02	; get perpendicular tiles
    353  144f		       45 23		      eor	move_dir_store
    354  1451		       a8		      tay		; eor move_dir with 2 to get perpendicular directions
    355  1452		       85 1f		      sta	temp
    356  1454		       b1 01		      lda	(DELTA_U),y
    357  1456		       a8		      tay
    358  1457		       b1 0b		      lda	(new_position),y
    359  1459		       a4 1f		      ldy	temp
    360  145b		       91 16		      sta	(tile_store),y
    361  145d
    362  145d		       a9 01		      lda	#$01
    363  145f		       45 1f		      eor	temp
    364  1461		       a8		      tay
    365  1462		       85 1f		      sta	temp
    366  1464		       b1 01		      lda	(DELTA_U),y
    367  1466		       a8		      tay
    368  1467		       b1 0b		      lda	(new_position),y
    369  1469		       a4 1f		      ldy	temp
    370  146b		       91 16		      sta	(tile_store),y
    371  146d
    372  146d		       20 e6 15 	      jsr	get_new_game_position
    373  1470		       60		      rts
    374  1471
    375  1471							;-----
    376  1471				   apply_powerup_logic
    377  1471							;call prepare_logic for index temp+3 = 0,1,2, and 3. store index in temp+3 since we change y often
    378  1471		       a9 00		      lda	#$0
    379  1473		       85 22		      sta	temp+3
    380  1475		       a8		      tay
    381  1476		       20 94 14 	      jsr	prepare_logic
    382  1479		       e6 22		      inc	temp+3
    383  147b		       20 94 14 	      jsr	prepare_logic
    384  147e		       e6 22		      inc	temp+3
    385  1480		       20 94 14 	      jsr	prepare_logic
    386  1483		       e6 22		      inc	temp+3
    387  1485		       20 94 14 	      jsr	prepare_logic
    388  1488		       a9 00		      lda	#$0
    389  148a		       85 1f		      sta	temp
    390  148c		       85 20		      sta	temp+1
    391  148e		       85 21		      sta	temp+2
    392  1490		       85 22		      sta	temp+3
    393  1492		       a8		      tay		; clean up just to be safe
    394  1493		       60		      rts
    395  1494
    396  1494							;temp = powerup,   temp+1 = tile behind powerup,   temp+2 = tile opposite powerup
    397  1494				   prepare_logic
    398  1494		       a4 22		      ldy	temp+3
    399  1496		       b1 1b		      lda	(attached_powerups),y
    400  1498		       85 1f		      sta	temp
    401  149a		       b1 16		      lda	(tile_store),y
    402  149c		       85 20		      sta	temp+1
    403  149e		       a9 01		      lda	#$01
    404  14a0		       45 22		      eor	temp+3
    405  14a2		       a8		      tay		; eor with 1 which gets us the tile opposite the powerup
    406  14a3		       b1 16		      lda	(tile_store),y
    407  14a5		       85 21		      sta	temp+2
    408  14a7		       20 be 14 	      jsr	powerup_logic	; perform logic
    409  14aa		       a4 22		      ldy	temp+3
    410  14ac		       a5 1f		      lda	temp
    411  14ae		       91 1b		      sta	(attached_powerups),y
    412  14b0		       a5 20		      lda	temp+1
    413  14b2		       91 16		      sta	(tile_store),y
    414  14b4		       a9 01		      lda	#$01
    415  14b6		       45 22		      eor	temp+3
    416  14b8		       a8		      tay
    417  14b9		       a5 21		      lda	temp+2
    418  14bb		       91 16		      sta	(tile_store),y
    419  14bd		       60		      rts
    420  14be
    421  14be							; ready booster: does nothing
    422  14be							; ignited booster: breaks breakable walls and changes to active booster
    423  14be							; active booster: breaks breakable walls and changes to ready booster
    424  14be							; key: spends itself to break locked walls
    425  14be				   powerup_logic		;temp = powerup,   temp+1 = tile behind powerup,   temp+2 = tile opposite powerup
    426  14be		       a5 1f		      lda	temp
    427  14c0		       c9 01		      cmp	#$01	; check ignited booster
    428  14c2		       d0 11		      bne	pl_b
    429  14c4		       a5 21		      lda	temp+2	; check opposite tile
    430  14c6		       c9 06		      cmp	#BREAKABLE_WALL_CHAR
    431  14c8		       d0 04		      bne	pl_ab
    432  14ca		       a9 00		      lda	#$00
    433  14cc		       85 21		      sta	temp+2	; delete wall
    434  14ce				   pl_ab
    435  14ce		       a9 0b		      lda	#$0B	; set active booster
    436  14d0		       85 1f		      sta	temp
    437  14d2		       4c fd 14 	      jmp	pl_return
    438  14d5				   pl_b
    439  14d5		       c9 0b		      cmp	#$0B	; check active booster
    440  14d7		       d0 11		      bne	pl_k
    441  14d9		       a5 21		      lda	temp+2	; check opposite tile
    442  14db		       c9 06		      cmp	#BREAKABLE_WALL_CHAR
    443  14dd		       d0 04		      bne	pl_rb
    444  14df		       a9 00		      lda	#$00
    445  14e1		       85 21		      sta	temp+2	; delete wall
    446  14e3				   pl_rb
    447  14e3		       a9 0a		      lda	#$0A	; set ready booster
    448  14e5		       85 1f		      sta	temp
    449  14e7		       4c fd 14 	      jmp	pl_return
    450  14ea				   pl_k
    451  14ea		       c9 0c		      cmp	#$0C	; check key, slightly unnecessary
    452  14ec		       d0 0f		      bne	pl_return
    453  14ee		       a5 20		      lda	temp+1
    454  14f0		       c9 05		      cmp	#LOCKED_WALL_CHAR
    455  14f2		       d0 09		      bne	pl_return
    456  14f4		       a9 00		      lda	#$00
    457  14f6		       85 1f		      sta	temp	; delete key
    458  14f8		       85 20		      sta	temp+1	; delete wall
    459  14fa		       4c fd 14 	      jmp	pl_return
    460  14fd				   pl_return
    461  14fd		       60		      rts		;-64 lines optimized
    462  14fe
    463  14fe							;-----
    464  14fe				   update_squarebot
    465  14fe		       a5 0b		      lda	new_position
    466  1500		       85 10		      sta	squarebot_position
    467  1502		       a5 0c		      lda	new_position+1
    468  1504		       85 11		      sta	squarebot_position+1
    469  1506
    470  1506		       a5 0d		      lda	new_color_position
    471  1508		       85 12		      sta	squarebot_color_position
    472  150a		       a5 0e		      lda	new_color_position+1
    473  150c		       85 13		      sta	squarebot_color_position+1
    474  150e		       60		      rts
    475  150f
    476  150f							;-----
    477  150f				   update_chars 		; chareor = tile*8,   chareor+1 = powerup*8,	chareor+2 = char*8
    478  150f		       a0 00		      ldy	#$0
    479  1511		       84 20		      sty	temp+1	; x and temp are being used by update_char
    480  1513
    481  1513				   update_char_dir_loop
    482  1513		       b1 16		      lda	(tile_store),y
    483  1515		       0a		      asl
    484  1516		       0a		      asl
    485  1517		       0a		      asl		; multiply by 8 since there are 8 bytes per character
    486  1518		       85 24		      sta	chareor
    487  151a		       b1 1b		      lda	(attached_powerups),y
    488  151c							;add index for rotation
    489  151c		       0a		      asl
    490  151d		       0a		      asl
    491  151e		       0a		      asl
    492  151f		       85 25		      sta	chareor+1
    493  1521		       b1 0e		      lda	(CHAR_U),y
    494  1523		       0a		      asl
    495  1524		       0a		      asl
    496  1525		       0a		      asl
    497  1526		       85 26		      sta	chareor+2
    498  1528		       20 34 15 	      jsr	update_char
    499  152b		       e6 20		      inc	temp+1
    500  152d		       a4 20		      ldy	temp+1
    501  152f
    502  152f		       c0 04		      cpy	#4
    503  1531		       d0 e0		      bne	update_char_dir_loop
    504  1533
    505  1533		       60		      rts
    506  1534
    507  1534				   update_char		; chareor = tile*8,   chareor+1 = powerup*8,	chareor+2 = char*8
    508  1534		       a2 00		      ldx	#0	; x is the incrementer
    509  1536				   update_char_loop
    510  1536		       8a		      txa
    511  1537		       18		      clc
    512  1538		       65 24		      adc	chareor
    513  153a		       a8		      tay
    514  153b		       b9 00 1c 	      lda	(#character_set_begin),y
    515  153e		       85 1f		      sta	temp
    516  1540
    517  1540		       8a		      txa
    518  1541		       18		      clc
    519  1542		       65 25		      adc	chareor+1
    520  1544		       a8		      tay
    521  1545		       b9 00 1c 	      lda	(#character_set_begin),y
    522  1548		       45 1f		      eor	temp
    523  154a		       85 1f		      sta	temp
    524  154c
    525  154c		       8a		      txa
    526  154d		       18		      clc
    527  154e		       65 26		      adc	chareor+2
    528  1550		       a8		      tay
    529  1551		       a5 1f		      lda	temp
    530  1553		       99 00 1c 	      sta	(#character_set_begin),y
    531  1556
    532  1556		       e8		      inx
    533  1557		       e0 08		      cpx	#8
    534  1559		       d0 db		      bne	update_char_loop
    535  155b
    536  155b		       60		      rts
    537  155c
    538  155c							; if there is a powerup:
    539  155c							; for each of 8 bytes:
    540  155c							; load tile byte
    541  155c							; eor with powerup tile byte
    542  155c							; store in char byte
    543  155c
    544  155c							;-----
    545  155c				   draw_squarebot
    546  155c		       20 95 15 	      jsr	get_squarebot_draw_position
    547  155f
    548  155f		       a9 0e		      lda	#CHAR_U
    549  1561		       a0 01		      ldy	#1
    550  1563		       91 10		      sta	(squarebot_position),y
    551  1565		       a9 00		      lda	#0
    552  1567		       91 12		      sta	(squarebot_color_position),y
    553  1569
    554  1569		       a9 0f		      lda	#CHAR_D
    555  156b		       a0 2d		      ldy	#[[ROW_SIZE*2]+1]
    556  156d		       91 10		      sta	(squarebot_position),y
    557  156f		       a9 00		      lda	#0
    558  1571		       91 12		      sta	(squarebot_color_position),y
    559  1573
    560  1573		       a9 10		      lda	#CHAR_L
    561  1575		       a0 16		      ldy	#ROW_SIZE
    562  1577		       91 10		      sta	(squarebot_position),y
    563  1579		       a9 00		      lda	#0
    564  157b		       91 12		      sta	(squarebot_color_position),y
    565  157d
    566  157d		       a9 11		      lda	#CHAR_R
    567  157f		       a0 18		      ldy	#[ROW_SIZE+2]
    568  1581		       91 10		      sta	(squarebot_position),y
    569  1583		       a9 00		      lda	#0
    570  1585		       91 12		      sta	(squarebot_color_position),y
    571  1587
    572  1587		       a9 12		      lda	#SQUAREBOT_CHAR
    573  1589		       a0 17		      ldy	#[ROW_SIZE+1]
    574  158b		       91 10		      sta	(squarebot_position),y
    575  158d		       a9 02		      lda	#SQUAREBOT_COLOR
    576  158f		       91 12		      sta	(squarebot_color_position),y
    577  1591
    578  1591		       20 b0 15 	      jsr	get_squarebot_game_position
    579  1594		       60		      rts
------- FILE src/main.s
------- FILE updateGameStateHelper.s LEVEL 2 PASS 3
      0  1595					      include	"updateGameStateHelper.s"
      1  1595							; Helper functions for updateGameState
      2  1595
      3  1595				   get_squarebot_draw_position
      4  1595		       38		      sec
      5  1596		       a5 10		      lda	squarebot_position
      6  1598		       e9 17		      sbc	#[ROW_SIZE+1]
      7  159a		       85 10		      sta	squarebot_position
      8  159c		       a5 11		      lda	squarebot_position+1
      9  159e		       e9 00		      sbc	#0
     10  15a0		       85 11		      sta	squarebot_position+1
     11  15a2		       38		      sec
     12  15a3		       a5 12		      lda	squarebot_color_position
     13  15a5		       e9 17		      sbc	#[ROW_SIZE+1]
     14  15a7		       85 12		      sta	squarebot_color_position
     15  15a9		       a5 13		      lda	squarebot_color_position+1
     16  15ab		       e9 00		      sbc	#0
     17  15ad		       85 13		      sta	squarebot_color_position+1
     18  15af		       60		      rts
     19  15b0
     20  15b0				   get_squarebot_game_position
     21  15b0		       18		      clc
     22  15b1		       a5 10		      lda	squarebot_position
     23  15b3		       69 17		      adc	#[ROW_SIZE+1]
     24  15b5		       85 10		      sta	squarebot_position
     25  15b7		       a5 11		      lda	squarebot_position+1
     26  15b9		       69 00		      adc	#0
     27  15bb		       85 11		      sta	squarebot_position+1
     28  15bd		       18		      clc
     29  15be		       a5 12		      lda	squarebot_color_position
     30  15c0		       69 17		      adc	#[ROW_SIZE+1]
     31  15c2		       85 12		      sta	squarebot_color_position
     32  15c4		       a5 13		      lda	squarebot_color_position+1
     33  15c6		       69 00		      adc	#0
     34  15c8		       85 13		      sta	squarebot_color_position+1
     35  15ca		       60		      rts
     36  15cb
     37  15cb				   get_new_draw_position
     38  15cb		       38		      sec
     39  15cc		       a5 0b		      lda	new_position
     40  15ce		       e9 17		      sbc	#[ROW_SIZE+1]
     41  15d0		       85 0b		      sta	new_position
     42  15d2		       a5 0c		      lda	new_position+1
     43  15d4		       e9 00		      sbc	#0
     44  15d6		       85 0c		      sta	new_position+1
     45  15d8		       38		      sec
     46  15d9		       a5 0d		      lda	new_color_position
     47  15db		       e9 17		      sbc	#[ROW_SIZE+1]
     48  15dd		       85 0d		      sta	new_color_position
     49  15df		       a5 0e		      lda	new_color_position+1
     50  15e1		       e9 00		      sbc	#0
     51  15e3		       85 0e		      sta	new_color_position+1
     52  15e5		       60		      rts
     53  15e6
     54  15e6				   get_new_game_position
     55  15e6		       18		      clc
     56  15e7		       a5 0b		      lda	new_position
     57  15e9		       69 17		      adc	#[ROW_SIZE+1]
     58  15eb		       85 0b		      sta	new_position
     59  15ed		       a5 0c		      lda	new_position+1
     60  15ef		       69 00		      adc	#0
     61  15f1		       85 0c		      sta	new_position+1
     62  15f3		       18		      clc
     63  15f4		       a5 0d		      lda	new_color_position
     64  15f6		       69 17		      adc	#[ROW_SIZE+1]
     65  15f8		       85 0d		      sta	new_color_position
     66  15fa		       a5 0e		      lda	new_color_position+1
     67  15fc		       69 00		      adc	#0
     68  15fe		       85 0e		      sta	new_color_position+1
     69  1600		       60		      rts
------- FILE src/main.s
    156  1601
    157  1601				   compressed_screen_data_start
    158  1601					      incbin	"../data/titleScreenData_compressed"	; got via 'bsave ""'
    159  1669
    160  1669				   level_data_start
    161  1669					      incbin	"../data/levels/binary_levels/jesse_1"
    162  16ef					      incbin	"../data/levels/binary_levels/jesse_2"
    163  1777					      incbin	"../data/levels/binary_levels/jesse_3"
    164  180b					      incbin	"../data/levels/binary_levels/jesse_4"
    165  18d5
    166  1c00					      org	character_set_begin
    167  1c00		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; blank 0
    168  1c08		       7e 42 7e 42*	      BYTE.b	$7E, $42, $7E, $42, $7E, $42, $7E, $42	; ladder 1
    169  1c10		       ff 5a 00 00*	      BYTE.b	$FF, $5A, $00, $00, $00, $00, $00, $00	; platform 2
    170  1c18		       ff ff ff ff*	      BYTE.b	$FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF	; wall 3
    171  1c20		       ff 9d a3 ac*	      BYTE.b	$FF, $9D, $A3, $AC, $A5, $99, $C3, $FF	; exit (door) 4
    172  1c28		       ff ff c3 c3*	      BYTE.b	$FF, $FF, $C3, $C3, $E7, $E7, $E7, $FF	; locked wall 5
    173  1c30		       ff ee f1 ef*	      BYTE.b	$FF, $EE, $F1, $EF, $57, $8F, $F3, $FF	; breakable wall 6
    174  1c38		       3c 42 99 bd*	      BYTE.b	$3C, $42, $99, $BD, $89, $91, $42, $3C	; booster powerup 7
    175  1c40		       3c 42 99 99*	      BYTE.b	$3C, $42, $99, $99, $91, $99, $42, $3C	; key powerup 8
    176  1c48		       3c 42 91 99*	      BYTE.b	$3C, $42, $91, $99, $BD, $81, $42, $3C	; spike powerup 9
    177  1c50		       10 30 f0 f0*	      BYTE.b	$10, $30, $F0, $F0, $F0, $F0, $30, $10	; ready booster attachment (R) 10, u d l r
    178  1c58		       10 30 f1 ff*	      BYTE.b	$10, $30, $F1, $FF, $FE, $F1, $30, $10	; active booster attachment (R) 11, u d l r
    179  1c60		       00 00 fe fe*	      BYTE.b	$00, $00, $FE, $FE, $6A, $0A, $0E, $00	; key attachment (R) 12, u d l r
    180  1c68		       80 c0 f0 fe*	      BYTE.b	$80, $C0, $F0, $FE, $F0, $C0, $80, $00	; spike attachment (R) 13, u d l r
    181  1c70		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; charU 14
    182  1c78		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; charD 15
    183  1c80		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; charL 16
    184  1c88		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; charR 17
    185  1c90		       ff 81 a5 81*	      BYTE.b	$FF, $81, $A5, $81, $BD, $81, $81, $FF	; squarebot 18
    186  1c98
------- FILE memoryCheck.s LEVEL 2 PASS 3
      0  1c98					      include	"memoryCheck.s"	; code to make sure the program isn't too large and enters screen memory
      1  1c98		       0c 97	   BYTES_USED =	.-$1001	; location counter minus starting location = total bytes used
      2  1c98		       1e 00	   SCREEN_MEMORY_START =	$1e00
 3223 bytes used
      3  1c98					      echo	[BYTES_USED]d, "bytes used"
 Ending program at memory location (base 10):  7320
      4  1c98					      echo	"Ending program at memory location (base 10): ", [.]d
      5  1c98				  -	      if	. >= SCREEN_MEMORY_START	; if program entering screen memory
      6  1c98				  -	      echo	"Throwing error because program is too large, and has entered screen memory!"
      7  1c98				  -	      err
      8  1c98					      endif
------- FILE src/main.s
    188  1c98
    189  1c98
    190  1c98							;assume levels have borders
    191  1c98							;shift character set begin as far as i can
    192  1c98							;get rid of half-bytes
    193  1c98							;16 bit arithmetic
    194  1c98							;storing attachments in each rotation
    195  1c98							;store delta in an array so you can have a dynamic function that draws each character.
