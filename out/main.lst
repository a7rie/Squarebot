------- FILE main.s LEVEL 1 PASS 3
      1  1c98 ????						; title screen program -- use hand-made compression method (esentially just RLE, see rleEncoding.py)
      2  1c98 ????				      processor	6502
      3  1c98 ????
      4 U0022 ????				      seg.u	ZP
      5 U0000					      org	$0
      6 U0000
      7 U0000
      8 U0000		       00 00	   screen_cursor ds.w	1	; stores the current screen memory address
      9 U0002		       00 00	   color_cursor ds.w	1	; store current color memory address
     10 U0004		       00 00	   current_level ds.w	1
     11 U0006		       00 00	   next_level ds.w	1
     12 U0008		       00	   level_reset ds.b	1
     13 U0009		       00	   level_completed ds.b	1
     14 U000a		       00	   level_data_index ds.b	1	; for temporarily saving index registers
     15 U000b		       00 00	   new_position ds.w	1	; use to store position of (proposed) new location for squarebot
     16 U000d		       00 00	   new_color_position ds.w	1	; use to store position of (proposed) new location for squarebot
     17 U000f		       00	   current_time ds.b	1	; store only the last byte of the jiffy clock
     18 U0010		       00 00	   squarebot_position ds.w	1
     19 U0012		       00 00	   squarebot_color_position ds.w	1
     20 U0014		       00	   jump_info  ds.b	1	; split in half, first hex=jump direction 0=up 1=left 2=right, second half=jumps remaining
     21 U0015		       00 00 00    tile_store ds.b	3	; UUUUDDDD LLLLRRRR 0000MMMM
     22 U0018							;colorStore ds.b 3 ; 0UUU0DDD 0LLL0RRR 00000MMM   not the most efficient storage but it needs to also be efficient to decompress
     23 U0018		       00 00	   attached_powerups ds.b	2	; 4 bits for each side, ordered U,D,L,R.
     24 U001a							; 0=none  1=readyBooster  2=activeBooster  3=key 4=spike(not implemented)  add more powerups here   8=ignitedBooster
     25 U001a		       00 00	   temp       ds.w	1	; for temporary storage of things. mainly used in updateGameState
     26 U001c		       00 00 00    charandr   ds.b	3	; for the incredibly complex operation of anding chars
     27 U001f		       00	   count_chars_drawn ds.b	1	; count number of chars drawn on screen in the current run
     28 U0020		       00	   temp_a     ds.b	1	; store acc
     29 U0021		       00	   temp_x     ds.b	1	; store x
     30  1c98 ????				      seg
     31  1c98 ????
     32  1c98 ????						; constants
     33  1c98 ????	       00 20	   BLANK_CHAR =	$20
     34  1c98 ????
     35  1c98 ????	       00 00	   SCREEN_CURSOR_BEGINNING_LOW_BYTE =	$00
     36  1c98 ????	       00 1e	   SCREEN_CURSOR_BEGINNING_HIGH_BYTE =	$1e
     37  1c98 ????
     38  1c98 ????						; last screen location
     39  1c98 ????	       00 fa	   END_OF_SCREEN_LOW_BYTE =	$fa
     40  1c98 ????	       00 1f	   END_OF_SCREEN_HIGH_BYTE =	$1f
     41  1c98 ????
     42  1c98 ????						; beginning of color memory
     43  1c98 ????	       00 00	   COLOR_CURSOR_BEGINNING_LOW_BYTE =	$00
     44  1c98 ????	       00 96	   COLOR_CURSOR_BEGINNING_HIGH_BYTE =	$96
     45  1c98 ????	       00 00	   RED_COLOR_CODE =	0
     46  1c98 ????
     47  1c98 ????	       00 20	   SPACE_KEY  =	$20
     48  1c98 ????	       00 30	   Q_KEY      =	$30
     49  1c98 ????	       00 09	   W_KEY      =	$09
     50  1c98 ????	       00 31	   E_KEY      =	$31
     51  1c98 ????	       00 11	   A_KEY      =	$11
     52  1c98 ????	       00 29	   S_KEY      =	$29
     53  1c98 ????	       00 12	   D_KEY      =	$12
     54  1c98 ????	       00 0d	   SECRET_KEY =	$0d	; press P to skip to next  level
     55  1c98 ????	       00 0a	   RESET_KEY  =	$0a	; press R to restart level i assume
     56  1c98 ????	       00 01	   JUMP_SIZE  =	$01	; number of characters a jump causes
     57  1c98 ????	       00 16	   ROW_SIZE   =	$16
     58  1c98 ????						; memory locations
     59  1c98 ????	       10 01	   user_memory_start =	$1001
     60  1c98 ????	       00 c5	   currently_pressed_key =	$c5
     61  1c98 ????	       00 a0	   jiffy_clock =	$A0
     62  1c98 ????	       90 05	   character_info_register =	$9005
     63  1c98 ????	       1c 00	   character_set_begin =	$1c00
     64  1c98 ????
     65  1c98 ????						; begin location counter at 4096 (user memory)
     66  1001					      org	user_memory_start
------- FILE stub.s LEVEL 2 PASS 3
      0  1001					      include	"stub.s"	; stub contains BASIC sys cmd to run the machine language code
      1  1001		       00 9e	   SYS_CMD_TOKEN =	$9e
      2  1001		       00 0a	   STUB_LINE_NUMBER =	10
      3  1001							; BASIC stub -- SYS cmd to run machine language
      4  1001		       0b 10		      dc.w	nextstmt	; link; beginning of basic
      5  1003		       0a 00		      dc.w	STUB_LINE_NUMBER	; line number
      6  1005		       9e 34 31 30*	      dc.b	SYS_CMD_TOKEN, [start]d, 0	; token for sys with operand as address to "start" label
      7  100b				   nextstmt
      8  100b		       00 00		      dc.w	0
------- FILE main.s
     68  100d
     69  100d				   start
     70  100d							; use combination of RAM (first 128 chars at 7168) & ROM character set
     71  100d		       a9 ff		      lda	#255
     72  100f		       8d 05 90 	      sta	character_info_register
     73  1012
     74  1012							; initialize some variables in the zero page
     75  1012		       a9 01		      lda	#1
     76  1014		       85 08		      sta	level_reset
     77  1016		       a9 00		      lda	#0
     78  1018		       85 09		      sta	level_completed
     79  101a
     80  101a		       a9 af		      lda	#<level_data_start
     81  101c		       85 04		      sta	current_level
     82  101e		       a9 19		      lda	#>level_data_start
     83  1020		       85 05		      sta	current_level+1
     84  1022
     85  1022		       a9 00		      lda	#0
     86  1024		       85 14		      sta	jump_info
     87  1026		       85 18		      sta	attached_powerups
     88  1028		       85 19		      sta	attached_powerups+1
     89  102a		       85 15		      sta	tile_store
     90  102c		       85 16		      sta	tile_store+1
     91  102e		       85 17		      sta	tile_store+2
     92  1030
------- FILE titleScreen.s LEVEL 2 PASS 3
      0  1030					      include	"titleScreen.s"
      1  1030		       00 00	   TITLE_SCREEN_CHAR_COLOR =	0
      2  1030		       00 0f	   ENTER_KEY  =	$0f
      3  1030
      4  1030				   display_title_screen
      5  1030		       a9 00		      lda	#SCREEN_CURSOR_BEGINNING_LOW_BYTE
      6  1032		       85 00		      sta	screen_cursor
      7  1034		       a9 1e		      lda	#SCREEN_CURSOR_BEGINNING_HIGH_BYTE	; store 1e in location 01
      8  1036		       85 01		      sta	screen_cursor+1
      9  1038
     10  1038		       a9 00		      lda	#COLOR_CURSOR_BEGINNING_LOW_BYTE
     11  103a		       85 02		      sta	color_cursor
     12  103c		       a9 96		      lda	#COLOR_CURSOR_BEGINNING_HIGH_BYTE
     13  103e		       85 03		      sta	color_cursor+1
     14  1040
     15  1040		       a0 00		      ldy	#$0	; to use for indirect indexed addressing
     16  1042		       a2 00		      ldx	#$0
     17  1044
     18  1044		       20 54 10 	      jsr	draw_title_screen_chars_loop
     19  1047		       a0 00		      ldy	#$0	; to use for indirect indexed addressing
     20  1049		       a2 00		      ldx	#$0
     21  104b
     22  104b
     23  104b				   infinite_loop
     24  104b		       a5 c5		      lda	currently_pressed_key
     25  104d		       c9 0f		      cmp	#ENTER_KEY
     26  104f		       f0 62		      beq	gameLoop
     27  1051		       4c 4b 10 	      jmp	infinite_loop
     28  1054
     29  1054
     30  1054				   draw_title_screen_chars_loop
     31  1054		       bd 45 19 	      lda	compressed_screen_data_start,X	; accumulator stores num times to repeat the byte
     32  1057		       20 62 10 	      jsr	draw_character	; draw the character that many times
     33  105a		       e8		      inx
     34  105b		       e8		      inx
     35  105c		       20 a3 10 	      jsr	check_if_screen_cursor_at_end
     36  105f		       90 f3		      bcc	draw_title_screen_chars_loop
     37  1061		       60		      rts
     38  1062
     39  1062
     40  1062							; draw the character in Y register for (value of accumulator) number of times
     41  1062				   draw_character
     42  1062							; if accumulator == 0, return; otherwise, subtract 1 from accumulator and continue drawing the letter at Y
     43  1062		       f0 23		      beq	draw_character_end
     44  1064		       38		      sec
     45  1065		       e9 01		      sbc	#1
     46  1067		       48		      pha		; push accumulator onto stack
     47  1068
     48  1068							; store current char at screen cursor location
     49  1068		       a0 00		      ldy	#0
     50  106a		       bd 46 19 	      lda	compressed_screen_data_start+1,X	; load cur char to draw
     51  106d
     52  106d							; solid block in the title screen editor is the a0 character; we convert that to the equivalent here (wall), as we cant access that char
     53  106d		       c9 a0		      cmp	#$a0
     54  106f		       d0 03		      bne	dont_map_wall
     55  1071		       a9 83		      lda	#WALL_CHAR-128
     56  1073		       18		      clc
     57  1074
     58  1074				   dont_map_wall
     59  1074		       69 80		      adc	#128
     60  1076		       91 00		      sta	(screen_cursor),Y	; draw it on screen
     61  1078
     62  1078
     63  1078							; add color to the screen location if it's not a space
     64  1078							; because our title screen only has one color, and only displays it for characters that arent space, we can get away with this "optimization",
     65  1078							; and avoid adding color data
     66  1078		       c9 20		      cmp	#BLANK_CHAR
     67  107a		       f0 04		      beq	dont_color
     68  107c
     69  107c		       a9 00		      lda	#TITLE_SCREEN_CHAR_COLOR
     70  107e		       91 02		      sta	(color_cursor),Y
     71  1080
     72  1080				   dont_color
     73  1080		       20 88 10 	      jsr	add_one_to_screen_cursor
     74  1083		       68		      pla		; put the current 'count' (remaining times to draw character) back on accumulator
     75  1084		       4c 62 10 	      jmp	draw_character
     76  1087
     77  1087				   draw_character_end
     78  1087		       60		      rts
     79  1088
     80  1088
     81  1088				   add_one_to_screen_cursor
     82  1088		       18		      clc
     83  1089		       a5 00		      lda	screen_cursor	; load and add to low byte
     84  108b		       69 01		      adc	#$1
     85  108d		       85 00		      sta	screen_cursor
     86  108f		       a5 01		      lda	screen_cursor+1
     87  1091		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
     88  1093		       85 01		      sta	screen_cursor+1
     89  1095
     90  1095							; add to color cursor as well
     91  1095		       18		      clc
     92  1096		       a5 02		      lda	color_cursor	; load and add to low byte
     93  1098		       69 01		      adc	#$1
     94  109a		       85 02		      sta	color_cursor
     95  109c		       a5 03		      lda	color_cursor+1
     96  109e		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
     97  10a0		       85 03		      sta	color_cursor+1
     98  10a2		       60		      rts
     99  10a3
    100  10a3				   check_if_screen_cursor_at_end		; set carry flag if screen_cursor at position $1ff9 (8185
    101  10a3		       a5 00		      lda	screen_cursor	; load value at screen_cursor low byte
    102  10a5		       c9 fa		      cmp	#END_OF_SCREEN_LOW_BYTE
    103  10a7		       d0 06		      bne	check_if_screen_cursor_at_end_return_false	; if low byte doesnt match, return with carry flag as neg
    104  10a9
    105  10a9		       a5 01		      lda	screen_cursor+1
    106  10ab		       c9 1f		      cmp	#END_OF_SCREEN_HIGH_BYTE
    107  10ad		       f0 02		      beq	check_if_screen_cursor_at_end_return_true	; if high byte matches, set carry flag
    108  10af
    109  10af				   check_if_screen_cursor_at_end_return_false
    110  10af		       18		      clc
    111  10b0		       60		      rts
    112  10b1
    113  10b1				   check_if_screen_cursor_at_end_return_true
    114  10b1		       38		      sec
    115  10b2		       60		      rts
------- FILE main.s
     94  10b3
     95  10b3							; title screen code jumps here once space pressed
     96  10b3				   gameLoop
     97  10b3		       20 fe 10 	      jsr	update_level
     98  10b6		       a9 00		      lda	#0
     99  10b8		       85 08		      sta	level_reset
    100  10ba		       20 48 12 	      jsr	update_game_state
    101  10bd		       20 de 10 	      jsr	check_for_secret_key
    102  10c0		       20 f0 10 	      jsr	check_for_reset_key
    103  10c3		       20 d5 10 	      jsr	wait_until_next_frame
    104  10c6		       20 d5 10 	      jsr	wait_until_next_frame
    105  10c9		       20 d5 10 	      jsr	wait_until_next_frame
    106  10cc		       20 d5 10 	      jsr	wait_until_next_frame
    107  10cf		       20 d5 10 	      jsr	wait_until_next_frame
    108  10d2		       4c b3 10 	      jmp	gameLoop
    109  10d5
    110  10d5
    111  10d5				   wait_until_next_frame		; wait one jiffy before completing game loop
    112  10d5		       a5 a2		      lda	jiffy_clock+2
    113  10d7		       c5 0f		      cmp	current_time
    114  10d9		       f0 fa		      beq	wait_until_next_frame
    115  10db		       85 0f		      sta	current_time
    116  10dd		       60		      rts
    117  10de
    118  10de							; update level_completed and level_reset if secret_key pressed
    119  10de				   check_for_secret_key
    120  10de		       a5 c5		      lda	currently_pressed_key
    121  10e0		       c9 0d		      cmp	#SECRET_KEY
    122  10e2		       d0 0b		      bne	check_for_secret_key_return
    123  10e4		       20 24 16 	      jsr	delete_squarebot
    124  10e7		       a9 01		      lda	#1
    125  10e9		       85 09		      sta	level_completed
    126  10eb		       a9 01		      lda	#1
    127  10ed		       85 08		      sta	level_reset
    128  10ef				   check_for_secret_key_return
    129  10ef		       60		      rts
    130  10f0
    131  10f0				   check_for_reset_key
    132  10f0		       a5 c5		      lda	currently_pressed_key
    133  10f2		       c9 0a		      cmp	#RESET_KEY
    134  10f4		       d0 f9		      bne	check_for_secret_key_return	; todo -- reset  a bunch of state (has_key, )
    135  10f6		       20 24 16 	      jsr	delete_squarebot
    136  10f9		       a9 01		      lda	#1
    137  10fb		       85 08		      sta	level_reset
    138  10fd				   check_for_reset_key_return
    139  10fd		       60		      rts
    140  10fe
------- FILE updateLevel.s LEVEL 2 PASS 3
      0  10fe					      include	"updateLevel.s"
      1  10fe		       00 01	   LEVEL_IS_DONE =	1
      2  10fe		       00 00	   LEVEL_NOT_DONE =	0
      3  10fe		       00 01	   SHOULD_RESET =	1
      4  10fe		       00 00	   SHOULD_NOT_RESET =	0
      5  10fe
      6  10fe							; only first 4 bits really matter here; refer to readme for guide on lvl format
      7  10fe		       00 00	   BLANK_SPACE =	0	; 000000000
      8  10fe		       00 10	   STARTING_POINT =	16	; 00010000
      9  10fe		       00 20	   WALL       =	32	; 00100000
     10  10fe		       00 30	   BREAKABLE_WALL =	48	; 00110000
     11  10fe		       00 40	   LOCKED_WALL =	64	; 01000000
     12  10fe		       00 50	   LADDER     =	80	; 01010000
     13  10fe		       00 60	   EXIT       =	96	; 01100000
     14  10fe		       00 70	   PLATFORM   =	112	; 01110000
     15  10fe		       00 80	   KEY	      =	128	; 10000000
     16  10fe		       00 90	   SPIKE      =	144	; 10010000
     17  10fe		       00 a0	   BOOSTER    =	160	; 10100000
     18  10fe
     19  10fe		       00 00	   WALL_COLOR =	0
     20  10fe		       00 00	   BREAKABLE_WALL_COLOR =	0
     21  10fe		       00 00	   LOCKED_WALL_COLOR =	0
     22  10fe		       00 00	   LADDER_COLOR =	0	;6
     23  10fe		       00 00	   EXIT_COLOR =	0	;6
     24  10fe		       00 00	   PLATFORM_COLOR =	0	;4
     25  10fe		       00 00	   SPIKE_COLOR =	0	;2
     26  10fe		       00 00	   KEY_P_COLOR =	0	;7
     27  10fe		       00 00	   SPIKE_P_COLOR =	0	;6
     28  10fe		       00 00	   BOOSTER_P_COLOR =	0	;6
     29  10fe		       00 02	   SQUAREBOT_COLOR =	2
     30  10fe
     31  10fe		       00 00	   BLANK_TILE_CHAR =	$00	; use this instead of BLANK_CHAR, allows me to save space with tile_store
     32  10fe		       00 01	   LADDER_CHAR =	$01
     33  10fe		       00 02	   PLATFORM_CHAR =	$02
     34  10fe		       00 03	   WALL_CHAR  =	$03
     35  10fe		       00 04	   EXIT_CHAR  =	$04
     36  10fe		       00 05	   LOCKED_WALL_CHAR =	$05
     37  10fe		       00 06	   BREAKABLE_WALL_CHAR =	$06
     38  10fe		       00 07	   BOOSTER_P_CHAR =	$07
     39  10fe		       00 08	   KEY_P_CHAR =	$08
     40  10fe		       00 09	   SPIKE_P_CHAR =	$09
     41  10fe		       00 0a	   BOOSTER_A_CHAR =	$0A
     42  10fe		       00 0b	   BOOSTER_AA_CHAR =	$0B
     43  10fe		       00 0c	   KEY_A_CHAR =	$0C
     44  10fe		       00 0d	   SPIKE_A_CHAR =	$0D
     45  10fe		       00 0e	   CHAR_U     =	$0E
     46  10fe		       00 0f	   CHAR_D     =	$0F
     47  10fe		       00 10	   CHAR_L     =	$10
     48  10fe		       00 11	   CHAR_R     =	$11
     49  10fe		       00 12	   SQUAREBOT_CHAR =	$12
     50  10fe		       00 17	   LEVEL_BEGINNING_LOW_BYTE =	$17
     51  10fe		       00 1e	   LEVEL_BEGINNING_HIGH_BYTE =	$1e
     52  10fe		       00 17	   LEVEL_COLOR_BEGINNING_LOW_BYTE =	$17
     53  10fe		       00 96	   LEVEL_COLOR_BEGINNING_HIGH_BYTE =	$96
     54  10fe		       00 e5	   END_OF_LEVEL_LOW_BYTE =	$e5
     55  10fe		       00 1f	   END_OF_LEVEL_HIGH_BYTE =	$1f
     56  10fe
     57  10fe				   update_level
     58  10fe							; check if the level is completed; set current_level to next_level if so
     59  10fe		       a5 09		      lda	level_completed
     60  1100		       c9 01		      cmp	#LEVEL_IS_DONE	; (try optimizing later)
     61  1102		       d0 10		      bne	dont_update
     62  1104
     63  1104							; level is done; reset level completed
     64  1104		       a9 00		      lda	#LEVEL_NOT_DONE
     65  1106		       85 09		      sta	level_completed
     66  1108
     67  1108							; now set current_level to next_level
     68  1108		       a5 06		      lda	next_level
     69  110a		       85 04		      sta	current_level
     70  110c		       a5 07		      lda	next_level+1
     71  110e		       85 05		      sta	current_level+1
     72  1110
     73  1110		       a9 00		      lda	#0
     74  1112		       85 1f		      sta	count_chars_drawn
     75  1114
     76  1114				   dont_update
     77  1114							; now check if level reset was set
     78  1114		       a5 08		      lda	level_reset
     79  1116		       c9 00		      cmp	#0
     80  1118		       d0 01		      bne	continue_update	; if not, go back to game loop
     81  111a		       60		      rts
     82  111b
     83  111b				   continue_update
     84  111b							; if it was, update the level
     85  111b		       a9 17		      lda	#LEVEL_BEGINNING_LOW_BYTE
     86  111d		       85 00		      sta	screen_cursor
     87  111f		       a9 1e		      lda	#LEVEL_BEGINNING_HIGH_BYTE
     88  1121		       85 01		      sta	screen_cursor+1
     89  1123
     90  1123		       a9 17		      lda	#LEVEL_COLOR_BEGINNING_LOW_BYTE
     91  1125		       85 02		      sta	color_cursor
     92  1127		       a9 96		      lda	#LEVEL_COLOR_BEGINNING_HIGH_BYTE
     93  1129		       85 03		      sta	color_cursor+1
     94  112b
     95  112b		       a2 00		      ldx	#0
     96  112d		       a0 00		      ldy	#0
     97  112f		       84 0a		      sty	level_data_index
     98  1131
     99  1131		       a9 00		      lda	#0
    100  1133		       85 14		      sta	jump_info
    101  1135		       85 18		      sta	attached_powerups
    102  1137		       85 19		      sta	attached_powerups+1
    103  1139		       85 15		      sta	tile_store
    104  113b		       85 16		      sta	tile_store+1
    105  113d		       85 17		      sta	tile_store+2
    106  113f
    107  113f							; draw (or redraw on reset) the current level
    108  113f				   draw_level_loop
    109  113f							; y stores our index in the current level data
    110  113f		       20 38 12 	      jsr	check_if_level_cursor_at_end
    111  1142		       b0 10		      bcs	update_level_return
    112  1144
    113  1144		       a4 0a		      ldy	level_data_index
    114  1146		       b1 04		      lda	(current_level),y	; accumulator stores the number of times to repeat the next byte
    115  1148
    116  1148		       20 62 11 	      jsr	draw_sequence
    117  114b
    118  114b		       a4 0a		      ldy	level_data_index
    119  114d		       c8		      iny		; set y to point to next length byte (iterate 2 at a time)
    120  114e		       c8		      iny
    121  114f		       84 0a		      sty	level_data_index
    122  1151		       4c 3f 11 	      jmp	draw_level_loop
    123  1154
    124  1154
    125  1154				   update_level_return
    126  1154							; update next level pointer to point to byte after current level
    127  1154		       a5 04		      lda	current_level
    128  1156		       18		      clc
    129  1157		       65 0a		      adc	level_data_index
    130  1159		       85 06		      sta	next_level
    131  115b		       a5 05		      lda	current_level+1
    132  115d		       69 00		      adc	#0
    133  115f		       85 07		      sta	next_level+1
    134  1161		       60		      rts
    135  1162
    136  1162
    137  1162
    138  1162				   draw_sequence
    139  1162							; if acc == 0, return; otherwise subtract 1, draw the next 2 chars
    140  1162		       f0 1c		      beq	draw_sequence_end
    141  1164		       38		      sec
    142  1165		       e9 01		      sbc	#1
    143  1167		       48		      pha		; push accumulator onto stack
    144  1168
    145  1168		       a4 0a		      ldy	level_data_index
    146  116a		       c8		      iny		; (so we can access the "element" byte after the length byte)
    147  116b		       b1 04		      lda	(current_level),y	; get formatted byte (see squarebot doc)
    148  116d		       0a		      asl		; lol
    149  116e		       0a		      asl
    150  116f		       0a		      asl
    151  1170		       0a		      asl
    152  1171		       20 81 11 	      jsr	draw_high_bits	; draw char represented by the 4 high bits
    153  1174
    154  1174		       a4 0a		      ldy	level_data_index
    155  1176		       c8		      iny
    156  1177
    157  1177		       b1 04		      lda	(current_level),y
    158  1179		       20 81 11 	      jsr	draw_high_bits
    159  117c
    160  117c		       68		      pla
    161  117d		       4c 62 11 	      jmp	draw_sequence
    162  1180
    163  1180				   draw_sequence_end
    164  1180		       60		      rts
    165  1181
    166  1181
    167  1181							; put the character in the high 4 bits of accumulator on screen (see readme), and move the color and screen cursors ahead
    168  1181				   draw_high_bits
    169  1181		       29 f0		      and	#240	; shave off last 4 bits
    170  1183
    171  1183		       c9 00		      cmp	#BLANK_SPACE
    172  1185		       d0 08		      bne	check_if_starting_point
    173  1187		       a9 00		      lda	#BLANK_TILE_CHAR	; todo; replace with actual chars
    174  1189		       a2 01		      ldx	#1
    175  118b		       20 13 12 	      jsr	draw_char_in_accumulator
    176  118e		       60		      rts
    177  118f
    178  118f				   check_if_starting_point
    179  118f		       c9 10		      cmp	#STARTING_POINT
    180  1191		       d0 18		      bne	check_if_wall
    181  1193
    182  1193							; set squarebot to starting point
    183  1193		       a5 00		      lda	screen_cursor
    184  1195		       85 10		      sta	squarebot_position
    185  1197		       a5 01		      lda	screen_cursor+1
    186  1199		       85 11		      sta	squarebot_position+1
    187  119b
    188  119b		       a5 02		      lda	color_cursor
    189  119d		       85 12		      sta	squarebot_color_position
    190  119f		       a5 03		      lda	color_cursor+1
    191  11a1		       85 13		      sta	squarebot_color_position+1
    192  11a3
    193  11a3		       a9 12		      lda	#SQUAREBOT_CHAR
    194  11a5		       a2 02		      ldx	#SQUAREBOT_COLOR
    195  11a7		       20 13 12 	      jsr	draw_char_in_accumulator
    196  11aa		       60		      rts
    197  11ab
    198  11ab				   check_if_wall
    199  11ab		       c9 20		      cmp	#WALL
    200  11ad		       d0 08		      bne	check_if_breakable_wall
    201  11af		       a9 03		      lda	#WALL_CHAR
    202  11b1		       a2 00		      ldx	#WALL_COLOR
    203  11b3		       20 13 12 	      jsr	draw_char_in_accumulator
    204  11b6		       60		      rts
    205  11b7
    206  11b7				   check_if_breakable_wall
    207  11b7		       c9 30		      cmp	#BREAKABLE_WALL
    208  11b9		       d0 08		      bne	check_if_locked_wall
    209  11bb		       a9 06		      lda	#BREAKABLE_WALL_CHAR
    210  11bd		       a2 00		      ldx	#BREAKABLE_WALL_COLOR
    211  11bf		       20 13 12 	      jsr	draw_char_in_accumulator
    212  11c2		       60		      rts
    213  11c3
    214  11c3				   check_if_locked_wall
    215  11c3		       c9 40		      cmp	#LOCKED_WALL
    216  11c5		       d0 08		      bne	check_if_ladder
    217  11c7		       a9 05		      lda	#LOCKED_WALL_CHAR
    218  11c9		       a2 00		      ldx	#LOCKED_WALL_COLOR
    219  11cb		       20 13 12 	      jsr	draw_char_in_accumulator
    220  11ce		       60		      rts
    221  11cf
    222  11cf				   check_if_ladder
    223  11cf		       c9 50		      cmp	#LADDER
    224  11d1		       d0 08		      bne	check_if_exit
    225  11d3		       a9 01		      lda	#LADDER_CHAR
    226  11d5		       a2 00		      ldx	#LADDER_COLOR
    227  11d7		       20 13 12 	      jsr	draw_char_in_accumulator
    228  11da		       60		      rts
    229  11db
    230  11db				   check_if_exit
    231  11db		       c9 60		      cmp	#EXIT
    232  11dd		       d0 08		      bne	check_if_platform
    233  11df		       a9 04		      lda	#EXIT_CHAR
    234  11e1		       a2 00		      ldx	#EXIT_COLOR
    235  11e3		       20 13 12 	      jsr	draw_char_in_accumulator
    236  11e6		       60		      rts
    237  11e7
    238  11e7				   check_if_platform
    239  11e7		       c9 70		      cmp	#PLATFORM
    240  11e9		       d0 08		      bne	check_if_key
    241  11eb		       a9 02		      lda	#PLATFORM_CHAR
    242  11ed		       a2 00		      ldx	#PLATFORM_COLOR
    243  11ef		       20 13 12 	      jsr	draw_char_in_accumulator
    244  11f2		       60		      rts
    245  11f3
    246  11f3				   check_if_key
    247  11f3		       c9 80		      cmp	#KEY
    248  11f5		       d0 08		      bne	check_if_spike
    249  11f7		       a9 08		      lda	#KEY_P_CHAR
    250  11f9		       a2 00		      ldx	#KEY_P_COLOR
    251  11fb		       20 13 12 	      jsr	draw_char_in_accumulator
    252  11fe		       60		      rts
    253  11ff
    254  11ff				   check_if_spike
    255  11ff		       c9 90		      cmp	#SPIKE
    256  1201		       d0 08		      bne	check_if_booster
    257  1203		       a9 09		      lda	#SPIKE_P_CHAR
    258  1205		       a2 00		      ldx	#SPIKE_P_COLOR
    259  1207		       20 13 12 	      jsr	draw_char_in_accumulator
    260  120a		       60		      rts
    261  120b
    262  120b				   check_if_booster
    263  120b		       a9 07		      lda	#BOOSTER_P_CHAR
    264  120d		       a2 00		      ldx	#BOOSTER_P_COLOR
    265  120f		       20 13 12 	      jsr	draw_char_in_accumulator
    266  1212		       60		      rts
    267  1213
    268  1213
    269  1213
    270  1213							; char in accumulator goes in screen cursor, color in x register goes in color cursor, then update cursors
    271  1213
    272  1213				   draw_char_in_accumulator
    273  1213		       a0 00		      ldy	#0
    274  1215		       91 00		      sta	(screen_cursor),y
    275  1217
    276  1217		       8a		      txa
    277  1218		       91 02		      sta	(color_cursor),y
    278  121a
    279  121a		       20 88 10 	      jsr	add_one_to_screen_cursor	; add to both screen and color cursor
    280  121d		       20 21 12 	      jsr	update_screen_position_if_on_border
    281  1220		       60		      rts
    282  1221
    283  1221
    284  1221
    285  1221				   update_screen_position_if_on_border
    286  1221		       a5 1f		      lda	count_chars_drawn
    287  1223		       c9 13		      cmp	#19
    288  1225		       d0 0b		      bne	add_and_return
    289  1227		       a9 00		      lda	#0
    290  1229		       85 1f		      sta	count_chars_drawn
    291  122b		       20 88 10 	      jsr	add_one_to_screen_cursor
    292  122e		       20 88 10 	      jsr	add_one_to_screen_cursor
    293  1231		       60		      rts
    294  1232
    295  1232
    296  1232				   add_and_return
    297  1232		       18		      clc
    298  1233		       69 01		      adc	#1
    299  1235		       85 1f		      sta	count_chars_drawn
    300  1237		       60		      rts
    301  1238
    302  1238				   check_if_level_cursor_at_end 		; set carry flag if screen_cursor at position $1ff9 (8185
    303  1238		       a5 00		      lda	screen_cursor	; load value at screen_cursor low byte
    304  123a		       c9 e5		      cmp	#END_OF_LEVEL_LOW_BYTE
    305  123c		       d0 06		      bne	check_if_level_cursor_at_end_return_false	; if low byte doesnt match, return with carry flag as neg
    306  123e
    307  123e		       a5 01		      lda	screen_cursor+1
    308  1240		       c9 1f		      cmp	#END_OF_LEVEL_HIGH_BYTE
    309  1242		       f0 02		      beq	check_if_level_cursor_at_end_return_true	; if high byte matches, set carry flag
    310  1244
    311  1244				   check_if_level_cursor_at_end_return_false
    312  1244		       18		      clc
    313  1245		       60		      rts
    314  1246
    315  1246				   check_if_level_cursor_at_end_return_true
    316  1246		       38		      sec
    317  1247		       60		      rts
------- FILE main.s
------- FILE updateGameState_new.s LEVEL 2 PASS 3
      0  1248					      include	"updateGameState_new.s"
      1  1248		       00 e4	   START_OF_FIRST_ROW_LOW_BYTE =	$e4
      2  1248		       00 1f	   START_OF_FIRST_ROW_HIGH_BYTE =	$1f
      3  1248
      4  1248							; main logic until line 113:
      5  1248				   update_game_state
      6  1248		       a5 10		      lda	squarebot_position	; likely unnecessary
      7  124a		       85 0b		      sta	new_position
      8  124c		       a5 11		      lda	squarebot_position+1
      9  124e		       85 0c		      sta	new_position+1
     10  1250		       a5 12		      lda	squarebot_color_position
     11  1252		       85 0d		      sta	new_color_position
     12  1254		       a5 13		      lda	squarebot_color_position+1
     13  1256		       85 0e		      sta	new_color_position+1
     14  1258
     15  1258				   jump_logic
     16  1258		       20 58 17 	      jsr	get_jump_num
     17  125b		       c9 00		      cmp	#0
     18  125d		       f0 26		      beq	fall_logic
     19  125f		       38		      sec
     20  1260		       e9 01		      sbc	#1
     21  1262		       20 68 17 	      jsr	set_jump_num
     22  1265		       20 20 13 	      jsr	move_up
     23  1268		       20 53 17 	      jsr	get_jump_dir
     24  126b				   j_left
     25  126b		       c9 10		      cmp	#$10
     26  126d		       d0 09		      bne	j_right
     27  126f		       20 d5 10 	      jsr	wait_until_next_frame
     28  1272		       20 fc 13 	      jsr	move_left
     29  1275		       4c b5 12 	      jmp	update_return
     30  1278				   j_right
     31  1278		       c9 20		      cmp	#$20
     32  127a		       d0 39		      bne	update_return
     33  127c		       20 d5 10 	      jsr	wait_until_next_frame
     34  127f		       20 60 14 	      jsr	move_right
     35  1282		       4c b5 12 	      jmp	update_return
     36  1285
     37  1285				   fall_logic
     38  1285		       20 7f 17 	      jsr	get_down
     39  1288		       20 fd 14 	      jsr	fall_check
     40  128b		       90 29		      bcc	check_if_space_pressed
     41  128d		       20 8d 13 	      jsr	move_down
     42  1290		       20 7f 17 	      jsr	get_down
     43  1293		       20 fd 14 	      jsr	fall_check
     44  1296		       90 1d		      bcc	update_return	; don't move if we land
     45  1298		       20 53 17 	      jsr	get_jump_dir
     46  129b				   f_left
     47  129b		       c9 10		      cmp	#$10
     48  129d		       d0 09		      bne	f_right
     49  129f		       20 d5 10 	      jsr	wait_until_next_frame
     50  12a2		       20 fc 13 	      jsr	move_left
     51  12a5		       4c b5 12 	      jmp	update_return
     52  12a8				   f_right
     53  12a8		       c9 20		      cmp	#$20
     54  12aa		       d0 09		      bne	update_return
     55  12ac		       20 d5 10 	      jsr	wait_until_next_frame
     56  12af		       20 60 14 	      jsr	move_right
     57  12b2		       4c b5 12 	      jmp	update_return
     58  12b5
     59  12b5				   update_return
     60  12b5		       60		      rts
     61  12b6
     62  12b6				   check_if_space_pressed
     63  12b6		       a9 00		      lda	#$00
     64  12b8		       85 14		      sta	jump_info	; double check we aren't falling in a direction
     65  12ba		       a5 c5		      lda	currently_pressed_key
     66  12bc		       c9 20		      cmp	#SPACE_KEY
     67  12be		       d0 10		      bne	check_if_q_pressed
     68  12c0		       a9 01		      lda	#JUMP_SIZE
     69  12c2		       20 68 17 	      jsr	set_jump_num
     70  12c5		       a9 00		      lda	#00
     71  12c7		       20 5d 17 	      jsr	set_jump_dir
     72  12ca		       20 20 13 	      jsr	move_up
     73  12cd		       4c b5 12 	      jmp	update_return
     74  12d0
     75  12d0				   check_if_q_pressed
     76  12d0		       c9 30		      cmp	#Q_KEY
     77  12d2		       d0 16		      bne	check_if_e_pressed
     78  12d4		       a9 01		      lda	#JUMP_SIZE
     79  12d6		       20 68 17 	      jsr	set_jump_num
     80  12d9		       a9 10		      lda	#$10
     81  12db		       20 5d 17 	      jsr	set_jump_dir
     82  12de		       20 20 13 	      jsr	move_up
     83  12e1		       20 d5 10 	      jsr	wait_until_next_frame
     84  12e4		       20 fc 13 	      jsr	move_left
     85  12e7		       4c b5 12 	      jmp	update_return
     86  12ea
     87  12ea				   check_if_e_pressed
     88  12ea		       c9 31		      cmp	#E_KEY
     89  12ec		       d0 16		      bne	check_if_a_pressed
     90  12ee		       a9 01		      lda	#JUMP_SIZE
     91  12f0		       20 68 17 	      jsr	set_jump_num
     92  12f3		       a9 20		      lda	#$20
     93  12f5		       20 5d 17 	      jsr	set_jump_dir
     94  12f8		       20 20 13 	      jsr	move_up
     95  12fb		       20 d5 10 	      jsr	wait_until_next_frame
     96  12fe		       20 60 14 	      jsr	move_right
     97  1301		       4c b5 12 	      jmp	update_return
     98  1304
     99  1304				   check_if_a_pressed
    100  1304		       c9 11		      cmp	#A_KEY
    101  1306		       d0 0a		      bne	check_if_d_pressed
    102  1308		       a9 10		      lda	#$10
    103  130a		       85 14		      sta	jump_info	; fall left if we go off a ledge
    104  130c		       20 fc 13 	      jsr	move_left
    105  130f		       4c b5 12 	      jmp	update_return
    106  1312
    107  1312				   check_if_d_pressed
    108  1312		       c9 12		      cmp	#D_KEY
    109  1314		       d0 9f		      bne	update_return
    110  1316		       a9 20		      lda	#$20
    111  1318		       85 14		      sta	jump_info	; fall right if we go off a ledge
    112  131a		       20 60 14 	      jsr	move_right
    113  131d		       4c b5 12 	      jmp	update_return
    114  1320
    115  1320							; The rest is subroutines
    116  1320
    117  1320							;current bugs:
    118  1320							;attached powerup sprites are not working
    119  1320							;jump direction is not reset properly
    120  1320							;platforms get deleted sometimes
    121  1320							;need to replace end screen
    122  1320
    123  1320				   move_up
    124  1320		       a9 00		      lda	#$0
    125  1322		       85 1a		      sta	temp
    126  1324		       20 84 17 	      jsr	get_up
    127  1327		       c9 04		      cmp	#EXIT_CHAR
    128  1329		       d0 09		      bne	cont_u
    129  132b		       a9 01		      lda	#1
    130  132d		       85 09		      sta	level_completed
    131  132f		       85 08		      sta	level_reset
    132  1331		       4c 83 13 	      jmp	return_u
    133  1334				   cont_u
    134  1334		       20 c4 14 	      jsr	collision_handler
    135  1337		       90 4b		      bcc	remove_jumps
    136  1339		       a5 1a		      lda	temp
    137  133b		       c9 00		      cmp	#$0
    138  133d		       f0 13		      beq	post_powerup_u
    139  133f		       29 f0		      and	#$F0
    140  1341		       85 1a		      sta	temp
    141  1343		       a9 0f		      lda	#$0F
    142  1345		       25 18		      and	attached_powerups
    143  1347		       18		      clc
    144  1348		       65 1a		      adc	temp
    145  134a		       85 18		      sta	attached_powerups
    146  134c		       a9 0f		      lda	#$0F
    147  134e		       25 15		      and	tile_store
    148  1350		       85 15		      sta	tile_store
    149  1352				   post_powerup_u
    150  1352		       20 24 16 	      jsr	delete_squarebot
    151  1355		       20 03 18 	      jsr	move_new_position_up
    152  1358		       20 a5 18 	      jsr	get_tiles_u
    153  135b		       a5 18		      lda	attached_powerups
    154  135d		       29 0f		      and	#$0F
    155  135f		       c9 01		      cmp	#$01
    156  1361		       d0 09		      bne	no_booster_u
    157  1363		       a5 18		      lda	attached_powerups
    158  1365		       29 f0		      and	#$F0
    159  1367		       18		      clc
    160  1368		       69 08		      adc	#$08
    161  136a		       85 18		      sta	attached_powerups
    162  136c				   no_booster_u
    163  136c		       20 14 15 	      jsr	apply_powerup_logic
    164  136f		       20 60 16 	      jsr	update_squarebot
    165  1372		       20 71 16 	      jsr	update_chars
    166  1375		       20 1a 17 	      jsr	draw_squarebot
    167  1378		       20 d5 10 	      jsr	wait_until_next_frame
    168  137b		       a5 18		      lda	attached_powerups
    169  137d		       29 0f		      and	#$0F
    170  137f		       c9 02		      cmp	#$02
    171  1381		       f0 9d		      beq	move_up
    172  1383				   return_u
    173  1383		       60		      rts
    174  1384				   remove_jumps
    175  1384		       a5 14		      lda	jump_info
    176  1386		       29 f0		      and	#$F0	;remove jumps_remaining since we hit a wall
    177  1388		       85 14		      sta	jump_info
    178  138a		       4c 83 13 	      jmp	return_u
    179  138d
    180  138d				   move_down
    181  138d		       a9 00		      lda	#$0
    182  138f		       85 1a		      sta	temp
    183  1391		       20 7f 17 	      jsr	get_down
    184  1394		       c9 04		      cmp	#EXIT_CHAR
    185  1396		       d0 09		      bne	cont_d
    186  1398		       a9 01		      lda	#1
    187  139a		       85 09		      sta	level_completed
    188  139c		       85 08		      sta	level_reset
    189  139e		       4c f4 13 	      jmp	return_d
    190  13a1				   cont_d
    191  13a1		       c9 02		      cmp	#PLATFORM_CHAR	; collision_handler assumes we go through these otherwise
    192  13a3		       f0 50		      beq	remove_fall
    193  13a5		       20 c4 14 	      jsr	collision_handler
    194  13a8		       90 4b		      bcc	remove_fall
    195  13aa		       a5 1a		      lda	temp
    196  13ac		       c9 00		      cmp	#$0
    197  13ae		       f0 13		      beq	post_powerup_d
    198  13b0		       29 0f		      and	#$0F
    199  13b2		       85 1a		      sta	temp
    200  13b4		       a9 f0		      lda	#$F0
    201  13b6		       25 18		      and	attached_powerups
    202  13b8		       18		      clc
    203  13b9		       65 1a		      adc	temp
    204  13bb		       85 18		      sta	attached_powerups
    205  13bd		       a9 f0		      lda	#$F0
    206  13bf		       25 15		      and	tile_store
    207  13c1		       85 15		      sta	tile_store
    208  13c3				   post_powerup_d
    209  13c3		       20 24 16 	      jsr	delete_squarebot
    210  13c6		       20 1e 18 	      jsr	move_new_position_down
    211  13c9		       20 cd 18 	      jsr	get_tiles_d
    212  13cc		       a5 18		      lda	attached_powerups
    213  13ce		       29 f0		      and	#$F0
    214  13d0		       c9 10		      cmp	#$10
    215  13d2		       d0 09		      bne	no_booster_d
    216  13d4		       a5 18		      lda	attached_powerups
    217  13d6		       29 0f		      and	#$0F
    218  13d8		       18		      clc
    219  13d9		       69 80		      adc	#$80
    220  13db		       85 18		      sta	attached_powerups
    221  13dd				   no_booster_d
    222  13dd		       20 14 15 	      jsr	apply_powerup_logic
    223  13e0		       20 60 16 	      jsr	update_squarebot
    224  13e3		       20 71 16 	      jsr	update_chars
    225  13e6		       20 1a 17 	      jsr	draw_squarebot
    226  13e9		       20 d5 10 	      jsr	wait_until_next_frame
    227  13ec		       a5 18		      lda	attached_powerups
    228  13ee		       29 f0		      and	#$F0
    229  13f0		       c9 20		      cmp	#$20
    230  13f2		       f0 99		      beq	move_down
    231  13f4				   return_d
    232  13f4		       60		      rts
    233  13f5				   remove_fall
    234  13f5		       a9 00		      lda	#$00	;landed on ground so we aren't jumping or falling
    235  13f7		       85 14		      sta	jump_info
    236  13f9		       4c f4 13 	      jmp	return_d
    237  13fc
    238  13fc				   move_left
    239  13fc		       a9 00		      lda	#$0
    240  13fe		       85 1a		      sta	temp	; preset temp to 0 here so collision_handler logic is simpler
    241  1400		       20 78 17 	      jsr	get_left
    242  1403		       c9 04		      cmp	#EXIT_CHAR	; finish level check
    243  1405		       d0 09		      bne	cont_l
    244  1407		       a9 01		      lda	#1	; finish level
    245  1409		       85 09		      sta	level_completed
    246  140b		       85 08		      sta	level_reset
    247  140d		       4c 5f 14 	      jmp	return_l
    248  1410				   cont_l
    249  1410		       20 c4 14 	      jsr	collision_handler	; check collision
    250  1413		       90 4a		      bcc	return_l
    251  1415		       a5 1a		      lda	temp
    252  1417		       c9 00		      cmp	#$0
    253  1419		       f0 13		      beq	post_powerup_l
    254  141b		       29 f0		      and	#$F0	; save left
    255  141d		       85 1a		      sta	temp
    256  141f		       a9 0f		      lda	#$0F	; assume we hit a powerup
    257  1421		       25 19		      and	attached_powerups+1
    258  1423		       18		      clc
    259  1424		       65 1a		      adc	temp
    260  1426		       85 19		      sta	attached_powerups+1
    261  1428		       a9 0f		      lda	#$0F	; clear left of powerup
    262  142a		       25 16		      and	tile_store+1
    263  142c		       85 16		      sta	tile_store+1
    264  142e				   post_powerup_l
    265  142e		       20 24 16 	      jsr	delete_squarebot	; delete character
    266  1431		       20 e8 17 	      jsr	move_new_position_left
    267  1434		       20 f5 18 	      jsr	get_tiles_l
    268  1437		       a5 19		      lda	attached_powerups+1
    269  1439		       29 0f		      and	#$0F
    270  143b		       c9 01		      cmp	#$01
    271  143d		       d0 09		      bne	no_booster_l
    272  143f		       a5 19		      lda	attached_powerups+1
    273  1441		       29 f0		      and	#$F0
    274  1443		       18		      clc
    275  1444		       69 08		      adc	#$08	; turn on the ignition
    276  1446		       85 19		      sta	attached_powerups+1
    277  1448				   no_booster_l
    278  1448		       20 14 15 	      jsr	apply_powerup_logic
    279  144b		       20 60 16 	      jsr	update_squarebot	; update squarebot_position and its color pos
    280  144e		       20 71 16 	      jsr	update_chars	; redraw adjacent characters
    281  1451		       20 1a 17 	      jsr	draw_squarebot	; put squarebot on screen
    282  1454		       20 d5 10 	      jsr	wait_until_next_frame
    283  1457		       a5 19		      lda	attached_powerups+1	; booster time, if we activated booster we move again in the same frame before handling jump logic
    284  1459		       29 0f		      and	#$0F
    285  145b		       c9 02		      cmp	#$02
    286  145d		       f0 9d		      beq	move_left
    287  145f				   return_l
    288  145f		       60		      rts
    289  1460
    290  1460				   move_right
    291  1460		       a9 00		      lda	#$0
    292  1462		       85 1a		      sta	temp	; preset temp to 0 here so collision_handler logic is simpler
    293  1464		       20 73 17 	      jsr	get_right
    294  1467		       c9 04		      cmp	#EXIT_CHAR	; check here if we finish the level so we can rts to game loop
    295  1469		       d0 09		      bne	cont_r
    296  146b		       a9 01		      lda	#1	; finish level
    297  146d		       85 09		      sta	level_completed
    298  146f		       85 08		      sta	level_reset
    299  1471		       4c c3 14 	      jmp	return_r
    300  1474				   cont_r
    301  1474		       20 c4 14 	      jsr	collision_handler	; check rest of collision
    302  1477		       90 4a		      bcc	return_r	; collided
    303  1479		       a5 1a		      lda	temp	; check for powerup (from collision_handler)
    304  147b		       c9 00		      cmp	#$0	; collision handler will put a 0 here unless we hit a powerup
    305  147d		       f0 13		      beq	post_powerup_r
    306  147f		       29 0f		      and	#$0F	; save right
    307  1481		       85 1a		      sta	temp
    308  1483		       a9 f0		      lda	#$F0	; its a powerup, add the powerup to attached_powerup
    309  1485		       25 19		      and	attached_powerups+1
    310  1487		       18		      clc
    311  1488		       65 1a		      adc	temp
    312  148a		       85 19		      sta	attached_powerups+1
    313  148c		       a9 f0		      lda	#$F0	; clear right of powerup
    314  148e		       25 16		      and	tile_store+1
    315  1490		       85 16		      sta	tile_store+1
    316  1492				   post_powerup_r
    317  1492		       20 24 16 	      jsr	delete_squarebot	; delete character
    318  1495		       20 cd 17 	      jsr	move_new_position_right	; new position is where we want to move
    319  1498		       20 1d 19 	      jsr	get_tiles_r
    320  149b		       a5 19		      lda	attached_powerups+1	; if left powerup is readyBooster, change it to ignitedBooster, since apply_powerup_logic doesn't have directional context
    321  149d		       29 f0		      and	#$F0
    322  149f		       c9 10		      cmp	#$10
    323  14a1		       d0 09		      bne	no_booster_r
    324  14a3		       a5 19		      lda	attached_powerups+1
    325  14a5		       29 0f		      and	#$0F
    326  14a7		       18		      clc
    327  14a8		       69 80		      adc	#$80	; turn on the ignition
    328  14aa		       85 19		      sta	attached_powerups+1
    329  14ac				   no_booster_r
    330  14ac		       20 14 15 	      jsr	apply_powerup_logic
    331  14af		       20 60 16 	      jsr	update_squarebot	; update squarebot_position and its color pos
    332  14b2		       20 71 16 	      jsr	update_chars	; redraw adjacent characters
    333  14b5		       20 1a 17 	      jsr	draw_squarebot	; put squarebot on screen
    334  14b8		       20 d5 10 	      jsr	wait_until_next_frame
    335  14bb		       a5 19		      lda	attached_powerups+1	; booster time, if we activated booster we move again in the same frame before handling jump logic
    336  14bd		       29 f0		      and	#$F0
    337  14bf		       c9 20		      cmp	#$20
    338  14c1		       f0 9d		      beq	move_right
    339  14c3				   return_r
    340  14c3		       60		      rts
    341  14c4
    342  14c4				   collision_handler		; accumulator is the character in the position that squarebot wants to move to
    343  14c4							; set carry flag if we can move to this char, otherwise clear it
    344  14c4							; if its a powerup, set temp to be the attached_powerup id + attached_powerup id <<4, otherwise return since temp is already 0
    345  14c4		       c9 00		      cmp	#BLANK_TILE_CHAR
    346  14c6		       f0 31		      beq	return_true
    347  14c8		       c9 02		      cmp	#PLATFORM_CHAR
    348  14ca		       f0 2d		      beq	return_true	; moving down will double check anyway
    349  14cc							;I'll figure out ladders later
    350  14cc		       c9 03		      cmp	#WALL_CHAR
    351  14ce		       f0 2b		      beq	return_false
    352  14d0		       c9 06		      cmp	#BREAKABLE_WALL_CHAR
    353  14d2		       f0 27		      beq	return_false
    354  14d4		       c9 05		      cmp	#LOCKED_WALL_CHAR
    355  14d6		       f0 23		      beq	return_false
    356  14d8							;else its a powerup
    357  14d8		       c9 07		      cmp	#BOOSTER_P_CHAR
    358  14da		       d0 07		      bne	rpk
    359  14dc		       a9 11		      lda	#$11	;set both hex characters to avoid dumb shifts taking up lots of space
    360  14de		       85 1a		      sta	temp
    361  14e0		       4c f9 14 	      jmp	return_true
    362  14e3				   rpk
    363  14e3		       c9 08		      cmp	#KEY_P_CHAR
    364  14e5		       d0 07		      bne	rps
    365  14e7		       a9 33		      lda	#$33
    366  14e9		       85 1a		      sta	temp
    367  14eb		       4c f9 14 	      jmp	return_true
    368  14ee				   rps
    369  14ee		       c9 09		      cmp	#SPIKE_P_CHAR
    370  14f0		       d0 09		      bne	return_false
    371  14f2		       a9 44		      lda	#$44
    372  14f4		       85 1a		      sta	temp
    373  14f6		       4c f9 14 	      jmp	return_true
    374  14f9
    375  14f9				   return_true
    376  14f9		       38		      sec
    377  14fa		       60		      rts
    378  14fb
    379  14fb				   return_false
    380  14fb		       18		      clc
    381  14fc		       60		      rts
    382  14fd
    383  14fd				   fall_check
    384  14fd		       c9 02		      cmp	#PLATFORM_CHAR
    385  14ff		       f0 fa		      beq	return_false
    386  1501		       c9 03		      cmp	#WALL_CHAR
    387  1503		       f0 f6		      beq	return_false
    388  1505		       c9 05		      cmp	#LOCKED_WALL_CHAR
    389  1507		       f0 f2		      beq	return_false
    390  1509		       c9 06		      cmp	#BREAKABLE_WALL_CHAR
    391  150b		       f0 ee		      beq	return_false
    392  150d		       c9 01		      cmp	#LADDER_CHAR
    393  150f		       f0 ea		      beq	return_false
    394  1511		       4c f9 14 	      jmp	return_true	;
    395  1514
    396  1514				   apply_powerup_logic
    397  1514							; ready booster: does nothing
    398  1514							; ignited booster: breaks breakable walls and changes to active booster
    399  1514							; active booster: breaks breakable walls and changes to ready booster
    400  1514							; key: spends itself to break locked walls
    401  1514		       a5 18		      lda	attached_powerups
    402  1516		       85 1a		      sta	temp
    403  1518		       20 84 17 	      jsr	get_up
    404  151b		       0a		      asl
    405  151c		       0a		      asl
    406  151d		       0a		      asl
    407  151e		       0a		      asl
    408  151f		       85 1b		      sta	temp+1
    409  1521		       20 7f 17 	      jsr	get_down
    410  1524		       18		      clc
    411  1525		       65 1b		      adc	temp+1
    412  1527		       85 1b		      sta	temp+1
    413  1529		       20 6d 15 	      jsr	power_pair_logic
    414  152c		       a5 1a		      lda	temp
    415  152e		       85 18		      sta	attached_powerups
    416  1530		       a5 1b		      lda	temp+1
    417  1532		       4a		      lsr
    418  1533		       4a		      lsr
    419  1534		       4a		      lsr
    420  1535		       4a		      lsr
    421  1536		       20 b8 17 	      jsr	set_up	; setting a tile effectively changes that character
    422  1539		       a5 1b		      lda	temp+1
    423  153b		       29 0f		      and	#$0F
    424  153d		       20 ac 17 	      jsr	set_down
    425  1540
    426  1540		       a5 19		      lda	attached_powerups+1
    427  1542		       85 1a		      sta	temp
    428  1544		       20 78 17 	      jsr	get_left
    429  1547		       0a		      asl
    430  1548		       0a		      asl
    431  1549		       0a		      asl
    432  154a		       0a		      asl
    433  154b		       85 1b		      sta	temp+1
    434  154d		       20 73 17 	      jsr	get_right
    435  1550		       18		      clc
    436  1551		       65 1b		      adc	temp+1
    437  1553		       85 1b		      sta	temp+1
    438  1555		       20 6d 15 	      jsr	power_pair_logic
    439  1558		       a5 1a		      lda	temp
    440  155a		       85 19		      sta	attached_powerups+1
    441  155c		       a5 1b		      lda	temp+1
    442  155e		       4a		      lsr
    443  155f		       4a		      lsr
    444  1560		       4a		      lsr
    445  1561		       4a		      lsr
    446  1562		       20 9c 17 	      jsr	set_left
    447  1565		       a5 1b		      lda	temp+1
    448  1567		       29 0f		      and	#$0F
    449  1569		       20 90 17 	      jsr	set_right
    450  156c		       60		      rts
    451  156d
    452  156d				   power_pair_logic
    453  156d		       a5 1a		      lda	temp
    454  156f		       29 f0		      and	#$F0
    455  1571		       c9 80		      cmp	#$80	; check ignited booster
    456  1573		       d0 1a		      bne	ppl1b
    457  1575		       a5 1b		      lda	temp+1
    458  1577		       29 0f		      and	#$0F	; check opposite tile
    459  1579		       c9 06		      cmp	#BREAKABLE_WALL_CHAR
    460  157b		       d0 06		      bne	ppl1ab
    461  157d		       a5 1b		      lda	temp+1
    462  157f		       29 f0		      and	#$F0
    463  1581		       85 1b		      sta	temp+1	; delete wall
    464  1583				   ppl1ab
    465  1583		       a5 1a		      lda	temp
    466  1585		       29 0f		      and	#$0F
    467  1587		       18		      clc
    468  1588		       69 20		      adc	#$20	; set active booster
    469  158a		       85 1a		      sta	temp
    470  158c		       4c c8 15 	      jmp	ppl2
    471  158f				   ppl1b
    472  158f		       c9 20		      cmp	#$20	; check active booster
    473  1591		       d0 1a		      bne	ppl1k
    474  1593		       a5 1b		      lda	temp+1
    475  1595		       29 0f		      and	#$0F	; check opposite tile
    476  1597		       c9 06		      cmp	#BREAKABLE_WALL_CHAR
    477  1599		       d0 06		      bne	ppl1rb
    478  159b		       a5 1b		      lda	temp+1
    479  159d		       29 f0		      and	#$F0
    480  159f		       85 1b		      sta	temp+1	; delete wall
    481  15a1				   ppl1rb
    482  15a1		       a5 1a		      lda	temp
    483  15a3		       29 0f		      and	#$0F
    484  15a5		       18		      clc
    485  15a6		       69 10		      adc	#$10	; set ready booster
    486  15a8		       85 1a		      sta	temp
    487  15aa		       4c c8 15 	      jmp	ppl2
    488  15ad				   ppl1k
    489  15ad		       c9 30		      cmp	#$30	; check key
    490  15af		       d0 17		      bne	ppl2
    491  15b1		       a5 1b		      lda	temp+1
    492  15b3		       29 f0		      and	#$F0
    493  15b5		       c9 50		      cmp	#[LOCKED_WALL_CHAR << 4]
    494  15b7		       d0 0f		      bne	ppl2
    495  15b9		       a5 1a		      lda	temp
    496  15bb		       29 0f		      and	#$0F
    497  15bd		       85 1a		      sta	temp	; delete key
    498  15bf		       a5 1b		      lda	temp+1
    499  15c1		       29 0f		      and	#$0F
    500  15c3		       85 1b		      sta	temp+1	; delete wall
    501  15c5		       4c c8 15 	      jmp	ppl2
    502  15c8
    503  15c8				   ppl2
    504  15c8		       a5 1a		      lda	temp
    505  15ca		       29 0f		      and	#$0F
    506  15cc		       c9 08		      cmp	#$08	; check ignited booster
    507  15ce		       d0 1a		      bne	ppl2b
    508  15d0		       a5 1b		      lda	temp+1
    509  15d2		       29 f0		      and	#$F0
    510  15d4		       c9 60		      cmp	#[BREAKABLE_WALL_CHAR << 4]
    511  15d6		       d0 06		      bne	ppl2ab
    512  15d8		       a5 1b		      lda	temp+1
    513  15da		       29 0f		      and	#$0F
    514  15dc		       85 1b		      sta	temp+1	; delete wall
    515  15de				   ppl2ab
    516  15de		       a5 1a		      lda	temp
    517  15e0		       29 f0		      and	#$F0
    518  15e2		       18		      clc
    519  15e3		       69 02		      adc	#$02	; set active booster
    520  15e5		       85 1a		      sta	temp
    521  15e7		       4c 23 16 	      jmp	pplend
    522  15ea				   ppl2b
    523  15ea		       c9 02		      cmp	#$02	; check active booster
    524  15ec		       d0 1a		      bne	ppl2k
    525  15ee		       a5 1b		      lda	temp+1
    526  15f0		       29 f0		      and	#$F0
    527  15f2		       c9 60		      cmp	#[BREAKABLE_WALL_CHAR << 4]
    528  15f4		       d0 06		      bne	ppl2rb
    529  15f6		       a5 1b		      lda	temp+1
    530  15f8		       29 0f		      and	#$0F
    531  15fa		       85 1b		      sta	temp+1	; delete wall
    532  15fc				   ppl2rb
    533  15fc		       a5 1a		      lda	temp
    534  15fe		       29 f0		      and	#$F0
    535  1600		       18		      clc
    536  1601		       69 01		      adc	#$01	; set ready booster
    537  1603		       85 1a		      sta	temp
    538  1605		       4c 23 16 	      jmp	pplend
    539  1608				   ppl2k
    540  1608		       c9 03		      cmp	#$03	; key
    541  160a		       d0 17		      bne	pplend
    542  160c		       a5 1b		      lda	temp+1
    543  160e		       29 0f		      and	#$0F
    544  1610		       c9 05		      cmp	#LOCKED_WALL_CHAR
    545  1612		       d0 0f		      bne	pplend
    546  1614		       a5 1a		      lda	temp
    547  1616		       29 f0		      and	#$F0
    548  1618		       85 1a		      sta	temp	; delete key
    549  161a		       a5 1b		      lda	temp+1
    550  161c		       29 f0		      and	#$F0
    551  161e		       85 1b		      sta	temp+1	; delete wall
    552  1620		       4c 23 16 	      jmp	pplend
    553  1623
    554  1623				   pplend
    555  1623		       60		      rts
    556  1624
    557  1624
    558  1624				   delete_squarebot
    559  1624		       20 39 18 	      jsr	get_squarebot_draw_position
    560  1627
    561  1627		       a0 17		      ldy	#[ROW_SIZE + 1]
    562  1629		       20 8b 17 	      jsr	get_mid
    563  162c		       91 10		      sta	(squarebot_position),y
    564  162e		       a9 00		      lda	#0
    565  1630		       91 12		      sta	(squarebot_color_position),y
    566  1632
    567  1632		       a0 01		      ldy	#1
    568  1634		       20 84 17 	      jsr	get_up
    569  1637		       91 10		      sta	(squarebot_position),y
    570  1639		       a9 00		      lda	#0
    571  163b		       91 12		      sta	(squarebot_color_position),y
    572  163d
    573  163d		       a0 2d		      ldy	#[[ROW_SIZE*2] + 1]
    574  163f		       20 7f 17 	      jsr	get_down
    575  1642		       91 10		      sta	(squarebot_position),y
    576  1644		       a9 00		      lda	#0
    577  1646		       91 12		      sta	(squarebot_color_position),y
    578  1648
    579  1648		       a0 16		      ldy	#ROW_SIZE
    580  164a		       20 78 17 	      jsr	get_left
    581  164d		       91 10		      sta	(squarebot_position),y
    582  164f		       a9 00		      lda	#0
    583  1651		       91 12		      sta	(squarebot_color_position),y
    584  1653
    585  1653		       a0 18		      ldy	#[ROW_SIZE + 2]
    586  1655		       20 73 17 	      jsr	get_right
    587  1658		       91 10		      sta	(squarebot_position),y
    588  165a		       a9 00		      lda	#0
    589  165c
    590  165c		       20 54 18 	      jsr	get_squarebot_game_position
    591  165f
    592  165f		       60		      rts
    593  1660
    594  1660
    595  1660				   update_squarebot
    596  1660		       a5 0b		      lda	new_position
    597  1662		       85 10		      sta	squarebot_position
    598  1664		       a5 0c		      lda	new_position+1
    599  1666		       85 11		      sta	squarebot_position+1
    600  1668
    601  1668		       a5 0d		      lda	new_color_position
    602  166a		       85 12		      sta	squarebot_color_position
    603  166c		       a5 0e		      lda	new_color_position+1
    604  166e		       85 13		      sta	squarebot_color_position+1
    605  1670		       60		      rts
    606  1671
    607  1671
    608  1671				   update_chars
    609  1671		       20 84 17 	      jsr	get_up
    610  1674		       0a		      asl
    611  1675		       0a		      asl
    612  1676		       0a		      asl		; multiply by 8
    613  1677		       85 1c		      sta	charandr
    614  1679		       a5 18		      lda	attached_powerups
    615  167b		       4a		      lsr
    616  167c		       4a		      lsr
    617  167d		       4a		      lsr
    618  167e		       4a		      lsr
    619  167f		       c9 00		      cmp	#$00
    620  1681		       f0 06		      beq	update_char_u
    621  1683		       18		      clc
    622  1684		       69 09		      adc	#$09
    623  1686		       0a		      asl
    624  1687		       0a		      asl
    625  1688		       0a		      asl		; we could simplify this but at this rate a few more asls isn't going to be the main thing slowing down the code
    626  1689				   update_char_u
    627  1689		       85 1d		      sta	charandr+1
    628  168b		       a9 70		      lda	#[CHAR_U << 3]
    629  168d		       85 1e		      sta	charandr+2
    630  168f		       20 f2 16 	      jsr	update_char
    631  1692							;keep in mind we haven't rotated it yet
    632  1692
    633  1692		       20 7f 17 	      jsr	get_down
    634  1695		       0a		      asl
    635  1696		       0a		      asl
    636  1697		       0a		      asl
    637  1698		       85 1c		      sta	charandr
    638  169a		       a5 18		      lda	attached_powerups
    639  169c		       29 0f		      and	#$0F
    640  169e		       c9 00		      cmp	#$00
    641  16a0		       f0 06		      beq	update_char_d
    642  16a2		       18		      clc
    643  16a3		       69 09		      adc	#$09
    644  16a5		       0a		      asl
    645  16a6		       0a		      asl
    646  16a7		       0a		      asl
    647  16a8				   update_char_d
    648  16a8		       85 1d		      sta	charandr+1
    649  16aa		       a9 78		      lda	#[CHAR_D << 3]
    650  16ac		       85 1e		      sta	charandr+2
    651  16ae		       20 f2 16 	      jsr	update_char
    652  16b1
    653  16b1		       20 78 17 	      jsr	get_left
    654  16b4		       0a		      asl
    655  16b5		       0a		      asl
    656  16b6		       0a		      asl
    657  16b7		       85 1c		      sta	charandr
    658  16b9		       a5 19		      lda	attached_powerups+1
    659  16bb		       4a		      lsr
    660  16bc		       4a		      lsr
    661  16bd		       4a		      lsr
    662  16be		       4a		      lsr
    663  16bf		       c9 00		      cmp	#$00
    664  16c1		       f0 06		      beq	update_char_l
    665  16c3		       18		      clc
    666  16c4		       69 09		      adc	#$09
    667  16c6		       0a		      asl
    668  16c7		       0a		      asl
    669  16c8		       0a		      asl
    670  16c9				   update_char_l
    671  16c9		       85 1d		      sta	charandr+1
    672  16cb		       a9 80		      lda	#[CHAR_L << 3]
    673  16cd		       85 1e		      sta	charandr+2
    674  16cf		       20 f2 16 	      jsr	update_char
    675  16d2
    676  16d2		       20 73 17 	      jsr	get_right
    677  16d5		       0a		      asl
    678  16d6		       0a		      asl
    679  16d7		       0a		      asl
    680  16d8		       85 1c		      sta	charandr
    681  16da		       a5 19		      lda	attached_powerups+1
    682  16dc		       29 0f		      and	#$0F
    683  16de		       c9 00		      cmp	#$00
    684  16e0		       f0 06		      beq	update_char_r
    685  16e2		       18		      clc
    686  16e3		       69 09		      adc	#$09
    687  16e5		       0a		      asl
    688  16e6		       0a		      asl
    689  16e7		       0a		      asl
    690  16e8				   update_char_r
    691  16e8		       85 1d		      sta	charandr+1
    692  16ea		       a9 88		      lda	#[CHAR_R << 3]
    693  16ec		       85 1e		      sta	charandr+2
    694  16ee		       20 f2 16 	      jsr	update_char
    695  16f1
    696  16f1		       60		      rts		;casual 98 line function
    697  16f2
    698  16f2
    699  16f2				   update_char
    700  16f2		       a2 00		      ldx	#$00
    701  16f4				   update_char_loop
    702  16f4		       8a		      txa
    703  16f5		       18		      clc
    704  16f6		       65 1c		      adc	charandr
    705  16f8		       a8		      tay
    706  16f9		       b9 00 1c 	      lda	(#character_set_begin),y
    707  16fc		       85 1a		      sta	temp
    708  16fe
    709  16fe		       8a		      txa
    710  16ff		       18		      clc
    711  1700		       65 1d		      adc	charandr+1
    712  1702		       a8		      tay
    713  1703		       b9 00 1c 	      lda	(#character_set_begin),y
    714  1706		       45 1a		      eor	temp
    715  1708		       85 1a		      sta	temp
    716  170a
    717  170a		       8a		      txa
    718  170b		       18		      clc
    719  170c		       65 1e		      adc	charandr+2
    720  170e		       a8		      tay
    721  170f		       a5 1a		      lda	temp
    722  1711		       99 00 1c 	      sta	(#character_set_begin),y
    723  1714
    724  1714		       e8		      inx
    725  1715		       e0 08		      cpx	#$08
    726  1717		       d0 db		      bne	update_char_loop
    727  1719		       60		      rts
    728  171a
    729  171a							; if there is a powerup:
    730  171a							; for each of 8 bytes:
    731  171a							; load tile byte
    732  171a							; eor with powerup tile byte
    733  171a							; store in char byte
    734  171a
    735  171a				   draw_squarebot
    736  171a		       20 39 18 	      jsr	get_squarebot_draw_position
    737  171d
    738  171d		       a9 0e		      lda	#CHAR_U
    739  171f		       a0 01		      ldy	#1
    740  1721		       91 10		      sta	(squarebot_position),y
    741  1723		       a9 00		      lda	#0
    742  1725		       91 12		      sta	(squarebot_color_position),y
    743  1727
    744  1727		       a9 0f		      lda	#CHAR_D
    745  1729		       a0 2d		      ldy	#[[ROW_SIZE*2]+1]
    746  172b		       91 10		      sta	(squarebot_position),y
    747  172d		       a9 00		      lda	#0
    748  172f		       91 12		      sta	(squarebot_color_position),y
    749  1731
    750  1731		       a9 10		      lda	#CHAR_L
    751  1733		       a0 16		      ldy	#ROW_SIZE
    752  1735		       91 10		      sta	(squarebot_position),y
    753  1737		       a9 00		      lda	#0
    754  1739		       91 12		      sta	(squarebot_color_position),y
    755  173b
    756  173b		       a9 11		      lda	#CHAR_R
    757  173d		       a0 18		      ldy	#[ROW_SIZE+2]
    758  173f		       91 10		      sta	(squarebot_position),y
    759  1741		       a9 00		      lda	#0
    760  1743		       91 12		      sta	(squarebot_color_position),y
    761  1745
    762  1745		       a9 12		      lda	#SQUAREBOT_CHAR
    763  1747		       a0 17		      ldy	#[ROW_SIZE+1]
    764  1749		       91 10		      sta	(squarebot_position),y
    765  174b		       a9 02		      lda	#SQUAREBOT_COLOR
    766  174d		       91 12		      sta	(squarebot_color_position),y
    767  174f
    768  174f		       20 54 18 	      jsr	get_squarebot_game_position
    769  1752		       60		      rts
    770  1753
    771  1753							;real how it works:
    772  1753
    773  1753							;l/r movement:
    774  1753							;store l/r tile you want to move to
    775  1753							;if you win, win
    776  1753							;check collision:
    777  1753							;  store powerup in temp
    778  1753							;  return whether you can move or not
    779  1753							;if you can't move, goto j/f movement
    780  1753							;apply powerup
    781  1753							;get new position
    782  1753							;refresh tiles
    783  1753							;apply powerup logic
    784  1753							;delete old position
    785  1753							;update position
    786  1753							;redraw chars
    787  1753							;draw new position
    788  1753							;wait a jiffy maybe
    789  1753							;check booster
    790  1753							;
    791  1753							;j/f movement
    792  1753							;do similar thing
------- FILE main.s
------- FILE updateGameStateHelper.s LEVEL 2 PASS 3
      0  1753					      include	"updateGameStateHelper.s"
      1  1753							; Helper functions for updateGameState
      2  1753
      3  1753				   get_jump_dir
      4  1753		       a5 14		      lda	jump_info
      5  1755		       29 f0		      and	#$F0
      6  1757		       60		      rts
      7  1758
      8  1758				   get_jump_num
      9  1758		       a5 14		      lda	jump_info
     10  175a		       29 0f		      and	#$0F
     11  175c		       60		      rts
     12  175d
     13  175d				   set_jump_dir
     14  175d		       85 1a		      sta	temp
     15  175f		       20 58 17 	      jsr	get_jump_num
     16  1762		       18		      clc
     17  1763		       65 1a		      adc	temp
     18  1765		       85 14		      sta	jump_info
     19  1767		       60		      rts
     20  1768
     21  1768				   set_jump_num
     22  1768		       85 1a		      sta	temp
     23  176a		       20 53 17 	      jsr	get_jump_dir
     24  176d		       18		      clc
     25  176e		       65 1a		      adc	temp
     26  1770		       85 14		      sta	jump_info
     27  1772		       60		      rts
     28  1773
     29  1773				   get_right
     30  1773		       a5 16		      lda	tile_store+1
     31  1775		       29 0f		      and	#$0F
     32  1777		       60		      rts
     33  1778
     34  1778				   get_left
     35  1778		       a5 16		      lda	tile_store+1
     36  177a		       4a		      lsr
     37  177b		       4a		      lsr
     38  177c		       4a		      lsr
     39  177d		       4a		      lsr
     40  177e		       60		      rts
     41  177f
     42  177f				   get_down
     43  177f		       a5 15		      lda	tile_store
     44  1781		       29 0f		      and	#$0F
     45  1783		       60		      rts
     46  1784
     47  1784				   get_up
     48  1784		       a5 15		      lda	tile_store
     49  1786		       4a		      lsr
     50  1787		       4a		      lsr
     51  1788		       4a		      lsr
     52  1789		       4a		      lsr
     53  178a		       60		      rts
     54  178b
     55  178b				   get_mid
     56  178b		       a5 17		      lda	tile_store+2
     57  178d		       29 0f		      and	#$0F
     58  178f		       60		      rts
     59  1790
     60  1790
     61  1790				   set_right
     62  1790		       85 1a		      sta	temp
     63  1792		       a9 f0		      lda	#$F0
     64  1794		       25 16		      and	tile_store+1
     65  1796		       18		      clc
     66  1797		       65 1a		      adc	temp
     67  1799		       85 16		      sta	tile_store+1
     68  179b		       60		      rts
     69  179c
     70  179c				   set_left
     71  179c		       0a		      asl
     72  179d		       0a		      asl
     73  179e		       0a		      asl
     74  179f		       0a		      asl
     75  17a0		       85 1a		      sta	temp
     76  17a2		       a9 0f		      lda	#$0F
     77  17a4		       25 16		      and	tile_store+1
     78  17a6		       18		      clc
     79  17a7		       65 1a		      adc	temp
     80  17a9		       85 16		      sta	tile_store+1
     81  17ab		       60		      rts
     82  17ac
     83  17ac				   set_down
     84  17ac		       85 1a		      sta	temp
     85  17ae		       a9 f0		      lda	#$F0
     86  17b0		       25 15		      and	tile_store
     87  17b2		       18		      clc
     88  17b3		       65 1a		      adc	temp
     89  17b5		       85 15		      sta	tile_store
     90  17b7		       60		      rts
     91  17b8
     92  17b8				   set_up
     93  17b8		       0a		      asl
     94  17b9		       0a		      asl
     95  17ba		       0a		      asl
     96  17bb		       0a		      asl
     97  17bc		       85 1a		      sta	temp
     98  17be		       a9 0f		      lda	#$0F
     99  17c0		       25 15		      and	tile_store
    100  17c2		       18		      clc
    101  17c3		       65 1a		      adc	temp
    102  17c5		       85 15		      sta	tile_store
    103  17c7		       60		      rts
    104  17c8
    105  17c8				   set_mid
    106  17c8		       29 0f		      and	#$0F
    107  17ca		       85 17		      sta	tile_store+2
    108  17cc		       60		      rts
    109  17cd
    110  17cd				   move_new_position_right
    111  17cd		       18		      clc
    112  17ce		       a5 0b		      lda	new_position	; load and add to low byte
    113  17d0		       69 01		      adc	#$1
    114  17d2		       85 0b		      sta	new_position
    115  17d4		       a5 0c		      lda	new_position+1
    116  17d6		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
    117  17d8		       85 0c		      sta	new_position+1
    118  17da		       18		      clc
    119  17db		       a5 0d		      lda	new_color_position	; load and add to low byte
    120  17dd		       69 01		      adc	#$1
    121  17df		       85 0d		      sta	new_color_position
    122  17e1		       a5 0e		      lda	new_color_position+1
    123  17e3		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
    124  17e5		       85 0e		      sta	new_color_position+1
    125  17e7		       60		      rts
    126  17e8
    127  17e8				   move_new_position_left
    128  17e8		       38		      sec
    129  17e9		       a5 0b		      lda	new_position
    130  17eb		       e9 01		      sbc	#$1
    131  17ed		       85 0b		      sta	new_position
    132  17ef		       a5 0c		      lda	new_position+1
    133  17f1		       e9 00		      sbc	#$0
    134  17f3		       85 0c		      sta	new_position+1
    135  17f5		       38		      sec
    136  17f6		       a5 0d		      lda	new_color_position
    137  17f8		       e9 01		      sbc	#$1
    138  17fa		       85 0d		      sta	new_color_position
    139  17fc		       a5 0e		      lda	new_color_position+1
    140  17fe		       e9 00		      sbc	#$0
    141  1800		       85 0e		      sta	new_color_position+1
    142  1802		       60		      rts
    143  1803
    144  1803
    145  1803				   move_new_position_up
    146  1803		       38		      sec
    147  1804		       a5 0b		      lda	new_position
    148  1806		       e9 16		      sbc	#ROW_SIZE
    149  1808		       85 0b		      sta	new_position
    150  180a		       a5 0c		      lda	new_position+1
    151  180c		       e9 00		      sbc	#$0
    152  180e		       85 0c		      sta	new_position+1
    153  1810		       38		      sec
    154  1811		       a5 0d		      lda	new_color_position
    155  1813		       e9 16		      sbc	#ROW_SIZE
    156  1815		       85 0d		      sta	new_color_position
    157  1817		       a5 0e		      lda	new_color_position+1
    158  1819		       e9 00		      sbc	#$0
    159  181b		       85 0e		      sta	new_color_position+1
    160  181d		       60		      rts
    161  181e
    162  181e				   move_new_position_down
    163  181e		       18		      clc
    164  181f		       a5 0b		      lda	new_position	; load and add to low byte
    165  1821		       69 16		      adc	#ROW_SIZE
    166  1823		       85 0b		      sta	new_position
    167  1825		       a5 0c		      lda	new_position+1
    168  1827		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
    169  1829		       85 0c		      sta	new_position+1
    170  182b		       18		      clc
    171  182c		       a5 0d		      lda	new_color_position	; load and add to low byte
    172  182e		       69 16		      adc	#ROW_SIZE
    173  1830		       85 0d		      sta	new_color_position
    174  1832		       a5 0e		      lda	new_color_position+1
    175  1834		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
    176  1836		       85 0e		      sta	new_color_position+1
    177  1838		       60		      rts
    178  1839
    179  1839				   get_squarebot_draw_position
    180  1839		       38		      sec
    181  183a		       a5 10		      lda	squarebot_position
    182  183c		       e9 17		      sbc	#[ROW_SIZE+1]
    183  183e		       85 10		      sta	squarebot_position
    184  1840		       a5 11		      lda	squarebot_position+1
    185  1842		       e9 00		      sbc	#0
    186  1844		       85 11		      sta	squarebot_position+1
    187  1846		       38		      sec
    188  1847		       a5 12		      lda	squarebot_color_position
    189  1849		       e9 17		      sbc	#[ROW_SIZE+1]
    190  184b		       85 12		      sta	squarebot_color_position
    191  184d		       a5 13		      lda	squarebot_color_position+1
    192  184f		       e9 00		      sbc	#0
    193  1851		       85 13		      sta	squarebot_color_position+1
    194  1853		       60		      rts
    195  1854
    196  1854				   get_squarebot_game_position
    197  1854		       18		      clc
    198  1855		       a5 10		      lda	squarebot_position
    199  1857		       69 17		      adc	#[ROW_SIZE+1]
    200  1859		       85 10		      sta	squarebot_position
    201  185b		       a5 11		      lda	squarebot_position+1
    202  185d		       69 00		      adc	#0
    203  185f		       85 11		      sta	squarebot_position+1
    204  1861		       18		      clc
    205  1862		       a5 12		      lda	squarebot_color_position
    206  1864		       69 17		      adc	#[ROW_SIZE+1]
    207  1866		       85 12		      sta	squarebot_color_position
    208  1868		       a5 13		      lda	squarebot_color_position+1
    209  186a		       69 00		      adc	#0
    210  186c		       85 13		      sta	squarebot_color_position+1
    211  186e		       60		      rts
    212  186f
    213  186f				   get_new_draw_position
    214  186f		       38		      sec
    215  1870		       a5 0b		      lda	new_position
    216  1872		       e9 17		      sbc	#[ROW_SIZE+1]
    217  1874		       85 0b		      sta	new_position
    218  1876		       a5 0c		      lda	new_position+1
    219  1878		       e9 00		      sbc	#0
    220  187a		       85 0c		      sta	new_position+1
    221  187c		       38		      sec
    222  187d		       a5 0d		      lda	new_color_position
    223  187f		       e9 17		      sbc	#[ROW_SIZE+1]
    224  1881		       85 0d		      sta	new_color_position
    225  1883		       a5 0e		      lda	new_color_position+1
    226  1885		       e9 00		      sbc	#0
    227  1887		       85 0e		      sta	new_color_position+1
    228  1889		       60		      rts
    229  188a
    230  188a				   get_new_game_position
    231  188a		       18		      clc
    232  188b		       a5 0b		      lda	new_position
    233  188d		       69 17		      adc	#[ROW_SIZE+1]
    234  188f		       85 0b		      sta	new_position
    235  1891		       a5 0c		      lda	new_position+1
    236  1893		       69 00		      adc	#0
    237  1895		       85 0c		      sta	new_position+1
    238  1897		       18		      clc
    239  1898		       a5 0d		      lda	new_color_position
    240  189a		       69 17		      adc	#[ROW_SIZE+1]
    241  189c		       85 0d		      sta	new_color_position
    242  189e		       a5 0e		      lda	new_color_position+1
    243  18a0		       69 00		      adc	#0
    244  18a2		       85 0e		      sta	new_color_position+1
    245  18a4		       60		      rts
    246  18a5
    247  18a5				   get_tiles_u
    248  18a5		       20 6f 18 	      jsr	get_new_draw_position
    249  18a8		       20 8b 17 	      jsr	get_mid
    250  18ab		       20 ac 17 	      jsr	set_down
    251  18ae		       20 84 17 	      jsr	get_up
    252  18b1		       20 c8 17 	      jsr	set_mid
    253  18b4		       a0 16		      ldy	#ROW_SIZE
    254  18b6		       b1 0b		      lda	(new_position),y
    255  18b8		       20 9c 17 	      jsr	set_left
    256  18bb		       a0 18		      ldy	#[ROW_SIZE+2]
    257  18bd		       b1 0b		      lda	(new_position),y
    258  18bf		       20 90 17 	      jsr	set_right
    259  18c2		       a0 01		      ldy	#1
    260  18c4		       b1 0b		      lda	(new_position),y
    261  18c6		       20 b8 17 	      jsr	set_up
    262  18c9		       20 8a 18 	      jsr	get_new_game_position
    263  18cc		       60		      rts
    264  18cd
    265  18cd				   get_tiles_d
    266  18cd		       20 6f 18 	      jsr	get_new_draw_position
    267  18d0		       20 8b 17 	      jsr	get_mid
    268  18d3		       20 b8 17 	      jsr	set_up
    269  18d6		       20 7f 17 	      jsr	get_down
    270  18d9		       20 c8 17 	      jsr	set_mid
    271  18dc		       a0 16		      ldy	#ROW_SIZE
    272  18de		       b1 0b		      lda	(new_position),y
    273  18e0		       20 9c 17 	      jsr	set_left
    274  18e3		       a0 18		      ldy	#[ROW_SIZE+2]
    275  18e5		       b1 0b		      lda	(new_position),y
    276  18e7		       20 90 17 	      jsr	set_right
    277  18ea		       a0 2d		      ldy	#[[ROW_SIZE*2]+1]
    278  18ec		       b1 0b		      lda	(new_position),y
    279  18ee		       20 ac 17 	      jsr	set_down
    280  18f1		       20 8a 18 	      jsr	get_new_game_position
    281  18f4		       60		      rts
    282  18f5
    283  18f5				   get_tiles_l
    284  18f5		       20 6f 18 	      jsr	get_new_draw_position
    285  18f8		       20 8b 17 	      jsr	get_mid
    286  18fb		       20 90 17 	      jsr	set_right
    287  18fe		       20 78 17 	      jsr	get_left
    288  1901		       20 c8 17 	      jsr	set_mid
    289  1904		       a0 01		      ldy	#1
    290  1906		       b1 0b		      lda	(new_position),y
    291  1908		       20 b8 17 	      jsr	set_up
    292  190b		       a0 2d		      ldy	#[[ROW_SIZE*2]+1]
    293  190d		       b1 0b		      lda	(new_position),y
    294  190f		       20 ac 17 	      jsr	set_down
    295  1912		       a0 16		      ldy	#ROW_SIZE
    296  1914		       b1 0b		      lda	(new_position),y
    297  1916		       20 9c 17 	      jsr	set_left
    298  1919		       20 8a 18 	      jsr	get_new_game_position
    299  191c		       60		      rts
    300  191d
    301  191d				   get_tiles_r
    302  191d		       20 6f 18 	      jsr	get_new_draw_position	; moves new_position and its color pos up and left one tile
    303  1920		       20 8b 17 	      jsr	get_mid
    304  1923		       20 9c 17 	      jsr	set_left
    305  1926		       20 73 17 	      jsr	get_right
    306  1929		       20 c8 17 	      jsr	set_mid
    307  192c		       a0 01		      ldy	#1
    308  192e		       b1 0b		      lda	(new_position),y
    309  1930		       20 b8 17 	      jsr	set_up
    310  1933		       a0 2d		      ldy	#[[ROW_SIZE*2]+1]
    311  1935		       b1 0b		      lda	(new_position),y
    312  1937		       20 ac 17 	      jsr	set_down
    313  193a		       a0 18		      ldy	#[ROW_SIZE+2]
    314  193c		       b1 0b		      lda	(new_position),y
    315  193e		       20 90 17 	      jsr	set_right
    316  1941		       20 8a 18 	      jsr	get_new_game_position	; move new_position and its color pos back
    317  1944		       60		      rts
------- FILE main.s
    144  1945
    145  1945				   compressed_screen_data_start
    146  1945					      incbin	"../data/jesseTitleScreen_compressed"	; got via 'bsave ""'
    147  19af
    148  19af				   level_data_start
    149  19af					      incbin	"../data/levels/binary_levels/jesse_1"
    150  19b9					      incbin	"../data/levels/binary_levels/jesse_2"
    151  19dd					      incbin	"../data/levels/binary_levels/jesse_3"
    152  19fd					      incbin	"../data/levels/binary_levels/jesse_4"
    153  1a31
------- FILE memoryCheck.s LEVEL 2 PASS 3
      0  1a31					      include	"memoryCheck.s"	; code to make sure the program isn't too large and enters screen memory
      1  1a31		       0a 30	   BYTES_USED =	.-$1001	; location counter minus starting location = total bytes used
      2  1a31		       1e 00	   SCREEN_MEMORY_START =	$1e00
 2608 bytes used
      3  1a31					      echo	[BYTES_USED]d, "bytes used"
 Ending program at memory location (base 10):  6705
      4  1a31					      echo	"Ending program at memory location (base 10): ", [.]d
      5  1a31				  -	      if	. >= SCREEN_MEMORY_START	; if program entering screen memory
      6  1a31				  -	      echo	"Throwing error because program is too large, and has entered screen memory!"
      7  1a31				  -	      err
      8  1a31					      endif
------- FILE main.s
    155  1a31
    156  1a31
    157  1c00					      org	character_set_begin
    158  1c00		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; blank 0
    159  1c08		       7e 42 7e 42*	      BYTE.b	$7E, $42, $7E, $42, $7E, $42, $7E, $42	; ladder 1
    160  1c10		       ff 5a 00 00*	      BYTE.b	$FF, $5A, $00, $00, $00, $00, $00, $00	; platform 2
    161  1c18		       ff ff ff ff*	      BYTE.b	$FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF	; wall 3
    162  1c20		       ff 9d a3 ac*	      BYTE.b	$FF, $9D, $A3, $AC, $A5, $99, $C3, $FF	; exit (door) 4
    163  1c28		       ff ff c3 c3*	      BYTE.b	$FF, $FF, $C3, $C3, $E7, $E7, $E7, $FF	; locked wall 5
    164  1c30		       ff ee f1 ef*	      BYTE.b	$FF, $EE, $F1, $EF, $57, $8F, $F3, $FF	; breakable wall 6
    165  1c38		       3c 42 99 bd*	      BYTE.b	$3C, $42, $99, $BD, $89, $91, $42, $3C	; booster powerup 7
    166  1c40		       3c 42 99 99*	      BYTE.b	$3C, $42, $99, $99, $91, $99, $42, $3C	; key powerup 8
    167  1c48		       3c 42 91 99*	      BYTE.b	$3C, $42, $91, $99, $BD, $81, $42, $3C	; spike powerup 9
    168  1c50		       10 30 f0 f0*	      BYTE.b	$10, $30, $F0, $F0, $F0, $F0, $30, $10	; ready booster attachment (R) 10
    169  1c58		       10 30 f1 ff*	      BYTE.b	$10, $30, $F1, $FF, $FE, $F1, $30, $10	; active booster attachment (R) 11
    170  1c60		       00 00 fe fe*	      BYTE.b	$00, $00, $FE, $FE, $6A, $0A, $0E, $00	; key attachment (R) 12
    171  1c68		       80 c0 f0 fe*	      BYTE.b	$80, $C0, $F0, $FE, $F0, $C0, $80, $00	; spike attachment (R) 13
    172  1c70		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; charU 14
    173  1c78		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; charD 15
    174  1c80		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; charL 16
    175  1c88		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; charR 17
    176  1c90		       ff 81 a5 81*	      BYTE.b	$FF, $81, $A5, $81, $BD, $81, $81, $FF	; squarebot 18
