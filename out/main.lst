------- FILE main.s LEVEL 1 PASS 3
      1  1d80 ????						; title screen program -- use hand-made compression method (esentially just RLE, see rleEncoding.py)
      2  1d80 ????				      processor	6502
      3  1d80 ????
      4 U0033 ????				      seg.u	ZP
      5 U0000					      org	$0
      6 U0000
      7 U0000
      8 U0000		       00 00	   screen_cursor ds.w	1	; stores the current screen memory address
      9 U0002		       00 00	   color_cursor ds.w	1	; store current color memory address
     10 U0004		       00 00	   current_level ds.w	1
     11 U0006		       00 00	   next_level ds.w	1
     12 U0008		       00	   level_reset ds.b	1
     13 U0009		       00	   level_completed ds.b	1
     14 U000a		       00	   level_data_index ds.b	1	; for temporarily saving index registers
     15 U000b		       00 00	   new_position ds.w	1	; use to store position of (proposed) new location for squarebot
     16 U000d		       00 00	   new_color_position ds.w	1	; use to store position of (proposed) new location for squarebot
     17 U000f		       00	   current_time ds.b	1	; store only the last byte of the jiffy clock
     18 U0010		       00 00	   squarebot_position ds.w	1
     19 U0012		       00 00	   squarebot_color_position ds.w	1
     20 U0014		       00	   jump_dir   ds.b	1	; 0 = up, 1=left, 2=right
     21 U0015		       00	   jump_num   ds.b	1
     22 U0016		       00 00 00 00*tile_store ds.b	5
     23 U001b							;colorStore ds.b 5 ; U, D, L, R, M  not the most efficient storage but it needs to also be efficient to decompress
     24 U001b		       00 00 00 00 attached_powerups ds.b	4
     25 U001f							; $0=none  $1=ignitedBooster $A=readyBooster  $B=activeBooster  $C=key  $D=spike(change into shield)
     26 U001f		       00 00 00 00*delta      ds.b	5	; U D L R M
     27 U0024		       00 00 00 00 chars      ds.b	4
     28 U0028		       00 00 00 00 temp       ds.b	4	; for temporary storage of things. mainly used in updateGameState
     29 U002c		       00	   move_dir_store ds.b	1	; exclusively for move_dir and related subroutines
     30 U002d		       00 00 00    chareor    ds.b	3	; for the incredibly complex operation of eoring chars
     31 U0030		       00	   count_chars_drawn ds.b	1	; count number of chars drawn on screen in the current run
     32 U0031		       00	   temp_a     ds.b	1	; store acc
     33 U0032		       00	   temp_x     ds.b	1	; store x
     34  1d80 ????				      seg
     35  1d80 ????
     36  1d80 ????						; constants
     37  1d80 ????	       00 20	   BLANK_CHAR =	$20
     38  1d80 ????
     39  1d80 ????	       00 00	   SCREEN_CURSOR_BEGINNING_LOW_BYTE =	$00
     40  1d80 ????	       00 1e	   SCREEN_CURSOR_BEGINNING_HIGH_BYTE =	$1e
     41  1d80 ????
     42  1d80 ????						; last screen location
     43  1d80 ????	       00 fa	   END_OF_SCREEN_LOW_BYTE =	$fa
     44  1d80 ????	       00 1f	   END_OF_SCREEN_HIGH_BYTE =	$1f
     45  1d80 ????
     46  1d80 ????						; beginning of color memory
     47  1d80 ????	       00 00	   COLOR_CURSOR_BEGINNING_LOW_BYTE =	$00
     48  1d80 ????	       00 96	   COLOR_CURSOR_BEGINNING_HIGH_BYTE =	$96
     49  1d80 ????	       00 00	   RED_COLOR_CODE =	0
     50  1d80 ????
     51  1d80 ????	       00 20	   SPACE_KEY  =	$20
     52  1d80 ????	       00 30	   Q_KEY      =	$30
     53  1d80 ????	       00 09	   W_KEY      =	$09
     54  1d80 ????	       00 31	   E_KEY      =	$31
     55  1d80 ????	       00 11	   A_KEY      =	$11
     56  1d80 ????	       00 29	   S_KEY      =	$29
     57  1d80 ????	       00 12	   D_KEY      =	$12
     58  1d80 ????	       00 0d	   SKIP_KEY   =	$0d	; press P to skip to next  level
     59  1d80 ????	       00 34	   MENU_KEY   =	$34	; press O to return to menu
     60  1d80 ????	       00 32	   RESET_KEY  =	$32	; press T to restart level i assume
     61  1d80 ????	       00 01	   JUMP_SIZE  =	$01	; number of characters a jump causes
     62  1d80 ????	       00 16	   ROW_SIZE   =	$16
     63  1d80 ????
     64  1d80 ????						; memory locations
     65  1d80 ????	       10 01	   user_memory_start =	$1001
     66  1d80 ????	       00 c5	   currently_pressed_key =	$c5	;proposed fix: mem editor 028 abc space bar loops
     67  1d80 ????	       00 a0	   jiffy_clock =	$A0
     68  1d80 ????	       90 05	   character_info_register =	$9005
     69  1d80 ????	       1c 00	   character_set_begin =	$1c00
     70  1d80 ????	       00 16	   tile_store_addr =	$16
     71  1d80 ????	       00 1b	   attached_powerups_addr =	$1b
     72  1d80 ????	       00 1f	   delta_addr =	$1f
     73  1d80 ????	       00 24	   chars_addr =	$24
     74  1d80 ????
     75  1d80 ????						; begin location counter at 4096 (user memory)
     76  1001					      org	user_memory_start
------- FILE stub.s LEVEL 2 PASS 3
      0  1001					      include	"stub.s"	; stub contains BASIC sys cmd to run the machine language code
      1  1001		       00 9e	   SYS_CMD_TOKEN =	$9e
      2  1001		       00 0a	   STUB_LINE_NUMBER =	10
      3  1001							; BASIC stub -- SYS cmd to run machine language 
      4  1001		       0b 10		      dc.w	nextstmt	; link; beginning of basic
      5  1003		       0a 00		      dc.w	STUB_LINE_NUMBER	; line number 
      6  1005		       9e 34 31 30*	      dc.b	SYS_CMD_TOKEN, [start]d, 0	; token for sys with operand as address to "start" label
      7  100b				   nextstmt
      8  100b		       00 00		      dc.w	0
------- FILE main.s
     78  100d
     79  100d				   start
     80  100d							; use combination of RAM (first 128 chars at 7168) & ROM character set
     81  100d		       a9 ff		      lda	#255
     82  100f		       8d 05 90 	      sta	character_info_register
     83  1012
     84  1012							; initialize some variables in the zero page
     85  1012		       a9 01		      lda	#1
     86  1014		       85 08		      sta	level_reset
     87  1016		       a9 00		      lda	#0
     88  1018		       85 09		      sta	level_completed
     89  101a
     90  101a		       a9 5e		      lda	#<level_data_start
     91  101c		       85 04		      sta	current_level
     92  101e		       a9 17		      lda	#>level_data_start
     93  1020		       85 05		      sta	current_level+1
     94  1022
     95  1022		       a9 00		      lda	#0
     96  1024		       85 30		      sta	count_chars_drawn
     97  1026		       85 15		      sta	jump_num
     98  1028		       85 14		      sta	jump_dir
     99  102a		       85 1b		      sta	attached_powerups
    100  102c		       85 1c		      sta	attached_powerups+1
    101  102e		       85 1d		      sta	attached_powerups+2
    102  1030		       85 1e		      sta	attached_powerups+3
    103  1032		       85 16		      sta	tile_store
    104  1034		       85 17		      sta	tile_store+1
    105  1036		       85 18		      sta	tile_store+2
    106  1038		       85 19		      sta	tile_store+3
    107  103a		       85 1a		      sta	tile_store+4
    108  103c		       85 28		      sta	temp
    109  103e		       85 29		      sta	temp+1
    110  1040		       85 2a		      sta	temp+2
    111  1042		       85 2b		      sta	temp+3
    112  1044		       a9 01		      lda	#1	; up
    113  1046		       85 1f		      sta	delta
    114  1048		       a9 2d		      lda	#[ROW_SIZE+ROW_SIZE+1]	; down
    115  104a		       85 20		      sta	delta+1
    116  104c		       a9 16		      lda	#ROW_SIZE	; left
    117  104e		       85 21		      sta	delta+2
    118  1050		       a9 18		      lda	#[ROW_SIZE+2]	; right
    119  1052		       85 22		      sta	delta+3
    120  1054		       a9 17		      lda	#[ROW_SIZE+1]	; mid
    121  1056		       85 23		      sta	delta+4
    122  1058		       a9 0f		      lda	#CHAR_U	; index of powerup characters
    123  105a		       85 24		      sta	chars
    124  105c		       a9 10		      lda	#CHAR_D
    125  105e		       85 25		      sta	chars+1
    126  1060		       a9 11		      lda	#CHAR_L
    127  1062		       85 26		      sta	chars+2
    128  1064		       a9 12		      lda	#CHAR_R
    129  1066		       85 27		      sta	chars+3
    130  1068
------- FILE titleScreen.s LEVEL 2 PASS 3
      0  1068					      include	"titleScreen.s"
      1  1068		       00 00	   TITLE_SCREEN_CHAR_COLOR =	0
      2  1068		       00 0f	   ENTER_KEY  =	$0f
      3  1068
      4  1068				   display_title_screen
      5  1068		       a9 00		      lda	#SCREEN_CURSOR_BEGINNING_LOW_BYTE
      6  106a		       85 00		      sta	screen_cursor
      7  106c		       a9 1e		      lda	#SCREEN_CURSOR_BEGINNING_HIGH_BYTE	; store 1e in location 01
      8  106e		       85 01		      sta	screen_cursor+1
      9  1070
     10  1070		       a9 00		      lda	#COLOR_CURSOR_BEGINNING_LOW_BYTE
     11  1072		       85 02		      sta	color_cursor
     12  1074		       a9 96		      lda	#COLOR_CURSOR_BEGINNING_HIGH_BYTE
     13  1076		       85 03		      sta	color_cursor+1
     14  1078
     15  1078		       a0 00		      ldy	#$0	; to use for indirect indexed addressing
     16  107a		       a2 00		      ldx	#$0
     17  107c
     18  107c		       20 8c 10 	      jsr	draw_title_screen_chars_loop
     19  107f		       a0 00		      ldy	#$0	; to use for indirect indexed addressing
     20  1081		       a2 00		      ldx	#$0
     21  1083
     22  1083
     23  1083				   infinite_loop
     24  1083		       a5 c5		      lda	currently_pressed_key
     25  1085		       c9 0f		      cmp	#ENTER_KEY
     26  1087		       f0 68		      beq	gameLoop
     27  1089		       4c 83 10 	      jmp	infinite_loop
     28  108c
     29  108c
     30  108c				   draw_title_screen_chars_loop
     31  108c		       bd ae 16 	      lda	compressed_screen_data_start,X	; accumulator stores num times to repeat the byte
     32  108f		       20 9d 10 	      jsr	draw_character	; draw the character that many times
     33  1092		       e8		      inx
     34  1093		       e8		      inx
     35  1094		       20 e1 10 	      jsr	check_if_screen_cursor_at_end
     36  1097		       90 f3		      bcc	draw_title_screen_chars_loop
     37  1099		       60		      rts
     38  109a
     39  109a				   back_to_start		;if menu button is pressed go back to start 
     40  109a		       4c 0d 10 	      jmp	start
     41  109d
     42  109d							; draw the character in Y register for (value of accumulator) number of times
     43  109d				   draw_character
     44  109d							; if accumulator == 0, return; otherwise, subtract 1 from accumulator and continue drawing the letter at Y
     45  109d		       f0 26		      beq	draw_character_end
     46  109f		       38		      sec
     47  10a0		       e9 01		      sbc	#1
     48  10a2		       48		      pha		; push accumulator onto stack
     49  10a3
     50  10a3							; store current char at screen cursor location
     51  10a3		       a0 00		      ldy	#0
     52  10a5		       bd af 16 	      lda	compressed_screen_data_start+1,X	; load cur char to draw
     53  10a8
     54  10a8							; solid block in the title screen editor is the a0 character; we convert that to the equivalent here (wall), as we cant access that char
     55  10a8		       c9 64		      cmp	#100
     56  10aa		       90 06		      bcc	below_100	; below 100 - add 128, map directly
     57  10ac		       38		      sec
     58  10ad		       e9 64		      sbc	#100
     59  10af		       4c b4 10 	      jmp	draw_title_screen_char
     60  10b2							; dont_map_wall
     61  10b2				   below_100
     62  10b2		       69 80		      adc	#128
     63  10b4				   draw_title_screen_char
     64  10b4		       91 00		      sta	(screen_cursor),Y	; draw it on screen
     65  10b6
     66  10b6
     67  10b6							; add color to the screen location if it's not a space
     68  10b6							; because our title screen only has one color, and only displays it for characters that arent space, we can get away with this "optimization",
     69  10b6							; and avoid adding color data
     70  10b6		       c9 a0		      cmp	#BLANK_CHAR+128
     71  10b8		       f0 04		      beq	dont_color
     72  10ba
     73  10ba		       a9 00		      lda	#TITLE_SCREEN_CHAR_COLOR
     74  10bc		       91 02		      sta	(color_cursor),Y
     75  10be
     76  10be				   dont_color
     77  10be		       20 c6 10 	      jsr	add_one_to_screen_cursor
     78  10c1		       68		      pla		; put the current 'count' (remaining times to draw character) back on accumulator
     79  10c2		       4c 9d 10 	      jmp	draw_character
     80  10c5
     81  10c5				   draw_character_end
     82  10c5		       60		      rts
     83  10c6
     84  10c6
     85  10c6				   add_one_to_screen_cursor
     86  10c6		       18		      clc
     87  10c7		       a5 00		      lda	screen_cursor	; load and add to low byte
     88  10c9		       69 01		      adc	#$1
     89  10cb		       85 00		      sta	screen_cursor
     90  10cd		       a5 01		      lda	screen_cursor+1
     91  10cf		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
     92  10d1		       85 01		      sta	screen_cursor+1
     93  10d3
     94  10d3							; add to color cursor as well
     95  10d3		       18		      clc
     96  10d4		       a5 02		      lda	color_cursor	; load and add to low byte
     97  10d6		       69 01		      adc	#$1
     98  10d8		       85 02		      sta	color_cursor
     99  10da		       a5 03		      lda	color_cursor+1
    100  10dc		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
    101  10de		       85 03		      sta	color_cursor+1
    102  10e0		       60		      rts
    103  10e1
    104  10e1				   check_if_screen_cursor_at_end		; set carry flag if screen_cursor at position $1ff9 (8185
    105  10e1		       a5 00		      lda	screen_cursor	; load value at screen_cursor low byte
    106  10e3		       c9 fa		      cmp	#END_OF_SCREEN_LOW_BYTE
    107  10e5		       d0 06		      bne	check_if_screen_cursor_at_end_return_false	; if low byte doesnt match, return with carry flag as neg
    108  10e7
    109  10e7		       a5 01		      lda	screen_cursor+1
    110  10e9		       c9 1f		      cmp	#END_OF_SCREEN_HIGH_BYTE
    111  10eb		       f0 02		      beq	check_if_screen_cursor_at_end_return_true	; if high byte matches, set carry flag
    112  10ed
    113  10ed				   check_if_screen_cursor_at_end_return_false
    114  10ed		       18		      clc
    115  10ee		       60		      rts
    116  10ef
    117  10ef				   check_if_screen_cursor_at_end_return_true
    118  10ef		       38		      sec
    119  10f0		       60		      rts
------- FILE main.s
    132  10f1
    133  10f1							; title screen code jumps here once enter pressed
    134  10f1				   gameLoop
    135  10f1		       20 46 11 	      jsr	update_level
    136  10f4		       a9 00		      lda	#0
    137  10f6		       85 08		      sta	level_reset
    138  10f8		       20 d2 12 	      jsr	update_game_state
    139  10fb		       20 1b 11 	      jsr	check_extra_keys
    140  10fe		       b0 9a		      bcs	back_to_start
    141  1100		       20 12 11 	      jsr	wait_until_next_frame
    142  1103		       20 12 11 	      jsr	wait_until_next_frame
    143  1106		       20 12 11 	      jsr	wait_until_next_frame
    144  1109		       20 12 11 	      jsr	wait_until_next_frame
    145  110c		       20 12 11 	      jsr	wait_until_next_frame
    146  110f		       4c f1 10 	      jmp	gameLoop
    147  1112
    148  1112				   wait_until_next_frame		; wait one jiffy before completing game loop
    149  1112		       a5 a2		      lda	jiffy_clock+2
    150  1114		       c5 0f		      cmp	current_time
    151  1116		       f0 fa		      beq	wait_until_next_frame
    152  1118		       85 0f		      sta	current_time
    153  111a		       60		      rts
    154  111b
    155  111b				   check_extra_keys
    156  111b		       a5 c5		      lda	currently_pressed_key
    157  111d		       c9 32		      cmp	#RESET_KEY
    158  111f		       d0 0a		      bne	check_skip
    159  1121		       20 94 14 	      jsr	delete_squarebot
    160  1124		       a9 01		      lda	#1
    161  1126		       85 08		      sta	level_reset
    162  1128		       4c 44 11 	      jmp	return_check
    163  112b				   check_skip
    164  112b		       c9 0d		      cmp	#SKIP_KEY
    165  112d		       d0 0c		      bne	check_menu
    166  112f		       20 94 14 	      jsr	delete_squarebot
    167  1132		       a9 01		      lda	#1
    168  1134		       85 09		      sta	level_completed
    169  1136		       85 08		      sta	level_reset
    170  1138		       4c 44 11 	      jmp	return_check
    171  113b				   check_menu
    172  113b		       c9 34		      cmp	#MENU_KEY
    173  113d		       d0 05		      bne	return_check
    174  113f		       20 94 14 	      jsr	delete_squarebot
    175  1142		       38		      sec
    176  1143		       60		      rts		; tell them to restart
    177  1144				   return_check
    178  1144		       18		      clc
    179  1145		       60		      rts
    180  1146
------- FILE updateLevel.s LEVEL 2 PASS 3
      0  1146					      include	"updateLevel.s"
      1  1146		       00 01	   LEVEL_IS_DONE =	1
      2  1146		       00 00	   LEVEL_NOT_DONE =	0
      3  1146		       00 01	   SHOULD_RESET =	1
      4  1146		       00 00	   SHOULD_NOT_RESET =	0
      5  1146
      6  1146							; only first 4 bits really matter here; refer to readme for guide on lvl format
      7  1146		       00 00	   BLANK_SPACE =	0	; 000000000
      8  1146		       00 10	   STARTING_POINT =	16	; 00010000
      9  1146		       00 20	   WALL       =	32	; 00100000
     10  1146		       00 30	   BREAKABLE_WALL =	48	; 00110000
     11  1146		       00 40	   LOCKED_WALL =	64	; 01000000
     12  1146		       00 50	   LADDER     =	80	; 01010000
     13  1146		       00 60	   EXIT       =	96	; 01100000
     14  1146		       00 70	   PLATFORM   =	112	; 01110000
     15  1146		       00 80	   KEY	      =	128	; 10000000
     16  1146		       00 90	   SPIKE      =	144	; 10010000
     17  1146		       00 a0	   BOOSTER    =	160	; 10100000
     18  1146		       00 b0	   LOCKED_EXIT =	176	; 1011000
     19  1146
     20  1146		       00 00	   WALL_COLOR =	0
     21  1146		       00 00	   BREAKABLE_WALL_COLOR =	0
     22  1146		       00 00	   LOCKED_WALL_COLOR =	0
     23  1146		       00 00	   LADDER_COLOR =	0	;6
     24  1146		       00 00	   EXIT_COLOR =	0	;6
     25  1146		       00 00	   LOCKED_EXIT_COLOR =	0
     26  1146		       00 00	   PLATFORM_COLOR =	0	;4
     27  1146		       00 00	   SPIKE_COLOR =	0	;2
     28  1146		       00 00	   KEY_P_COLOR =	0	;7
     29  1146		       00 00	   BOOSTER_P_COLOR =	0	;6
     30  1146		       00 02	   SQUAREBOT_COLOR =	2
     31  1146
     32  1146		       00 00	   BLANK_TILE_CHAR =	$00	; use this instead of BLANK_CHAR, allows me to save space with tile_store
     33  1146		       00 01	   LADDER_CHAR =	$01
     34  1146		       00 02	   PLATFORM_CHAR =	$02
     35  1146		       00 03	   WALL_CHAR  =	$03
     36  1146		       00 04	   EXIT_CHAR  =	$04
     37  1146		       00 05	   LOCKED_EXIT_CHAR =	$05
     38  1146		       00 06	   LOCKED_WALL_CHAR =	$06
     39  1146		       00 07	   BREAKABLE_WALL_CHAR =	$07
     40  1146		       00 08	   SPIKE_CHAR =	$08
     41  1146		       00 09	   BOOSTER_P_CHAR =	$09
     42  1146		       00 0a	   KEY_P_CHAR =	$0A
     43  1146		       00 14	   RBOOSTER_A_CHAR =	$14
     44  1146		       00 18	   ABOOSTER_A_CHAR =	$18
     45  1146		       00 1c	   KEY_A_CHAR =	$1C
     46  1146		       00 0f	   CHAR_U     =	$0F
     47  1146		       00 10	   CHAR_D     =	$10
     48  1146		       00 11	   CHAR_L     =	$11
     49  1146		       00 12	   CHAR_R     =	$12
     50  1146		       00 13	   SQUAREBOT_CHAR =	$13
     51  1146		       00 17	   LEVEL_BEGINNING_LOW_BYTE =	$17
     52  1146		       00 1e	   LEVEL_BEGINNING_HIGH_BYTE =	$1e
     53  1146		       00 17	   LEVEL_COLOR_BEGINNING_LOW_BYTE =	$17
     54  1146		       00 96	   LEVEL_COLOR_BEGINNING_HIGH_BYTE =	$96
     55  1146		       00 e5	   END_OF_LEVEL_LOW_BYTE =	$e5
     56  1146		       00 1f	   END_OF_LEVEL_HIGH_BYTE =	$1f
     57  1146
     58  1146				   update_level
     59  1146							; check if the level is completed; set current_level to next_level if so
     60  1146		       a5 09		      lda	level_completed
     61  1148		       c9 01		      cmp	#LEVEL_IS_DONE	; (try optimizing later)
     62  114a		       d0 16		      bne	dont_update
     63  114c
     64  114c							; level is done; reset level completed
     65  114c		       a9 00		      lda	#LEVEL_NOT_DONE
     66  114e		       85 09		      sta	level_completed
     67  1150
     68  1150							; delete squarebot
     69  1150		       20 94 14 	      jsr	delete_squarebot
     70  1153
     71  1153							; now set current_level to next_level
     72  1153		       20 b4 12 	      jsr	player_movement
     73  1156		       a5 06		      lda	next_level
     74  1158		       85 04		      sta	current_level
     75  115a		       a5 07		      lda	next_level+1
     76  115c		       85 05		      sta	current_level+1
     77  115e
     78  115e		       a9 00		      lda	#0
     79  1160		       85 30		      sta	count_chars_drawn
     80  1162
     81  1162				   dont_update
     82  1162							; now check if level reset was set
     83  1162		       a5 08		      lda	level_reset
     84  1164		       c9 00		      cmp	#0
     85  1166		       d0 01		      bne	continue_update	; if not, go back to game loop
     86  1168		       60		      rts
     87  1169
     88  1169				   continue_update
     89  1169							; if it was, update the level
     90  1169		       a9 17		      lda	#LEVEL_BEGINNING_LOW_BYTE
     91  116b		       85 00		      sta	screen_cursor
     92  116d		       a9 1e		      lda	#LEVEL_BEGINNING_HIGH_BYTE
     93  116f		       85 01		      sta	screen_cursor+1
     94  1171
     95  1171		       a9 17		      lda	#LEVEL_COLOR_BEGINNING_LOW_BYTE
     96  1173		       85 02		      sta	color_cursor
     97  1175		       a9 96		      lda	#LEVEL_COLOR_BEGINNING_HIGH_BYTE
     98  1177		       85 03		      sta	color_cursor+1
     99  1179
    100  1179		       a2 00		      ldx	#0
    101  117b		       a0 00		      ldy	#0
    102  117d		       84 0a		      sty	level_data_index
    103  117f
    104  117f		       a9 00		      lda	#0
    105  1181		       85 15		      sta	jump_num
    106  1183		       85 14		      sta	jump_dir
    107  1185		       85 1b		      sta	attached_powerups
    108  1187		       85 1c		      sta	attached_powerups+1
    109  1189		       85 1d		      sta	attached_powerups+2
    110  118b		       85 1e		      sta	attached_powerups+3
    111  118d		       85 16		      sta	tile_store
    112  118f		       85 17		      sta	tile_store+1
    113  1191		       85 18		      sta	tile_store+2
    114  1193		       85 19		      sta	tile_store+3
    115  1195		       85 1a		      sta	tile_store+4
    116  1197		       85 28		      sta	temp
    117  1199		       85 29		      sta	temp+1
    118  119b		       85 2a		      sta	temp+2
    119  119d		       85 2b		      sta	temp+3
    120  119f
    121  119f							; draw (or redraw on reset) the current level
    122  119f				   draw_level_loop
    123  119f							; y stores our index in the current level data
    124  119f		       20 a4 12 	      jsr	check_if_level_cursor_at_end
    125  11a2		       b0 10		      bcs	update_level_return
    126  11a4
    127  11a4		       a4 0a		      ldy	level_data_index
    128  11a6		       b1 04		      lda	(current_level),y	; accumulator stores the number of times to repeat the next byte  
    129  11a8
    130  11a8		       20 c2 11 	      jsr	draw_sequence
    131  11ab
    132  11ab		       a4 0a		      ldy	level_data_index
    133  11ad		       c8		      iny		; set y to point to next length byte (iterate 2 at a time)
    134  11ae		       c8		      iny
    135  11af		       84 0a		      sty	level_data_index
    136  11b1		       4c 9f 11 	      jmp	draw_level_loop
    137  11b4
    138  11b4
    139  11b4				   update_level_return
    140  11b4							; update next level pointer to point to byte after current level
    141  11b4		       a5 04		      lda	current_level
    142  11b6		       18		      clc
    143  11b7		       65 0a		      adc	level_data_index
    144  11b9		       85 06		      sta	next_level
    145  11bb		       a5 05		      lda	current_level+1
    146  11bd		       69 00		      adc	#0
    147  11bf		       85 07		      sta	next_level+1
    148  11c1		       60		      rts
    149  11c2
    150  11c2
    151  11c2
    152  11c2				   draw_sequence
    153  11c2							; if acc == 0, return; otherwise subtract 1, draw the next 2 chars
    154  11c2		       f0 1c		      beq	draw_sequence_end
    155  11c4		       38		      sec
    156  11c5		       e9 01		      sbc	#1
    157  11c7		       48		      pha		; push accumulator onto stack
    158  11c8
    159  11c8		       a4 0a		      ldy	level_data_index
    160  11ca		       c8		      iny		; (so we can access the "element" byte after the length byte)
    161  11cb		       b1 04		      lda	(current_level),y	; get formatted byte (see squarebot doc)
    162  11cd		       0a		      asl		; lol
    163  11ce		       0a		      asl
    164  11cf		       0a		      asl
    165  11d0		       0a		      asl
    166  11d1		       20 e1 11 	      jsr	draw_high_bits	; draw char represented by the 4 high bits
    167  11d4
    168  11d4		       a4 0a		      ldy	level_data_index
    169  11d6		       c8		      iny
    170  11d7
    171  11d7		       b1 04		      lda	(current_level),y
    172  11d9		       20 e1 11 	      jsr	draw_high_bits
    173  11dc
    174  11dc		       68		      pla
    175  11dd		       4c c2 11 	      jmp	draw_sequence
    176  11e0
    177  11e0				   draw_sequence_end
    178  11e0		       60		      rts
    179  11e1
    180  11e1
    181  11e1							; put the character in the high 4 bits of accumulator on screen (see readme), and move the color and screen cursors ahead
    182  11e1				   draw_high_bits
    183  11e1		       29 f0		      and	#240	; shave off last 4 bits
    184  11e3
    185  11e3		       c9 00		      cmp	#BLANK_SPACE
    186  11e5		       d0 08		      bne	check_if_starting_point
    187  11e7		       a9 00		      lda	#BLANK_TILE_CHAR	; todo; replace with actual chars
    188  11e9		       a2 01		      ldx	#1
    189  11eb		       20 7f 12 	      jsr	draw_char_in_accumulator
    190  11ee		       60		      rts
    191  11ef
    192  11ef				   check_if_starting_point
    193  11ef		       c9 10		      cmp	#STARTING_POINT
    194  11f1		       d0 18		      bne	check_if_wall
    195  11f3
    196  11f3							; set squarebot to starting point
    197  11f3		       a5 00		      lda	screen_cursor
    198  11f5		       85 10		      sta	squarebot_position
    199  11f7		       a5 01		      lda	screen_cursor+1
    200  11f9		       85 11		      sta	squarebot_position+1
    201  11fb
    202  11fb		       a5 02		      lda	color_cursor
    203  11fd		       85 12		      sta	squarebot_color_position
    204  11ff		       a5 03		      lda	color_cursor+1
    205  1201		       85 13		      sta	squarebot_color_position+1
    206  1203
    207  1203		       a9 13		      lda	#SQUAREBOT_CHAR
    208  1205		       a2 02		      ldx	#SQUAREBOT_COLOR
    209  1207		       20 7f 12 	      jsr	draw_char_in_accumulator
    210  120a		       60		      rts
    211  120b
    212  120b				   check_if_wall
    213  120b		       c9 20		      cmp	#WALL
    214  120d		       d0 08		      bne	check_if_breakable_wall
    215  120f		       a9 03		      lda	#WALL_CHAR
    216  1211		       a2 00		      ldx	#WALL_COLOR
    217  1213		       20 7f 12 	      jsr	draw_char_in_accumulator
    218  1216		       60		      rts
    219  1217
    220  1217				   check_if_breakable_wall
    221  1217		       c9 30		      cmp	#BREAKABLE_WALL
    222  1219		       d0 08		      bne	check_if_locked_wall
    223  121b		       a9 07		      lda	#BREAKABLE_WALL_CHAR
    224  121d		       a2 00		      ldx	#BREAKABLE_WALL_COLOR
    225  121f		       20 7f 12 	      jsr	draw_char_in_accumulator
    226  1222		       60		      rts
    227  1223
    228  1223				   check_if_locked_wall
    229  1223		       c9 40		      cmp	#LOCKED_WALL
    230  1225		       d0 08		      bne	check_if_ladder
    231  1227		       a9 06		      lda	#LOCKED_WALL_CHAR
    232  1229		       a2 00		      ldx	#LOCKED_WALL_COLOR
    233  122b		       20 7f 12 	      jsr	draw_char_in_accumulator
    234  122e		       60		      rts
    235  122f
    236  122f				   check_if_ladder
    237  122f		       c9 50		      cmp	#LADDER
    238  1231		       d0 08		      bne	check_if_exit
    239  1233		       a9 01		      lda	#LADDER_CHAR
    240  1235		       a2 00		      ldx	#LADDER_COLOR
    241  1237		       20 7f 12 	      jsr	draw_char_in_accumulator
    242  123a		       60		      rts
    243  123b
    244  123b				   check_if_exit
    245  123b		       c9 60		      cmp	#EXIT
    246  123d		       d0 08		      bne	check_if_locked_exit
    247  123f		       a9 04		      lda	#EXIT_CHAR
    248  1241		       a2 00		      ldx	#EXIT_COLOR
    249  1243		       20 7f 12 	      jsr	draw_char_in_accumulator
    250  1246		       60		      rts
    251  1247
    252  1247				   check_if_locked_exit
    253  1247		       c9 b0		      cmp	#LOCKED_EXIT
    254  1249		       d0 08		      bne	check_if_platform
    255  124b		       a9 05		      lda	#LOCKED_EXIT_CHAR
    256  124d		       a2 00		      ldx	#LOCKED_EXIT_COLOR
    257  124f		       20 7f 12 	      jsr	draw_char_in_accumulator
    258  1252		       60		      rts
    259  1253
    260  1253				   check_if_platform
    261  1253		       c9 70		      cmp	#PLATFORM
    262  1255		       d0 08		      bne	check_if_key
    263  1257		       a9 02		      lda	#PLATFORM_CHAR
    264  1259		       a2 00		      ldx	#PLATFORM_COLOR
    265  125b		       20 7f 12 	      jsr	draw_char_in_accumulator
    266  125e		       60		      rts
    267  125f
    268  125f				   check_if_key
    269  125f		       c9 80		      cmp	#KEY
    270  1261		       d0 08		      bne	check_if_spike
    271  1263		       a9 0a		      lda	#KEY_P_CHAR
    272  1265		       a2 00		      ldx	#KEY_P_COLOR
    273  1267		       20 7f 12 	      jsr	draw_char_in_accumulator
    274  126a		       60		      rts
    275  126b
    276  126b				   check_if_spike
    277  126b		       c9 90		      cmp	#SPIKE
    278  126d		       d0 08		      bne	check_if_booster
    279  126f		       a9 08		      lda	#SPIKE_CHAR
    280  1271		       a2 00		      ldx	#SPIKE_COLOR
    281  1273		       20 7f 12 	      jsr	draw_char_in_accumulator
    282  1276		       60		      rts
    283  1277
    284  1277				   check_if_booster
    285  1277		       a9 09		      lda	#BOOSTER_P_CHAR
    286  1279		       a2 00		      ldx	#BOOSTER_P_COLOR
    287  127b		       20 7f 12 	      jsr	draw_char_in_accumulator
    288  127e		       60		      rts
    289  127f
    290  127f
    291  127f
    292  127f							; char in accumulator goes in screen cursor, color in x register goes in color cursor, then update cursors
    293  127f
    294  127f				   draw_char_in_accumulator
    295  127f		       a0 00		      ldy	#0
    296  1281		       91 00		      sta	(screen_cursor),y
    297  1283
    298  1283		       8a		      txa
    299  1284		       91 02		      sta	(color_cursor),y
    300  1286
    301  1286		       20 c6 10 	      jsr	add_one_to_screen_cursor	; add to both screen and color cursor
    302  1289		       20 8d 12 	      jsr	update_screen_position_if_on_border
    303  128c		       60		      rts
    304  128d
    305  128d
    306  128d
    307  128d				   update_screen_position_if_on_border
    308  128d		       a5 30		      lda	count_chars_drawn
    309  128f		       c9 13		      cmp	#19
    310  1291		       d0 0b		      bne	add_and_return
    311  1293		       a9 00		      lda	#0
    312  1295		       85 30		      sta	count_chars_drawn
    313  1297		       20 c6 10 	      jsr	add_one_to_screen_cursor
    314  129a		       20 c6 10 	      jsr	add_one_to_screen_cursor
    315  129d		       60		      rts
    316  129e
    317  129e
    318  129e				   add_and_return
    319  129e		       18		      clc
    320  129f		       69 01		      adc	#1
    321  12a1		       85 30		      sta	count_chars_drawn
    322  12a3		       60		      rts
    323  12a4
    324  12a4				   check_if_level_cursor_at_end 		; set carry flag if screen_cursor at position $1ff9 (8185
    325  12a4		       a5 00		      lda	screen_cursor	; load value at screen_cursor low byte
    326  12a6		       c9 e5		      cmp	#END_OF_LEVEL_LOW_BYTE
    327  12a8		       d0 06		      bne	check_if_level_cursor_at_end_return_false	; if low byte doesnt match, return with carry flag as neg
    328  12aa
    329  12aa		       a5 01		      lda	screen_cursor+1
    330  12ac		       c9 1f		      cmp	#END_OF_LEVEL_HIGH_BYTE
    331  12ae		       f0 02		      beq	check_if_level_cursor_at_end_return_true	; if high byte matches, set carry flag
    332  12b0
    333  12b0				   check_if_level_cursor_at_end_return_false
    334  12b0		       18		      clc
    335  12b1		       60		      rts
    336  12b2
    337  12b2				   check_if_level_cursor_at_end_return_true
    338  12b2		       38		      sec
    339  12b3		       60		      rts
------- FILE main.s
------- FILE sound.s LEVEL 2 PASS 3
      0  12b4					      include	"sound.s"
      1  12b4		       90 0d	   SN	      =	$900d	; noise channel (these memory addresses are in the reference manual)
      2  12b4		       90 0e	   SV	      =	$900e	; volume
      3  12b4		       00 a2	   JC	      =	$00a2	; jiffy clock
      4  12b4
      5  12b4		       00 d6	   STARTM     =	214	; initial pitch of move (must be between 129 and 255 ish, but you should already know that)
      6  12b4		       00 96	   STARTC     =	150	; initial pitch of move (must be between 129 and 255 ish, but you should already know that)
      7  12b4		       00 ff	   STARTG     =	255	; initial pitch of move (must be between 129 and 255 ish, but you should already know that)
      8  12b4
      9  12b4				   player_movement		; CALL THIS SUBROUTINE TO PLAY THE SOUND
     10  12b4		       a2 00		      ldx	#0
     11  12b6		       a0 d6		      ldy	#STARTM	; load the first pitch into the Y register
     12  12b8		       8c 0d 90 	      sty	SN	; write the note to the noise channel
     13  12bb				   player_movement_next
     14  12bb		       bd cd 12 	      lda	mov_velocities,X	; get the current note velocity
     15  12be		       8d 0e 90 	      sta	SV	; set speakers to volume in accumulator
     16  12c1							; check if we should exit on this note
     17  12c1		       f0 0e		      beq	exit_move	; if volume is 0, exit the main loop (this branches to an rts, essentially. my exit code is slightly more complicated)
     18  12c3							; we should not exit on this note
     19  12c3		       e8		      inx		; move on
     20  12c4							; set up the jiffy waiting loop
     21  12c4		       a4 a2		      ldy	JC	; load jiffy clock into Y register
     22  12c6		       c8		      iny		; Y register now stores the desired end time (one jiffy away)
     23  12c7							; wait one jiffy
     24  12c7				   jiffyM
     25  12c7		       c4 a2		      cpy	JC
     26  12c9		       d0 fc		      bne	jiffyM
     27  12cb							; move on to the next velocity value
     28  12cb		       f0 ee		      beq	player_movement_next	; restart main loop
     29  12cd
     30  12cd							; you can define the velocities here, it moves on to the next velocity after it waits a jiffy. a velocity of 0 is the delimiter (i.e. it exits when it hits 0)
     31  12cd				   mov_velocities
     32  12cd		       03 06 03 00	      dc	3, 6, 3, 0	;sound duration
     33  12d1
     34  12d1				   exit_move
     35  12d1		       60		      rts
------- FILE main.s
------- FILE updateGameState_new.s LEVEL 2 PASS 3
      0  12d2					      include	"updateGameState_new.s"
      1  12d2		       00 e4	   START_OF_FIRST_ROW_LOW_BYTE =	$e4
      2  12d2		       00 1f	   START_OF_FIRST_ROW_HIGH_BYTE =	$1f
      3  12d2
      4  12d2							; main logic until line 113:
      5  12d2				   update_game_state
      6  12d2		       a5 10		      lda	squarebot_position	; likely unnecessary
      7  12d4		       85 0b		      sta	new_position
      8  12d6		       a5 11		      lda	squarebot_position+1
      9  12d8		       85 0c		      sta	new_position+1
     10  12da		       a5 12		      lda	squarebot_color_position
     11  12dc		       85 0d		      sta	new_color_position
     12  12de		       a5 13		      lda	squarebot_color_position+1
     13  12e0		       85 0e		      sta	new_color_position+1
     14  12e2
     15  12e2				   jump_logic
     16  12e2		       a5 15		      lda	jump_num
     17  12e4		       c9 00		      cmp	#$00
     18  12e6		       f0 31		      beq	fall_logic
     19  12e8		       a2 00		      ldx	#0	; up
     20  12ea		       20 cf 13 	      jsr	move_dir
     21  12ed		       b0 07		      bcs	j_cont	; jump successful
     22  12ef		       a9 00		      lda	#$00	; jump failed
     23  12f1		       85 15		      sta	jump_num
     24  12f3		       4c 53 13 	      jmp	update_return
     25  12f6				   j_cont
     26  12f6		       38		      sec
     27  12f7		       c6 15		      dec	jump_num
     28  12f9				   j_left
     29  12f9		       a5 14		      lda	jump_dir
     30  12fb		       c9 01		      cmp	#$01
     31  12fd		       d0 0b		      bne	j_right
     32  12ff		       20 12 11 	      jsr	wait_until_next_frame
     33  1302		       a2 02		      ldx	#2	; left
     34  1304		       20 cf 13 	      jsr	move_dir
     35  1307		       4c 53 13 	      jmp	update_return
     36  130a				   j_right
     37  130a		       c9 02		      cmp	#$02
     38  130c		       d0 45		      bne	update_return
     39  130e		       20 12 11 	      jsr	wait_until_next_frame
     40  1311		       a2 03		      ldx	#3	; right
     41  1313		       20 cf 13 	      jsr	move_dir
     42  1316		       4c 53 13 	      jmp	update_return
     43  1319
     44  1319				   fall_logic
     45  1319		       a5 17		      lda	tile_store+1	; down
     46  131b		       20 79 14 	      jsr	fall_check	; check if we hit the ground, different from collision_handler since platforms are included
     47  131e		       90 3f		      bcc	check_if_w_pressed
     48  1320		       a2 01		      ldx	#1	; down
     49  1322		       20 cf 13 	      jsr	move_dir
     50  1325		       a5 17		      lda	tile_store+1	; check if we hit ground again, if we didn't we can move in the jump_dir
     51  1327		       20 79 14 	      jsr	fall_check
     52  132a		       b0 07		      bcs	f_left
     53  132c		       a9 00		      lda	#$00	; otherwise we stay still
     54  132e		       85 14		      sta	jump_dir
     55  1330		       4c 53 13 	      jmp	update_return
     56  1333				   f_left
     57  1333		       a5 14		      lda	jump_dir
     58  1335		       c9 01		      cmp	#$01
     59  1337		       d0 0b		      bne	f_right
     60  1339		       20 12 11 	      jsr	wait_until_next_frame
     61  133c		       a2 02		      ldx	#2	; left
     62  133e		       20 cf 13 	      jsr	move_dir
     63  1341		       4c 53 13 	      jmp	update_return
     64  1344				   f_right
     65  1344		       c9 02		      cmp	#$02
     66  1346		       d0 0b		      bne	update_return
     67  1348		       20 12 11 	      jsr	wait_until_next_frame
     68  134b		       a2 03		      ldx	#3	; right
     69  134d		       20 cf 13 	      jsr	move_dir
     70  1350		       4c 53 13 	      jmp	update_return
     71  1353
     72  1353				   update_return
     73  1353		       18		      clc		; reset numbers that should be
     74  1354		       a9 00		      lda	#0
     75  1356		       85 28		      sta	temp
     76  1358		       85 29		      sta	temp+1
     77  135a		       85 2a		      sta	temp+2
     78  135c		       85 2b		      sta	temp+3
     79  135e		       60		      rts
     80  135f
     81  135f				   check_if_w_pressed
     82  135f		       a9 00		      lda	#$00
     83  1361		       85 14		      sta	jump_dir	; double check we aren't falling in a direction
     84  1363		       a5 c5		      lda	currently_pressed_key
     85  1365		       c9 09		      cmp	#W_KEY
     86  1367		       d0 12		      bne	check_if_q_pressed
     87  1369		       a2 00		      ldx	#0	; up
     88  136b		       20 cf 13 	      jsr	move_dir
     89  136e		       90 e3		      bcc	update_return	; jump failed
     90  1370		       a9 01		      lda	#JUMP_SIZE
     91  1372		       85 15		      sta	jump_num
     92  1374		       a9 00		      lda	#$00
     93  1376		       85 14		      sta	jump_dir
     94  1378		       4c 53 13 	      jmp	update_return
     95  137b
     96  137b				   check_if_q_pressed
     97  137b		       c9 30		      cmp	#Q_KEY
     98  137d		       d0 1a		      bne	check_if_e_pressed
     99  137f		       a2 00		      ldx	#0	; up
    100  1381		       20 cf 13 	      jsr	move_dir
    101  1384		       90 cd		      bcc	update_return	; jump failed
    102  1386		       a9 01		      lda	#JUMP_SIZE
    103  1388		       85 15		      sta	jump_num
    104  138a		       a9 01		      lda	#$01
    105  138c		       85 14		      sta	jump_dir
    106  138e		       20 12 11 	      jsr	wait_until_next_frame
    107  1391		       a2 02		      ldx	#2	; left
    108  1393		       20 cf 13 	      jsr	move_dir
    109  1396		       4c 53 13 	      jmp	update_return
    110  1399
    111  1399				   check_if_e_pressed
    112  1399		       c9 31		      cmp	#E_KEY
    113  139b		       d0 1a		      bne	check_if_a_pressed
    114  139d		       a2 00		      ldx	#0	; up
    115  139f		       20 cf 13 	      jsr	move_dir
    116  13a2		       90 af		      bcc	update_return	; jump failed
    117  13a4		       a9 01		      lda	#JUMP_SIZE
    118  13a6		       85 15		      sta	jump_num
    119  13a8		       a9 02		      lda	#$02
    120  13aa		       85 14		      sta	jump_dir
    121  13ac		       20 12 11 	      jsr	wait_until_next_frame
    122  13af		       a2 03		      ldx	#3	; right
    123  13b1		       20 cf 13 	      jsr	move_dir
    124  13b4		       4c 53 13 	      jmp	update_return
    125  13b7
    126  13b7				   check_if_a_pressed
    127  13b7		       c9 11		      cmp	#A_KEY
    128  13b9		       d0 08		      bne	check_if_d_pressed
    129  13bb		       a2 02		      ldx	#2	; left
    130  13bd		       20 cf 13 	      jsr	move_dir
    131  13c0		       4c 53 13 	      jmp	update_return
    132  13c3
    133  13c3				   check_if_d_pressed
    134  13c3		       c9 12		      cmp	#D_KEY
    135  13c5		       d0 8c		      bne	update_return
    136  13c7		       a2 03		      ldx	#3	; right
    137  13c9		       20 cf 13 	      jsr	move_dir
    138  13cc		       4c 53 13 	      jmp	update_return
    139  13cf
    140  13cf							; The rest is subroutines
    141  13cf
    142  13cf							;current bugs:
    143  13cf							;attached powerup sprites are not working
    144  13cf							;jump direction is not reset properly
    145  13cf							;platforms get deleted sometimes
    146  13cf							;need to replace end screen
    147  13cf
    148  13cf
    149  13cf
    150  13cf							;store tile you are moving to
    151  13cf							;if you win, win
    152  13cf							;check collision:
    153  13cf							;  store powerup in temp
    154  13cf							;  return whether you can move or not
    155  13cf							;if you can't move, return false
    156  13cf							;apply powerups you moved into
    157  13cf							;get new position
    158  13cf							;refresh tiles
    159  13cf							;apply powerup logic
    160  13cf							;delete old position
    161  13cf							;update position
    162  13cf							;redraw chars
    163  13cf							;draw new position
    164  13cf							;wait a jiffy maybe
    165  13cf							;check booster if we move again
    166  13cf				   move_dir
    167  13cf		       86 2c		      stx	move_dir_store
    168  13d1		       a9 00		      lda	#$00
    169  13d3		       85 28		      sta	temp
    170  13d5		       b5 16		      lda	tile_store_addr,x	; load colliding tile
    171  13d7		       c9 04		      cmp	#EXIT_CHAR
    172  13d9		       d0 09		      bne	spike_check
    173  13db		       a9 01		      lda	#1	; level complete
    174  13dd		       85 09		      sta	level_completed
    175  13df		       85 08		      sta	level_reset
    176  13e1		       4c 41 14 	      jmp	return_false_move
    177  13e4				   spike_check
    178  13e4		       c9 08		      cmp	#SPIKE_CHAR
    179  13e6		       d0 07		      bne	cont_move
    180  13e8		       a9 01		      lda	#1
    181  13ea		       85 08		      sta	level_reset	; died
    182  13ec		       4c 41 14 	      jmp	return_false_move
    183  13ef				   cont_move
    184  13ef		       20 43 14 	      jsr	collision_handler
    185  13f2		       90 4d		      bcc	return_false_move
    186  13f4		       a5 28		      lda	temp	; if we hit a powerup this will be its id
    187  13f6		       c9 00		      cmp	#$00
    188  13f8		       f0 06		      beq	post_powerup_move
    189  13fa		       95 1b		      sta	attached_powerups_addr,x	; attach powerup
    190  13fc		       a9 00		      lda	#$00
    191  13fe		       95 16		      sta	tile_store_addr,x	; remove the powerup tile from the level
    192  1400				   post_powerup_move
    193  1400		       20 94 14 	      jsr	delete_squarebot
    194  1403		       a6 2c		      ldx	move_dir_store
    195  1405		       20 ac 14 	      jsr	move_new_position
    196  1408		       20 cb 14 	      jsr	get_tiles
    197  140b		       a9 01		      lda	#$01	; eor y with 1 to get opposite side
    198  140d		       45 2c		      eor	move_dir_store
    199  140f		       aa		      tax
    200  1410		       b5 1b		      lda	attached_powerups_addr,x	; ignite ready booster
    201  1412		       c9 14		      cmp	#RBOOSTER_A_CHAR
    202  1414		       d0 04		      bne	post_booster
    203  1416		       a9 01		      lda	#$01	; ignited booster is a ladder because its not shown
    204  1418		       95 1b		      sta	attached_powerups_addr,x
    205  141a				   post_booster
    206  141a		       20 00 15 	      jsr	apply_powerup_logic
    207  141d		       20 9c 15 	      jsr	update_squarebot
    208  1420		       20 ad 15 	      jsr	update_chars
    209  1423		       20 09 16 	      jsr	draw_squarebot
    210  1426		       20 12 11 	      jsr	wait_until_next_frame
    211  1429		       a9 01		      lda	#$01	; eor y with 1 to get opposite side
    212  142b		       45 2c		      eor	move_dir_store
    213  142d		       aa		      tax
    214  142e		       b5 1b		      lda	attached_powerups_addr,x
    215  1430		       c9 18		      cmp	#ABOOSTER_A_CHAR
    216  1432		       d0 0b		      bne	return_true_move	; if booster activated go again
    217  1434		       20 12 11 	      jsr	wait_until_next_frame	; give them time to see active booster
    218  1437		       20 12 11 	      jsr	wait_until_next_frame
    219  143a		       a6 2c		      ldx	move_dir_store
    220  143c		       4c cf 13 	      jmp	move_dir
    221  143f				   return_true_move
    222  143f		       38		      sec
    223  1440		       60		      rts		; return true move
    224  1441				   return_false_move
    225  1441		       18		      clc
    226  1442		       60		      rts
    227  1443
    228  1443							;-----
    229  1443				   collision_handler		; accumulator is the character in the position that squarebot wants to move to
    230  1443							; set carry flag if we can move to this char, otherwise clear it
    231  1443							; if its a powerup, set temp to be the attached_powerup id + attached_powerup id <<4, otherwise return since temp is already 0
    232  1443		       c9 00		      cmp	#BLANK_TILE_CHAR
    233  1445		       f0 2e		      beq	return_true
    234  1447		       c9 02		      cmp	#PLATFORM_CHAR
    235  1449		       f0 2a		      beq	return_true	; moving down will double check anyway
    236  144b		       c9 01		      cmp	#LADDER_CHAR
    237  144d		       f0 26		      beq	return_true	; not fully implemented though
    238  144f		       c9 03		      cmp	#WALL_CHAR
    239  1451		       f0 24		      beq	return_false
    240  1453		       c9 07		      cmp	#BREAKABLE_WALL_CHAR
    241  1455		       f0 20		      beq	return_false
    242  1457		       c9 05		      cmp	#LOCKED_EXIT_CHAR
    243  1459		       f0 1c		      beq	return_false
    244  145b		       c9 06		      cmp	#LOCKED_WALL_CHAR
    245  145d		       f0 18		      beq	return_false
    246  145f							;else its a powerup
    247  145f		       c9 09		      cmp	#BOOSTER_P_CHAR
    248  1461		       d0 07		      bne	rpk
    249  1463		       a9 14		      lda	#RBOOSTER_A_CHAR
    250  1465		       85 28		      sta	temp
    251  1467		       4c 75 14 	      jmp	return_true
    252  146a				   rpk
    253  146a		       c9 0a		      cmp	#KEY_P_CHAR
    254  146c		       d0 09		      bne	return_false
    255  146e		       a9 1c		      lda	#KEY_A_CHAR
    256  1470		       85 28		      sta	temp
    257  1472		       4c 75 14 	      jmp	return_true
    258  1475
    259  1475				   return_true
    260  1475		       38		      sec
    261  1476		       60		      rts
    262  1477
    263  1477				   return_false
    264  1477		       18		      clc
    265  1478		       60		      rts
    266  1479
    267  1479							;-----
    268  1479				   fall_check
    269  1479		       c9 02		      cmp	#PLATFORM_CHAR
    270  147b		       f0 fa		      beq	return_false
    271  147d		       c9 03		      cmp	#WALL_CHAR
    272  147f		       f0 f6		      beq	return_false
    273  1481		       c9 05		      cmp	#LOCKED_EXIT_CHAR
    274  1483		       f0 f2		      beq	return_false
    275  1485		       c9 06		      cmp	#LOCKED_WALL_CHAR
    276  1487		       f0 ee		      beq	return_false
    277  1489		       c9 07		      cmp	#BREAKABLE_WALL_CHAR
    278  148b		       f0 ea		      beq	return_false
    279  148d		       c9 01		      cmp	#LADDER_CHAR
    280  148f		       f0 e6		      beq	return_false
    281  1491		       4c 75 14 	      jmp	return_true	;
    282  1494
    283  1494							;-----
    284  1494				   delete_squarebot
    285  1494		       20 42 16 	      jsr	get_squarebot_draw_position
    286  1497		       a2 00		      ldx	#$0
    287  1499
    288  1499				   delete_loop
    289  1499		       b4 1f		      ldy	delta_addr,x
    290  149b		       b5 16		      lda	tile_store_addr,X
    291  149d		       91 10		      sta	(squarebot_position),y
    292  149f		       a9 00		      lda	#0	; EVERYTHING IS BLACK
    293  14a1		       91 12		      sta	(squarebot_color_position),y
    294  14a3
    295  14a3		       e8		      inx
    296  14a4		       e0 05		      cpx	#5
    297  14a6		       d0 f1		      bne	delete_loop
    298  14a8
    299  14a8		       20 5d 16 	      jsr	get_squarebot_game_position
    300  14ab		       60		      rts
    301  14ac
    302  14ac							;-----
    303  14ac				   move_new_position
    304  14ac		       20 78 16 	      jsr	get_new_draw_position
    305  14af
    306  14af		       18		      clc
    307  14b0		       a5 0b		      lda	new_position
    308  14b2		       75 1f		      adc	delta_addr,x	; x is the index of the move_dir
    309  14b4		       85 0b		      sta	new_position
    310  14b6		       a5 0c		      lda	new_position+1
    311  14b8		       69 00		      adc	#0
    312  14ba		       85 0c		      sta	new_position+1
    313  14bc		       18		      clc
    314  14bd		       a5 0d		      lda	new_color_position
    315  14bf		       75 1f		      adc	delta_addr,x
    316  14c1		       85 0d		      sta	new_color_position
    317  14c3		       a5 0e		      lda	new_color_position+1
    318  14c5		       69 00		      adc	#0
    319  14c7		       85 0e		      sta	new_color_position+1
    320  14c9		       18		      clc
    321  14ca		       60		      rts		; no need to undo get_new_draw_position
    322  14cb
    323  14cb							;-----
    324  14cb				   get_tiles
    325  14cb		       20 78 16 	      jsr	get_new_draw_position
    326  14ce
    327  14ce		       a9 01		      lda	#$01	; eor move_dir with 1 to get opposite side
    328  14d0		       45 2c		      eor	move_dir_store
    329  14d2		       aa		      tax
    330  14d3		       a5 1a		      lda	tile_store+4	; get mid
    331  14d5		       95 16		      sta	tile_store_addr,x	; set opposite dir
    332  14d7
    333  14d7		       a6 2c		      ldx	move_dir_store
    334  14d9		       b5 16		      lda	tile_store_addr,x	;get dir
    335  14db		       85 1a		      sta	tile_store+4	; set mid
    336  14dd
    337  14dd		       b5 1f		      lda	delta_addr,x
    338  14df		       a8		      tay
    339  14e0		       b1 0b		      lda	(new_position),y	; get tile_dir
    340  14e2		       95 16		      sta	tile_store_addr,x	; set tile_dir
    341  14e4
    342  14e4		       a9 02		      lda	#$02	; get perpendicular tiles
    343  14e6		       45 2c		      eor	move_dir_store
    344  14e8		       aa		      tax		; eor move_dir with 2 to get perpendicular directions
    345  14e9		       b5 1f		      lda	delta_addr,x
    346  14eb		       a8		      tay
    347  14ec		       b1 0b		      lda	(new_position),y
    348  14ee		       95 16		      sta	tile_store_addr,x
    349  14f0
    350  14f0		       a9 03		      lda	#$03
    351  14f2		       45 2c		      eor	move_dir_store
    352  14f4		       aa		      tax
    353  14f5		       b5 1f		      lda	delta_addr,x
    354  14f7		       a8		      tay
    355  14f8		       b1 0b		      lda	(new_position),y
    356  14fa		       95 16		      sta	tile_store_addr,x
    357  14fc
    358  14fc		       20 93 16 	      jsr	get_new_game_position
    359  14ff		       60		      rts
    360  1500
    361  1500							;-----
    362  1500				   apply_powerup_logic
    363  1500							;call prepare_logic for index temp+3 = 0,1,2, and 3. store index in temp+3 since we change y often
    364  1500		       a9 00		      lda	#$0
    365  1502		       85 2b		      sta	temp+3
    366  1504		       aa		      tax
    367  1505		       20 23 15 	      jsr	prepare_logic
    368  1508		       e6 2b		      inc	temp+3
    369  150a		       20 23 15 	      jsr	prepare_logic
    370  150d		       e6 2b		      inc	temp+3
    371  150f		       20 23 15 	      jsr	prepare_logic
    372  1512		       e6 2b		      inc	temp+3
    373  1514		       20 23 15 	      jsr	prepare_logic
    374  1517		       a9 00		      lda	#$0
    375  1519		       85 28		      sta	temp
    376  151b		       85 29		      sta	temp+1
    377  151d		       85 2a		      sta	temp+2
    378  151f		       85 2b		      sta	temp+3
    379  1521		       aa		      tax		; clean up just to be safe
    380  1522		       60		      rts
    381  1523
    382  1523							;temp = powerup,   temp+1 = tile behind powerup,   temp+2 = tile opposite powerup
    383  1523				   prepare_logic
    384  1523		       a6 2b		      ldx	temp+3
    385  1525		       b5 1b		      lda	attached_powerups_addr,x
    386  1527		       85 28		      sta	temp
    387  1529		       b5 16		      lda	tile_store_addr,x
    388  152b		       85 29		      sta	temp+1
    389  152d		       a9 01		      lda	#$01
    390  152f		       45 2b		      eor	temp+3
    391  1531		       aa		      tax		; eor with 1 which gets us the tile opposite the powerup
    392  1532		       b5 16		      lda	tile_store_addr,x
    393  1534		       85 2a		      sta	temp+2
    394  1536		       20 4d 15 	      jsr	powerup_logic	; perform logic
    395  1539		       a6 2b		      ldx	temp+3
    396  153b		       a5 28		      lda	temp
    397  153d		       95 1b		      sta	attached_powerups_addr,x
    398  153f		       a5 29		      lda	temp+1
    399  1541		       95 16		      sta	tile_store_addr,x
    400  1543		       a9 01		      lda	#$01
    401  1545		       45 2b		      eor	temp+3
    402  1547		       aa		      tax
    403  1548		       a5 2a		      lda	temp+2
    404  154a		       95 16		      sta	tile_store_addr,x
    405  154c		       60		      rts
    406  154d
    407  154d							; ready booster: does nothing
    408  154d							; ignited booster: breaks breakable walls and changes to active booster 
    409  154d							; active booster: breaks breakable walls and changes to ready booster
    410  154d							; key: spends itself to break locked walls
    411  154d				   powerup_logic		;temp = powerup,   temp+1 = tile behind powerup,   temp+2 = tile opposite powerup
    412  154d		       a5 28		      lda	temp
    413  154f		       c9 01		      cmp	#$01	; check ignited booster
    414  1551		       d0 11		      bne	pl_b
    415  1553		       a5 2a		      lda	temp+2	; check opposite tile
    416  1555		       c9 07		      cmp	#BREAKABLE_WALL_CHAR
    417  1557		       d0 04		      bne	pl_ab
    418  1559		       a9 00		      lda	#BLANK_TILE_CHAR
    419  155b		       85 2a		      sta	temp+2	; delete wall
    420  155d				   pl_ab
    421  155d		       a9 18		      lda	#ABOOSTER_A_CHAR	; set active booster
    422  155f		       85 28		      sta	temp
    423  1561		       4c 9b 15 	      jmp	pl_return
    424  1564				   pl_b
    425  1564		       c9 18		      cmp	#ABOOSTER_A_CHAR	; check active booster
    426  1566		       d0 11		      bne	pl_k
    427  1568		       a5 2a		      lda	temp+2	; check opposite tile
    428  156a		       c9 07		      cmp	#BREAKABLE_WALL_CHAR
    429  156c		       d0 04		      bne	pl_rb
    430  156e		       a9 00		      lda	#BLANK_TILE_CHAR
    431  1570		       85 2a		      sta	temp+2	; delete wall
    432  1572				   pl_rb
    433  1572		       a9 14		      lda	#RBOOSTER_A_CHAR	; set ready booster
    434  1574		       85 28		      sta	temp
    435  1576		       4c 9b 15 	      jmp	pl_return
    436  1579				   pl_k
    437  1579		       c9 1c		      cmp	#KEY_A_CHAR	; check key, slightly unnecessary
    438  157b		       d0 1e		      bne	pl_return
    439  157d		       a5 29		      lda	temp+1
    440  157f		       c9 06		      cmp	#LOCKED_WALL_CHAR
    441  1581		       d0 09		      bne	pl_ke
    442  1583		       a9 00		      lda	#BLANK_TILE_CHAR
    443  1585		       85 28		      sta	temp	; delete key
    444  1587		       85 29		      sta	temp+1	; delete wall
    445  1589		       4c 9b 15 	      jmp	pl_return
    446  158c				   pl_ke
    447  158c		       c9 05		      cmp	#LOCKED_EXIT_CHAR
    448  158e		       d0 0b		      bne	pl_return
    449  1590		       a9 00		      lda	#BLANK_TILE_CHAR
    450  1592		       85 28		      sta	temp
    451  1594		       a9 04		      lda	#EXIT_CHAR
    452  1596		       85 29		      sta	temp+1
    453  1598		       4c 9b 15 	      jmp	pl_return
    454  159b				   pl_return
    455  159b		       60		      rts
    456  159c
    457  159c							;-----
    458  159c				   update_squarebot
    459  159c		       a5 0b		      lda	new_position
    460  159e		       85 10		      sta	squarebot_position
    461  15a0		       a5 0c		      lda	new_position+1
    462  15a2		       85 11		      sta	squarebot_position+1
    463  15a4
    464  15a4		       a5 0d		      lda	new_color_position
    465  15a6		       85 12		      sta	squarebot_color_position
    466  15a8		       a5 0e		      lda	new_color_position+1
    467  15aa		       85 13		      sta	squarebot_color_position+1
    468  15ac		       60		      rts
    469  15ad
    470  15ad							;-----
    471  15ad				   update_chars 		; chareor = tile*8,   chareor+1 = powerup*8,	chareor+2 = char*8
    472  15ad		       a2 00		      ldx	#$00
    473  15af		       86 28		      stx	temp
    474  15b1
    475  15b1				   update_char_dir_loop
    476  15b1		       b5 16		      lda	tile_store_addr,x
    477  15b3		       0a		      asl
    478  15b4		       0a		      asl
    479  15b5		       0a		      asl		; multiply by 8 since there are 8 bytes per character
    480  15b6		       85 2d		      sta	chareor
    481  15b8		       b5 24		      lda	chars_addr,x
    482  15ba		       0a		      asl
    483  15bb		       0a		      asl
    484  15bc		       0a		      asl
    485  15bd		       85 2f		      sta	chareor+2
    486  15bf		       b5 1b		      lda	attached_powerups_addr,x
    487  15c1		       c9 00		      cmp	#$00
    488  15c3		       f0 03		      beq	no_powerup
    489  15c5		       18		      clc		;add index for rotation 
    490  15c6		       65 28		      adc	temp
    491  15c8				   no_powerup
    492  15c8		       0a		      asl
    493  15c9		       0a		      asl
    494  15ca		       0a		      asl
    495  15cb		       85 2e		      sta	chareor+1
    496  15cd		       20 d9 15 	      jsr	update_char
    497  15d0		       e6 28		      inc	temp
    498  15d2		       a6 28		      ldx	temp
    499  15d4
    500  15d4		       e0 04		      cpx	#4
    501  15d6		       d0 d9		      bne	update_char_dir_loop
    502  15d8
    503  15d8		       60		      rts
    504  15d9
    505  15d9				   update_char		; chareor = tile*8,   chareor+1 = powerup*8,	chareor+2 = char*8
    506  15d9		       a9 00		      lda	#$00
    507  15db		       85 29		      sta	temp+1
    508  15dd				   update_char_loop
    509  15dd		       a5 29		      lda	temp+1
    510  15df		       18		      clc
    511  15e0		       65 2d		      adc	chareor
    512  15e2		       a8		      tay
    513  15e3		       b9 00 1c 	      lda	character_set_begin,y
    514  15e6		       85 2a		      sta	temp+2
    515  15e8
    516  15e8		       a5 29		      lda	temp+1
    517  15ea		       18		      clc
    518  15eb		       65 2e		      adc	chareor+1
    519  15ed		       a8		      tay
    520  15ee		       b9 00 1c 	      lda	character_set_begin,y
    521  15f1		       45 2a		      eor	temp+2
    522  15f3		       85 2a		      sta	temp+2
    523  15f5
    524  15f5		       a5 29		      lda	temp+1
    525  15f7		       18		      clc
    526  15f8		       65 2f		      adc	chareor+2
    527  15fa		       a8		      tay
    528  15fb		       a5 2a		      lda	temp+2
    529  15fd		       99 00 1c 	      sta	character_set_begin,y
    530  1600
    531  1600		       e6 29		      inc	temp+1
    532  1602		       a5 29		      lda	temp+1
    533  1604		       c9 08		      cmp	#8
    534  1606		       d0 d5		      bne	update_char_loop
    535  1608
    536  1608		       60		      rts
    537  1609
    538  1609							; if there is a powerup:
    539  1609							; for each of 8 bytes:
    540  1609							; load tile byte
    541  1609							; eor with powerup tile byte
    542  1609							; store in char byte
    543  1609
    544  1609							;-----
    545  1609				   draw_squarebot
    546  1609		       20 42 16 	      jsr	get_squarebot_draw_position
    547  160c
    548  160c		       a5 24		      lda	chars	;u
    549  160e		       a4 1f		      ldy	delta
    550  1610		       91 10		      sta	(squarebot_position),y
    551  1612		       a9 00		      lda	#0
    552  1614		       91 12		      sta	(squarebot_color_position),y
    553  1616
    554  1616		       a5 25		      lda	chars+1
    555  1618		       a4 20		      ldy	delta+1	;d
    556  161a		       91 10		      sta	(squarebot_position),y
    557  161c		       a9 00		      lda	#0
    558  161e		       91 12		      sta	(squarebot_color_position),y
    559  1620
    560  1620		       a5 26		      lda	chars+2
    561  1622		       a4 21		      ldy	delta+2	;l
    562  1624		       91 10		      sta	(squarebot_position),y
    563  1626		       a9 00		      lda	#0
    564  1628		       91 12		      sta	(squarebot_color_position),y
    565  162a
    566  162a		       a5 27		      lda	chars+3
    567  162c		       a4 22		      ldy	delta+3	;r
    568  162e		       91 10		      sta	(squarebot_position),y
    569  1630		       a9 00		      lda	#0
    570  1632		       91 12		      sta	(squarebot_color_position),y
    571  1634
    572  1634		       a9 13		      lda	#SQUAREBOT_CHAR
    573  1636		       a4 23		      ldy	delta+4	;m
    574  1638		       91 10		      sta	(squarebot_position),y
    575  163a		       a9 02		      lda	#SQUAREBOT_COLOR
    576  163c		       91 12		      sta	(squarebot_color_position),y
    577  163e
    578  163e		       20 5d 16 	      jsr	get_squarebot_game_position
    579  1641		       60		      rts
------- FILE main.s
------- FILE updateGameStateHelper.s LEVEL 2 PASS 3
      0  1642					      include	"updateGameStateHelper.s"
      1  1642							; Helper functions for updateGameState
      2  1642
      3  1642				   get_squarebot_draw_position
      4  1642		       38		      sec
      5  1643		       a5 10		      lda	squarebot_position
      6  1645		       e9 17		      sbc	#[ROW_SIZE+1]
      7  1647		       85 10		      sta	squarebot_position
      8  1649		       a5 11		      lda	squarebot_position+1
      9  164b		       e9 00		      sbc	#0
     10  164d		       85 11		      sta	squarebot_position+1
     11  164f		       38		      sec
     12  1650		       a5 12		      lda	squarebot_color_position
     13  1652		       e9 17		      sbc	#[ROW_SIZE+1]
     14  1654		       85 12		      sta	squarebot_color_position
     15  1656		       a5 13		      lda	squarebot_color_position+1
     16  1658		       e9 00		      sbc	#0
     17  165a		       85 13		      sta	squarebot_color_position+1
     18  165c		       60		      rts
     19  165d
     20  165d				   get_squarebot_game_position
     21  165d		       18		      clc
     22  165e		       a5 10		      lda	squarebot_position
     23  1660		       69 17		      adc	#[ROW_SIZE+1]
     24  1662		       85 10		      sta	squarebot_position
     25  1664		       a5 11		      lda	squarebot_position+1
     26  1666		       69 00		      adc	#0
     27  1668		       85 11		      sta	squarebot_position+1
     28  166a		       18		      clc
     29  166b		       a5 12		      lda	squarebot_color_position
     30  166d		       69 17		      adc	#[ROW_SIZE+1]
     31  166f		       85 12		      sta	squarebot_color_position
     32  1671		       a5 13		      lda	squarebot_color_position+1
     33  1673		       69 00		      adc	#0
     34  1675		       85 13		      sta	squarebot_color_position+1
     35  1677		       60		      rts
     36  1678
     37  1678				   get_new_draw_position
     38  1678		       38		      sec
     39  1679		       a5 0b		      lda	new_position
     40  167b		       e9 17		      sbc	#[ROW_SIZE+1]
     41  167d		       85 0b		      sta	new_position
     42  167f		       a5 0c		      lda	new_position+1
     43  1681		       e9 00		      sbc	#0
     44  1683		       85 0c		      sta	new_position+1
     45  1685		       38		      sec
     46  1686		       a5 0d		      lda	new_color_position
     47  1688		       e9 17		      sbc	#[ROW_SIZE+1]
     48  168a		       85 0d		      sta	new_color_position
     49  168c		       a5 0e		      lda	new_color_position+1
     50  168e		       e9 00		      sbc	#0
     51  1690		       85 0e		      sta	new_color_position+1
     52  1692		       60		      rts
     53  1693
     54  1693				   get_new_game_position
     55  1693		       18		      clc
     56  1694		       a5 0b		      lda	new_position
     57  1696		       69 17		      adc	#[ROW_SIZE+1]
     58  1698		       85 0b		      sta	new_position
     59  169a		       a5 0c		      lda	new_position+1
     60  169c		       69 00		      adc	#0
     61  169e		       85 0c		      sta	new_position+1
     62  16a0		       18		      clc
     63  16a1		       a5 0d		      lda	new_color_position
     64  16a3		       69 17		      adc	#[ROW_SIZE+1]
     65  16a5		       85 0d		      sta	new_color_position
     66  16a7		       a5 0e		      lda	new_color_position+1
     67  16a9		       69 00		      adc	#0
     68  16ab		       85 0e		      sta	new_color_position+1
     69  16ad		       60		      rts
------- FILE main.s
    185  16ae
    186  16ae				   compressed_screen_data_start
    187  16ae					      incbin	"../data/titleScreenData_compressed"
    188  175e
    189  175e				   level_data_start
    190  175e							; tutorial levels -- introduce mechanics one by one
    191  175e					      incbin	"../data/levels/binary_levels/jesse_1"
    192  1768					      incbin	"../data/levels/binary_levels/jesse_2"
    193  1780					      incbin	"../data/levels/binary_levels/jesse_3"
    194  17c4					      incbin	"../data/levels/binary_levels/amin_1"
    195  17e8					      incbin	"../data/levels/binary_levels/amin_2"
    196  181a					      incbin	"../data/levels/binary_levels/amin_3"
    197  1854					      incbin	"../data/levels/binary_levels/amin_4"
    198  1880
    199  1880
    200  1880					      incbin	"../data/levels/binary_levels/amin_5"
    201  18be					      incbin	"../data/levels/binary_levels/jesse_4"
    202  1904					      incbin	"../data/levels/binary_levels/jesse_5"
    203  1958					      incbin	"../data/levels/binary_levels/jesse_6"
    204  19ca					      incbin	"../data/levels/binary_levels/jesse_7"
    205  1a26					      incbin	"../data/levels/binary_levels/end_screen"
    206  1abe
    207  1abe
    208  1abe
------- FILE memoryCheck.s LEVEL 2 PASS 3
      0  1abe					      include	"memoryCheck.s"	; code to make sure the program isn't too large and enters screen memory
      1  1abe		       0a bd	   BYTES_USED =	.-$1001	; location counter minus starting location = total bytes used
      2  1abe		       1e 00	   SCREEN_MEMORY_START =	$1e00
 2749 bytes used
      3  1abe					      echo	[BYTES_USED]d, "bytes used"
 Ending program at memory location (base 10):  6846
      4  1abe					      echo	"Ending program at memory location (base 10): ", [.]d
      5  1abe				  -	      if	. >= SCREEN_MEMORY_START	; if program entering screen memory
      6  1abe				  -	      echo	"Throwing error because program is too large, and has entered screen memory!"
      7  1abe				  -	      err
      8  1abe					      endif
------- FILE main.s
    210  1abe
    211  1abe
    212  1abe							; byte 2469
    213  1abe							;copy paste script: python generateLevelBinary.py ascii_levels/<> binary_levels/<>
    214  1abe
    215  1c00					      org	character_set_begin	; starts at byte 3079 i think
    216  1c00		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; blank 0
    217  1c08		       7e 42 7e 42*	      BYTE.b	$7E, $42, $7E, $42, $7E, $42, $7E, $42	; ladder 1
    218  1c10		       ff 5a 00 00*	      BYTE.b	$FF, $5A, $00, $00, $00, $00, $00, $00	; platform 2
    219  1c18		       ff ff ff ff*	      BYTE.b	$FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF	; wall 3
    220  1c20		       00 3c 62 5e*	      BYTE.b	0,60,98,94,86,102,60,0	; exit (door) 4
    221  1c28		       ff 81 9d a1*	      BYTE.b	255,129,157,161,173,153,129,255	; locked exit 5
    222  1c30		       ff e7 db db*	      BYTE.b	255,231,219,219,129,129,129,255	; locked wall 6
    223  1c38		       ff ee f1 ef*	      BYTE.b	$FF, $EE, $F1, $EF, $57, $8F, $F3, $FF	; breakable wall 7
    224  1c40		       12 d6 7c 3f*	      BYTE.b	18,214,124,63,252,62,107,72	; spike ball 8 		    PETSCII WHY?? I CAN'T READ THIS!
    225  1c48		       18 3c 3c 3c*	      BYTE.b	24,60,60,60,126,82,8,36	; booster powerup 9
    226  1c50		       18 24 24 18*	      BYTE.b	24,36,36,24,16,24,16,24	; key powerup A
    227  1c58		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; empty B
    228  1c60		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; empty C
    229  1c68		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; empty D
    230  1c70		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; empty E
    231  1c78
    232  1c78		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; charU F
    233  1c80		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; charD 10
    234  1c88		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; charL 11
    235  1c90		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; charR 12
    236  1c98		       ff 81 a5 81*	      BYTE.b	$FF, $81, $A5, $81, $BD, $81, $81, $FF	; squarebot 13 
    237  1ca0
    238  1ca0							; attachments
    239  1ca0		       00 00 00 00*	      BYTE.b	0,0,0,0,195,126,126,60	; ready booster attachment up 14
    240  1ca8		       3c 7e 7e c3*	      BYTE.b	60,126,126,195,0,0,0,0	; rb down 15
    241  1cb0		       08 0e 07 07*	      BYTE.b	8,14,7,7,7,7,14,8	; rb left 16
    242  1cb8		       10 70 e0 e0*	      BYTE.b	16,112,224,224,224,224,112,16	; rb right 17
    243  1cc0		       3c 7e 3c 18*	      BYTE.b	60,126,60,24,219,126,126,60	; active booster attachment up 18
    244  1cc8		       3c 7e 7e db*	      BYTE.b	60,126,126,219,24,60,126,60	; ab down 19
    245  1cd0		       08 4e e7 ff*	      BYTE.b	8,78,231,255,255,231,78,8	; ab left 1A
    246  1cd8		       10 72 e7 ff*	      BYTE.b	16,114,231,255,255,231,114,16	; ab right 1B
    247  1ce0		       00 1e 14 1e*	      BYTE.b	0,30,20,30,24,24,24,60	; key attachment up 1C
    248  1ce8		       3c 18 18 18*	      BYTE.b	60,24,24,24,30,20,30,0	; key down 1D
    249  1cf0		       00 00 01 7f*	      BYTE.b	0,0,1,127,95,113,80,0	; key left 1E
    250  1cf8		       00 00 80 fe*	      BYTE.b	0,0,128,254,250,142,10,0	; key right 1F
    251  1d00
    252  1d00							; for the title screen.......
    253  1d00		       ff 80 80 80*	      BYTE.b	255,128,128,128,128,129,131,135	;20
    254  1d08		       ff 00 00 00*	      BYTE.b	255,0,0,0,192,224,48,248	;21
    255  1d10		       ff 00 00 00*	      BYTE.b	255,0,0,0,0,0,0,0	;22
    256  1d18		       ff 01 01 01*	      BYTE.b	255,1,1,1,1,1,1,1	;23
    257  1d20		       8f 9b 83 83*	      BYTE.b	143,155,131,131,128,128,128,128	;24
    258  1d28		       e0 e0 e0 e0*	      BYTE.b	224,224,224,224,0,0,0,0	;25
    259  1d30		       01 07 1f 07*	      BYTE.b	1,7,31,7,7,7,0,0	;26
    260  1d38		       f1 c1 c1 c1*	      BYTE.b	241,193,193,193,193,193,1,1	;27
    261  1d40		       80 80 81 80*	      BYTE.b	128,128,129,128,152,152,156,143	;28
    262  1d48		       00 00 c0 70*	      BYTE.b	0,0,192,112,30,3,0,255	;29
    263  1d50		       00 00 00 00*	      BYTE.b	0,0,0,0,0,128,240,28	;2A
    264  1d58		       01 01 01 01*	      BYTE.b	1,1,1,1,1,1,1,1	;2B
    265  1d60		       8f 9f 9f 9e*	      BYTE.b	143,159,159,158,128,128,128,255	;2C
    266  1d68		       ff 00 00 00*	      BYTE.b	255,0,0,0,0,0,0,255	;2D
    267  1d70		       07 00 00 00*	      BYTE.b	7,0,0,0,0,0,0,255	;2E
    268  1d78		       81 c1 01 01*	      BYTE.b	129,193,1,1,1,1,1,255	;2F
    269  1d80							;byte 3455
    270  1d80
    271  1d80							;possible optimizations:
    272  1d80							;shift character set begin as far as i can
    273  1d80							;generalize 16 bit arithmetic
    274  1d80							;reuse switch statements
