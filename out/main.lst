------- FILE src/main.s LEVEL 1 PASS 3
      1  1c50 ????						; title screen program -- use hand-made compression method (esentially just RLE, see rleEncoding.py)
      2  1c50 ????				      processor	6502
      3  1c50 ????
      4 U0018 ????				      seg.u	ZP
      5 U0000					      org	$0
      6 U0000
      7 U0000
      8 U0000		       00 00	   screen_cursor ds.w	1	; stores the current screen memory address
      9 U0002		       00 00	   color_cursor ds.w	1	; store current color memory address
     10 U0004		       00 00	   current_level ds.w	1
     11 U0006		       00 00	   next_level ds.w	1
     12 U0008		       00	   level_reset ds.b	1
     13 U0009		       00	   level_completed ds.b	1
     14 U000a		       00	   level_data_index ds.b	1	; for temporarily saving index registers
     15 U000b		       00	   temp       ds.b	1	; for temporarily saving index registers
     16 U000c		       00 00	   new_position ds.w	1	; use to store position of (proposed) new location for squarebot
     17 U000e		       00 00	   new_color_position ds.w	1	; use to store position of (proposed) new location for squarebot
     18 U0010		       00	   current_time ds.b	1	; store only the last byte of the jiffy clock
     19 U0011		       00 00	   squarebot_position ds.w	1
     20 U0013		       00 00	   squarebot_color_position ds.w	1
     21 U0015		       00	   has_key    ds.b	1
     22 U0016		       00	   has_booster ds.b	1
     23 U0017		       00	   jump_remaining ds.b	1	; number of times the character should continue to move upwards in the current jump
     24  1c50 ????				      seg
     25  1c50 ????
     26  1c50 ????						; constants
     27  1c50 ????	       00 20	   BLANK_CHAR =	$20
     28  1c50 ????
     29  1c50 ????	       00 00	   SCREEN_CURSOR_BEGINNING_LOW_BYTE =	$00
     30  1c50 ????	       00 1e	   SCREEN_CURSOR_BEGINNING_HIGH_BYTE =	$1e
     31  1c50 ????
     32  1c50 ????						; last screen location
     33  1c50 ????	       00 fa	   END_OF_SCREEN_LOW_BYTE =	$fa
     34  1c50 ????	       00 1f	   END_OF_SCREEN_HIGH_BYTE =	$1f
     35  1c50 ????
     36  1c50 ????						; beginning of color memory
     37  1c50 ????	       00 00	   COLOR_CURSOR_BEGINNING_LOW_BYTE =	$00
     38  1c50 ????	       00 96	   COLOR_CURSOR_BEGINNING_HIGH_BYTE =	$96
     39  1c50 ????	       00 00	   RED_COLOR_CODE =	0
     40  1c50 ????
     41  1c50 ????	       00 20	   SPACE_KEY  =	$20
     42  1c50 ????	       00 09	   W_KEY      =	$09
     43  1c50 ????	       00 11	   A_KEY      =	$11
     44  1c50 ????	       00 29	   S_KEY      =	$29
     45  1c50 ????	       00 12	   D_KEY      =	$12
     46  1c50 ????	       00 0d	   SECRET_KEY =	$0d	; press P to skip to next  level
     47  1c50 ????	       00 03	   JUMP_SIZE  =	$3	; number of characters a jump causes
     48  1c50 ????	       00 16	   ROW_SIZE   =	$16
     49  1c50 ????
     50  1c50 ????						; memory locations
     51  1c50 ????	       10 01	   user_memory_start =	$1001
     52  1c50 ????	       00 c5	   currently_pressed_key =	$c5
     53  1c50 ????	       00 a0	   jiffy_clock =	$A0
     54  1c50 ????	       90 05	   character_info_register =	$9005
     55  1c50 ????	       1c 00	   character_set_begin =	$1c00
     56  1c50 ????
     57  1c50 ????						; begin location counter at 4096 (user memory)
     58  1001					      org	user_memory_start
------- FILE stub.s LEVEL 2 PASS 3
      0  1001					      include	"stub.s"	; stub contains BASIC sys cmd to run the machine language code
      1  1001		       00 9e	   SYS_CMD_TOKEN =	$9e
      2  1001		       00 0a	   STUB_LINE_NUMBER =	10
      3  1001							; BASIC stub -- SYS cmd to run machine language 
      4  1001		       0b 10		      dc.w	nextstmt	; link; beginning of basic
      5  1003		       0a 00		      dc.w	STUB_LINE_NUMBER	; line number 
      6  1005		       9e 34 31 30*	      dc.b	SYS_CMD_TOKEN, [start]d, 0	; token for sys with operand as address to "start" label
      7  100b				   nextstmt
      8  100b		       00 00		      dc.w	0
------- FILE src/main.s
     60  100d
     61  100d				   start
     62  100d							; use combination of RAM (first 128 chars at 7168) & ROM character set
     63  100d		       a9 ff		      lda	#255
     64  100f		       8d 05 90 	      sta	character_info_register
     65  1012
     66  1012							; initialize some variables in the zero page
     67  1012		       a9 01		      lda	#1
     68  1014		       85 08		      sta	level_reset
     69  1016		       a9 00		      lda	#0
     70  1018		       85 09		      sta	level_completed
     71  101a
     72  101a		       a9 76		      lda	#<level_data_start
     73  101c		       85 04		      sta	current_level
     74  101e		       a9 13		      lda	#>level_data_start
     75  1020		       85 05		      sta	current_level+1
     76  1022
     77  1022		       a9 00		      lda	#0
     78  1024		       85 17		      sta	jump_remaining
     79  1026
------- FILE titleScreen.s LEVEL 2 PASS 3
      0  1026					      include	"titleScreen.s"
      1  1026				   display_title_screen
      2  1026		       a9 00		      lda	#SCREEN_CURSOR_BEGINNING_LOW_BYTE
      3  1028		       85 00		      sta	screen_cursor
      4  102a		       a9 1e		      lda	#SCREEN_CURSOR_BEGINNING_HIGH_BYTE	; store 1e in location 01
      5  102c		       85 01		      sta	screen_cursor+1
      6  102e
      7  102e		       a9 00		      lda	#COLOR_CURSOR_BEGINNING_LOW_BYTE
      8  1030		       85 02		      sta	color_cursor
      9  1032		       a9 96		      lda	#COLOR_CURSOR_BEGINNING_HIGH_BYTE
     10  1034		       85 03		      sta	color_cursor+1
     11  1036
     12  1036		       a0 00		      ldy	#$0	; to use for indirect indexed addressing
     13  1038		       a2 00		      ldx	#$0
     14  103a
     15  103a		       20 46 10 	      jsr	draw_title_screen_loop
     16  103d
     17  103d				   infinite_loop
     18  103d		       a5 c5		      lda	currently_pressed_key
     19  103f		       c9 20		      cmp	#SPACE_KEY
     20  1041		       f0 5c		      beq	gameLoop
     21  1043		       4c 3d 10 	      jmp	infinite_loop
     22  1046
     23  1046
     24  1046				   draw_title_screen_loop
     25  1046		       bd 0e 13 	      lda	compressed_screen_data_start,X	; accumulator stores num times to repeat the byte
     26  1049		       20 54 10 	      jsr	draw_character	; draw the character that many times
     27  104c		       e8		      inx
     28  104d		       e8		      inx
     29  104e		       20 8f 10 	      jsr	check_if_screen_cursor_at_end
     30  1051		       90 f3		      bcc	draw_title_screen_loop
     31  1053		       60		      rts
     32  1054
     33  1054
     34  1054							; draw the character in Y register for (value of accumulator) number of times
     35  1054				   draw_character
     36  1054							; if accumulator == 0, return; otherwise, subtract 1 from accumulator and continue drawing the letter at Y
     37  1054		       f0 1d		      beq	draw_character_end
     38  1056		       38		      sec
     39  1057		       e9 01		      sbc	#1
     40  1059		       48		      pha		; push accumulator onto stack
     41  105a
     42  105a							; store current char at screen cursor location
     43  105a		       a0 00		      ldy	#0
     44  105c		       bd 0f 13 	      lda	compressed_screen_data_start+1,X	; load cur char to draw
     45  105f		       18		      clc
     46  1060		       69 80		      adc	#128
     47  1062		       91 00		      sta	(screen_cursor),Y	; draw it on screen
     48  1064
     49  1064							; add color to the screen location if it's not a space
     50  1064							; because our title screen only has one color, and only displays it for characters that arent space, we can get away with this "optimization",
     51  1064							; and avoid adding color data
     52  1064		       c9 20		      cmp	#BLANK_CHAR
     53  1066		       f0 04		      beq	dont_color
     54  1068		       a9 00		      lda	#RED_COLOR_CODE
     55  106a		       91 02		      sta	(color_cursor),Y
     56  106c
     57  106c				   dont_color
     58  106c		       20 74 10 	      jsr	add_one_to_screen_cursor
     59  106f		       68		      pla		; put the current 'count' (remaining times to draw character) back on accumulator
     60  1070		       4c 54 10 	      jmp	draw_character
     61  1073
     62  1073				   draw_character_end
     63  1073		       60		      rts
     64  1074
     65  1074
     66  1074
     67  1074				   add_one_to_screen_cursor
     68  1074		       18		      clc
     69  1075		       a5 00		      lda	screen_cursor	; load and add to low byte
     70  1077		       69 01		      adc	#$1
     71  1079		       85 00		      sta	screen_cursor
     72  107b		       a5 01		      lda	screen_cursor+1
     73  107d		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
     74  107f		       85 01		      sta	screen_cursor+1
     75  1081
     76  1081							; add to color cursor as well
     77  1081		       18		      clc
     78  1082		       a5 02		      lda	color_cursor	; load and add to low byte
     79  1084		       69 01		      adc	#$1
     80  1086		       85 02		      sta	color_cursor
     81  1088		       a5 03		      lda	color_cursor+1
     82  108a		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
     83  108c		       85 03		      sta	color_cursor+1
     84  108e		       60		      rts
     85  108f
     86  108f				   check_if_screen_cursor_at_end		; set carry flag if screen_cursor at position $1ff9 (8185
     87  108f		       a5 00		      lda	screen_cursor	; load value at screen_cursor low byte
     88  1091		       c9 fa		      cmp	#END_OF_SCREEN_LOW_BYTE
     89  1093		       d0 06		      bne	check_if_screen_cursor_at_end_return_false	; if low byte doesnt match, return with carry flag as neg
     90  1095
     91  1095		       a5 01		      lda	screen_cursor+1
     92  1097		       c9 1f		      cmp	#END_OF_SCREEN_HIGH_BYTE
     93  1099		       f0 02		      beq	check_if_screen_cursor_at_end_return_true	; if high byte matches, set carry flag
     94  109b
     95  109b				   check_if_screen_cursor_at_end_return_false
     96  109b		       18		      clc
     97  109c		       60		      rts
     98  109d
     99  109d				   check_if_screen_cursor_at_end_return_true
    100  109d		       38		      sec
    101  109e		       60		      rts
------- FILE src/main.s
     81  109f
     82  109f
     83  109f							; title screen code jumps here once space pressed
     84  109f				   gameLoop
     85  109f		       20 d3 10 	      jsr	update_level
     86  10a2		       a9 00		      lda	#0
     87  10a4		       85 08		      sta	level_reset
     88  10a6		       20 de 11 	      jsr	update_game_state
     89  10a9		       20 c4 10 	      jsr	check_for_secret_key
     90  10ac		       20 bb 10 	      jsr	wait_until_next_frame
     91  10af		       20 bb 10 	      jsr	wait_until_next_frame
     92  10b2		       20 bb 10 	      jsr	wait_until_next_frame
     93  10b5		       20 bb 10 	      jsr	wait_until_next_frame
     94  10b8		       4c 9f 10 	      JMP	gameLoop
     95  10bb
     96  10bb
     97  10bb				   wait_until_next_frame		; wait one jiffy before completing game loop
     98  10bb		       a5 a2		      lda	jiffy_clock+2
     99  10bd		       c5 10		      cmp	current_time
    100  10bf		       f0 fa		      beq	wait_until_next_frame
    101  10c1		       85 10		      sta	current_time
    102  10c3		       60		      rts
    103  10c4
    104  10c4							; update level_completed and level_reset if secret_key pressed
    105  10c4				   check_for_secret_key
    106  10c4		       a5 c5		      lda	currently_pressed_key
    107  10c6		       c9 0d		      cmp	#SECRET_KEY
    108  10c8		       d0 08		      bne	check_for_secret_key_return
    109  10ca		       a9 01		      lda	#1
    110  10cc		       85 09		      sta	level_completed
    111  10ce		       a9 01		      lda	#1
    112  10d0		       85 08		      sta	level_reset
    113  10d2
    114  10d2				   check_for_secret_key_return
    115  10d2		       60		      rts
    116  10d3
------- FILE updateLevel.s LEVEL 2 PASS 3
      0  10d3					      include	"updateLevel.s"
      1  10d3		       00 01	   LEVEL_IS_DONE =	1
      2  10d3		       00 00	   LEVEL_NOT_DONE =	0
      3  10d3		       00 01	   SHOULD_RESET =	1
      4  10d3		       00 00	   SHOULD_NOT_RESET =	0
      5  10d3
      6  10d3							; only first 4 bits really matter here; refer to readme for guide on lvl format
      7  10d3		       00 00	   BLANK_SPACE =	0	; 000000000
      8  10d3		       00 10	   STARTING_POINT =	16	; 00010000
      9  10d3		       00 20	   WALL       =	32	; 00100000
     10  10d3		       00 30	   BREAKABLE_WALL =	48	; 00110000
     11  10d3		       00 40	   LOCKED_WALL =	64	; 01000000
     12  10d3		       00 50	   LADDER     =	80	; 01010000
     13  10d3		       00 60	   EXIT       =	96	; 01100000
     14  10d3		       00 70	   PLATFORM   =	112	; 01110000
     15  10d3		       00 80	   KEY	      =	128	; 10000000
     16  10d3		       00 90	   SPIKE      =	144	; 10010000
     17  10d3		       00 a0	   BOOSTER    =	160	;  10100000
     18  10d3
     19  10d3		       00 00	   WALL_COLOR =	0
     20  10d3		       00 00	   BREAKABLE_WALL_COLOR =	0
     21  10d3		       00 00	   LOCKED_WALL_COLOR =	0
     22  10d3		       00 08	   LADDER_COLOR =	8
     23  10d3		       00 02	   EXIT_COLOR =	2
     24  10d3		       00 02	   PLATFORM_COLOR =	2
     25  10d3		       00 07	   KEY_COLOR  =	7
     26  10d3		       00 06	   SPIKE_COLOR =	6
     27  10d3		       00 03	   BOOSTER_COLOR =	3
     28  10d3
     29  10d3		       00 20	   BLANK_SPACE_CHAR =	$20
     30  10d3		       00 03	   WALL_CHAR  =	$3
     31  10d3		       00 07	   BREAKABLE_WALL_CHAR =	$7
     32  10d3		       00 06	   LOCKED_WALL_CHAR =	$6
     33  10d3		       00 00	   LADDER_CHAR =	$0
     34  10d3		       00 04	   EXIT_CHAR  =	$4
     35  10d3		       00 02	   PLATFORM_CHAR =	$2
     36  10d3		       00 05	   KEY_CHAR   =	$5
     37  10d3		       00 08	   SPIKE_CHAR =	$8
     38  10d3		       00 09	   BOOSTER_CHAR =	$9
     39  10d3
     40  10d3
     41  10d3				   update_level
     42  10d3							; check if the level is completed; set current_level to next_level if so
     43  10d3		       a5 09		      lda	level_completed
     44  10d5		       c9 01		      cmp	#LEVEL_IS_DONE	; (try optimizing later)
     45  10d7		       d0 0c		      bne	dont_update
     46  10d9
     47  10d9							; level is done; reset level completed
     48  10d9		       a9 00		      lda	#LEVEL_NOT_DONE
     49  10db		       85 09		      sta	level_completed
     50  10dd
     51  10dd							; now set current_level to next_level
     52  10dd		       a5 06		      lda	next_level
     53  10df		       85 04		      sta	current_level
     54  10e1		       a5 07		      lda	next_level+1
     55  10e3		       85 05		      sta	current_level+1
     56  10e5
     57  10e5				   dont_update
     58  10e5							; now check if level reset was set
     59  10e5		       a5 08		      lda	level_reset
     60  10e7		       c9 00		      cmp	#0
     61  10e9		       d0 01		      bne	continue_update	; if not, go back to game loop
     62  10eb		       60		      rts
     63  10ec
     64  10ec				   continue_update
     65  10ec							; if it was, update the level
     66  10ec		       a9 00		      lda	#SCREEN_CURSOR_BEGINNING_LOW_BYTE
     67  10ee		       85 00		      sta	screen_cursor
     68  10f0		       a9 1e		      lda	#SCREEN_CURSOR_BEGINNING_HIGH_BYTE
     69  10f2		       85 01		      sta	screen_cursor+1
     70  10f4
     71  10f4		       a9 00		      lda	#COLOR_CURSOR_BEGINNING_LOW_BYTE
     72  10f6		       85 02		      sta	color_cursor
     73  10f8		       a9 96		      lda	#COLOR_CURSOR_BEGINNING_HIGH_BYTE
     74  10fa		       85 03		      sta	color_cursor+1
     75  10fc
     76  10fc		       a2 00		      ldx	#0
     77  10fe		       a0 00		      ldy	#0
     78  1100		       84 0a		      sty	level_data_index
     79  1102							; draw (or redraw) the current level
     80  1102				   draw_level_loop
     81  1102							; y stores our index in the current level data
     82  1102		       a4 0a		      ldy	level_data_index
     83  1104		       b1 04		      lda	(current_level),y	; accumulator stores the number of times to repeat the next byte  
     84  1106
     85  1106		       20 22 11 	      jsr	draw_sequence
     86  1109
     87  1109		       a4 0a		      ldy	level_data_index
     88  110b		       c8		      iny		; set y to point to next length byte (iterate 2 at a time)
     89  110c		       c8		      iny
     90  110d		       84 0a		      sty	level_data_index
     91  110f
     92  110f
     93  110f		       20 8f 10 	      jsr	check_if_screen_cursor_at_end
     94  1112		       90 ee		      bcc	draw_level_loop
     95  1114
     96  1114
     97  1114							; update next level pointer to point to byte after current level
     98  1114		       a5 04		      lda	current_level
     99  1116		       18		      clc
    100  1117		       65 0a		      adc	level_data_index
    101  1119		       85 06		      sta	next_level
    102  111b		       a5 05		      lda	current_level+1
    103  111d		       69 00		      adc	#0
    104  111f		       85 07		      sta	next_level+1
    105  1121		       60		      rts
    106  1122
    107  1122
    108  1122
    109  1122							; i love writing decompression code in assembly. i love writing decompression code in assembly. i love writing decompression code in assembly. 
    110  1122				   draw_sequence
    111  1122							; if acc == 0, return; otherwise subtract 1, draw the next 2 chars
    112  1122		       f0 1c		      beq	draw_sequence_end
    113  1124		       38		      sec
    114  1125		       e9 01		      sbc	#1
    115  1127		       48		      pha		; push accumulator onto stack
    116  1128
    117  1128		       a4 0a		      ldy	level_data_index
    118  112a		       c8		      iny		; (so we can access the "element" byte after the length byte)
    119  112b		       b1 04		      lda	(current_level),y	; get formatted byte (see squarebot doc)
    120  112d		       0a		      asl		; lol
    121  112e		       0a		      asl
    122  112f		       0a		      asl
    123  1130		       0a		      asl
    124  1131		       20 41 11 	      jsr	draw_high_bits	; draw char represented by the 4 high bits
    125  1134
    126  1134		       a4 0a		      ldy	level_data_index
    127  1136		       c8		      iny
    128  1137
    129  1137		       b1 04		      lda	(current_level),y
    130  1139		       20 41 11 	      jsr	draw_high_bits
    131  113c
    132  113c		       68		      pla
    133  113d		       4c 22 11 	      jmp	draw_sequence
    134  1140
    135  1140				   draw_sequence_end
    136  1140		       60		      rts
    137  1141
    138  1141
    139  1141							; put the character in the high 4 bits of accumulator on screen (see readme), and move the color and screen cursors ahead
    140  1141				   draw_high_bits
    141  1141		       29 f0		      and	#240	; shave off last 4 bits
    142  1143
    143  1143		       c9 00		      cmp	#BLANK_SPACE
    144  1145		       d0 08		      bne	check_if_starting_point
    145  1147		       a9 20		      lda	#BLANK_SPACE_CHAR	; todo; replace with actual chars
    146  1149		       a2 01		      ldx	#1
    147  114b		       20 d3 11 	      jsr	draw_char_in_accumulator
    148  114e		       60		      rts
    149  114f
    150  114f				   check_if_starting_point
    151  114f		       c9 10		      cmp	#STARTING_POINT
    152  1151		       d0 18		      bne	check_if_wall
    153  1153
    154  1153							; set squarebot to starting point
    155  1153		       a5 00		      lda	screen_cursor
    156  1155		       85 11		      sta	squarebot_position
    157  1157		       a5 01		      lda	screen_cursor+1
    158  1159		       85 12		      sta	squarebot_position+1
    159  115b
    160  115b		       a5 02		      lda	color_cursor
    161  115d		       85 13		      sta	squarebot_color_position
    162  115f		       a5 03		      lda	color_cursor+1
    163  1161		       85 14		      sta	squarebot_color_position+1
    164  1163
    165  1163		       a9 01		      lda	#$1
    166  1165		       a2 02		      ldx	#SQUAREBOT_COLOR
    167  1167		       20 d3 11 	      jsr	draw_char_in_accumulator
    168  116a
    169  116a
    170  116a
    171  116a		       60		      rts
    172  116b
    173  116b				   check_if_wall
    174  116b		       c9 20		      cmp	#WALL
    175  116d		       d0 08		      bne	check_if_breakable_wall
    176  116f		       a9 03		      lda	#WALL_CHAR
    177  1171		       a2 00		      ldx	#WALL_COLOR
    178  1173		       20 d3 11 	      jsr	draw_char_in_accumulator
    179  1176		       60		      rts
    180  1177
    181  1177				   check_if_breakable_wall
    182  1177		       c9 30		      cmp	#BREAKABLE_WALL
    183  1179		       d0 08		      bne	check_if_locked_wall
    184  117b		       a9 07		      lda	#BREAKABLE_WALL_CHAR
    185  117d		       a2 00		      ldx	#BREAKABLE_WALL_COLOR
    186  117f		       20 d3 11 	      jsr	draw_char_in_accumulator
    187  1182		       60		      rts
    188  1183
    189  1183				   check_if_locked_wall
    190  1183		       c9 40		      cmp	#LOCKED_WALL
    191  1185		       d0 08		      bne	check_if_ladder
    192  1187		       a9 06		      lda	#LOCKED_WALL_CHAR
    193  1189		       a2 00		      ldx	#LOCKED_WALL_COLOR
    194  118b		       20 d3 11 	      jsr	draw_char_in_accumulator
    195  118e		       60		      rts
    196  118f
    197  118f				   check_if_ladder
    198  118f		       c9 50		      cmp	#LADDER
    199  1191		       d0 08		      bne	check_if_exit
    200  1193		       a9 00		      lda	#LADDER_CHAR
    201  1195		       a2 08		      ldx	#LADDER_COLOR
    202  1197		       20 d3 11 	      jsr	draw_char_in_accumulator
    203  119a		       60		      rts
    204  119b
    205  119b				   check_if_exit
    206  119b		       c9 60		      cmp	#EXIT
    207  119d		       d0 08		      bne	check_if_platform
    208  119f		       a9 04		      lda	#EXIT_CHAR
    209  11a1		       a2 02		      ldx	#EXIT_COLOR
    210  11a3		       20 d3 11 	      jsr	draw_char_in_accumulator
    211  11a6		       60		      rts
    212  11a7
    213  11a7				   check_if_platform
    214  11a7		       c9 70		      cmp	#PLATFORM
    215  11a9		       d0 08		      bne	check_if_key
    216  11ab		       a9 02		      lda	#PLATFORM_CHAR
    217  11ad		       a2 02		      ldx	#PLATFORM_COLOR
    218  11af		       20 d3 11 	      jsr	draw_char_in_accumulator
    219  11b2		       60		      rts
    220  11b3
    221  11b3
    222  11b3				   check_if_key
    223  11b3		       c9 80		      cmp	#KEY
    224  11b5		       d0 08		      bne	check_if_spike
    225  11b7		       a9 05		      lda	#KEY_CHAR
    226  11b9		       a2 07		      ldx	#KEY_COLOR
    227  11bb		       20 d3 11 	      jsr	draw_char_in_accumulator
    228  11be		       60		      rts
    229  11bf
    230  11bf				   check_if_spike
    231  11bf		       c9 90		      cmp	#SPIKE
    232  11c1		       d0 08		      bne	check_if_booster
    233  11c3		       a9 08		      lda	#SPIKE_CHAR
    234  11c5		       a2 06		      ldx	#SPIKE_COLOR
    235  11c7		       20 d3 11 	      jsr	draw_char_in_accumulator
    236  11ca		       60		      rts
    237  11cb
    238  11cb				   check_if_booster
    239  11cb		       a9 09		      lda	#BOOSTER_CHAR
    240  11cd		       a2 03		      ldx	#BOOSTER_COLOR
    241  11cf		       20 d3 11 	      jsr	draw_char_in_accumulator
    242  11d2		       60		      rts
    243  11d3
    244  11d3
    245  11d3							; char in accumulator goes in screen cursor, color in x register goes in color cursor, then update cursors
    246  11d3
    247  11d3				   draw_char_in_accumulator
    248  11d3		       a0 00		      ldy	#0
    249  11d5		       91 00		      sta	(screen_cursor),y
    250  11d7
    251  11d7		       8a		      txa
    252  11d8		       91 02		      sta	(color_cursor),y
    253  11da
    254  11da		       20 74 10 	      jsr	add_one_to_screen_cursor	; add to both screen and color cursor
    255  11dd		       60		      rts
------- FILE src/main.s
------- FILE updateGameState.s LEVEL 2 PASS 3
      0  11de					      include	"updateGameState.s"
      1  11de
      2  11de		       00 01	   MOVE_LEFT  =	1
      3  11de		       00 02	   MOVE_RIGHT =	2
      4  11de		       00 01	   SQUAREBOT_CHAR =	$1
      5  11de		       00 02	   SQUAREBOT_COLOR =	$2
      6  11de		       00 e4	   START_OF_FIRST_ROW_LOW_BYTE =	$e4
      7  11de		       00 1f	   START_OF_FIRST_ROW_HIGH_BYTE =	$1f
      8  11de
      9  11de							; handle player input, update current state of game objects
     10  11de							; some pseudocode to provide a better idea of what we're doing here:
     11  11de
     12  11de							; new_position = squarebot_position
     13  11de							; if A pressed
     14  11de							;   new_position += 1 (move right one char)
     15  11de							; if D pressed
     16  11de							;   new_position -= 1 (move left one char)
     17  11de							; if not valid(new_position)
     18  11de							;   new_position = squarebot_position
     19  11de
     20  11de							; if jump_remaining = 0 and space not pressed:
     21  11de							;   return
     22  11de							; if jump_remaining = 0 and space is pressed:
     23  11de							;   jump remaining = JUMP_SIZE
     24  11de
     25  11de
     26  11de							; if jump_remaining > 0
     27  11de							;   new_position -= 22 (go up one)
     28  11de							;   if not valid(new_position):
     29  11de							;     new_position = squarebot_position
     30  11de							;     jump_remaining = 0
     31  11de							; else
     32  11de							;   new_position += 22 (go down one)
     33  11de							;   jump_remaining -= 1
     34  11de							;   if not valid(new_position):
     35  11de							;     jump_remaining = 0
     36  11de							;     new_position = o
     37  11de							; 
     38  11de							;
     39  11de
     40  11de				   update_game_state
     41  11de		       a5 11		      lda	squarebot_position
     42  11e0		       85 0c		      sta	new_position
     43  11e2		       a5 12		      lda	squarebot_position+1
     44  11e4		       85 0d		      sta	new_position+1
     45  11e6		       a5 13		      lda	squarebot_color_position
     46  11e8		       85 0e		      sta	new_color_position
     47  11ea		       a5 14		      lda	squarebot_color_position+1
     48  11ec		       85 0f		      sta	new_color_position+1
     49  11ee
     50  11ee		       a5 c5		      lda	currently_pressed_key
     51  11f0		       c9 11		      cmp	#A_KEY
     52  11f2		       d0 06		      bne	check_if_d_pressed
     53  11f4		       20 91 12 	      jsr	move_new_position_to_left
     54  11f7		       4c 01 12 	      jmp	check_if_new_position_valid
     55  11fa
     56  11fa				   check_if_d_pressed
     57  11fa		       c9 12		      cmp	#D_KEY
     58  11fc		       d0 03		      bne	check_if_new_position_valid
     59  11fe		       20 76 12 	      jsr	move_new_position_to_right
     60  1201
     61  1201				   check_if_new_position_valid
     62  1201		       a0 00		      ldy	#0
     63  1203		       b1 0c		      lda	(new_position),y
     64  1205		       c9 20		      cmp	#BLANK_CHAR
     65  1207		       d0 03		      bne	handle_jump_logic
     66  1209		       20 58 12 	      jsr	update_squarebot_position
     67  120c
     68  120c				   handle_jump_logic
     69  120c		       a5 17		      lda	jump_remaining	; how many more upward motions for current jump
     70  120e		       c9 00		      cmp	#0
     71  1210		       d0 17		      bne	handle_jumps_remaining
     72  1212
     73  1212
     74  1212				   handle_no_jumps_remaining		; if no jumps left, then start jump if space is pressed, otherwise just skip and handle gravity
     75  1212		       a5 c5		      lda	currently_pressed_key
     76  1214		       c9 20		      cmp	#SPACE_KEY
     77  1216		       d0 2c		      bne	handle_gravity
     78  1218
     79  1218
     80  1218
     81  1218		       20 fe 12 	      jsr	squarebot_on_first_row	; if on first row, we dont care about what character lies below
     82  121b		       b0 08		      bcs	skip_validity_check
     83  121d
     84  121d							; check if character below is blank; if so dont allow us to set jump_remaining
     85  121d		       a0 16		      ldy	#ROW_SIZE
     86  121f		       b1 11		      lda	(squarebot_position),y
     87  1221		       c9 20		      cmp	#BLANK_SPACE_CHAR
     88  1223		       f0 1f		      beq	handle_gravity
     89  1225
     90  1225				   skip_validity_check
     91  1225		       a9 03		      lda	#JUMP_SIZE
     92  1227		       85 17		      sta	jump_remaining
     93  1229
     94  1229				   handle_jumps_remaining
     95  1229		       20 ac 12 	      jsr	move_new_position_up
     96  122c		       a0 00		      ldy	#0
     97  122e		       b1 0c		      lda	(new_position),y
     98  1230		       c9 20		      cmp	#BLANK_CHAR
     99  1232		       d0 0b		      bne	jump_is_invalid	; cant continue moving up; somethings in the way
    100  1234
    101  1234		       20 58 12 	      jsr	update_squarebot_position
    102  1237
    103  1237		       a5 17		      lda	jump_remaining
    104  1239		       38		      sec
    105  123a		       e9 01		      sbc	#1
    106  123c		       85 17		      sta	jump_remaining
    107  123e		       60		      rts		; no gravity effect after moving upwards from jump
    108  123f
    109  123f
    110  123f				   jump_is_invalid
    111  123f		       a9 00		      lda	#0
    112  1241		       85 17		      sta	jump_remaining
    113  1243		       60		      rts
    114  1244
    115  1244				   handle_gravity		; on first row - do nothing
    116  1244		       20 c7 12 	      jsr	move_new_position_down
    117  1247
    118  1247		       20 fe 12 	      jsr	squarebot_on_first_row
    119  124a		       b0 0b		      bcs	do_nothing
    120  124c
    121  124c		       a0 00		      ldy	#0
    122  124e		       b1 0c		      lda	(new_position),y
    123  1250		       c9 20		      cmp	#BLANK_CHAR
    124  1252		       d0 03		      bne	do_nothing
    125  1254
    126  1254
    127  1254		       20 58 12 	      jsr	update_squarebot_position
    128  1257
    129  1257				   do_nothing
    130  1257		       60		      rts
    131  1258
    132  1258				   update_squarebot_position
    133  1258		       20 f3 12 	      jsr	remove_char
    134  125b							; new positions are valid; set them to current positions
    135  125b		       a5 0c		      lda	new_position
    136  125d		       85 11		      sta	squarebot_position
    137  125f		       a5 0d		      lda	new_position+1
    138  1261		       85 12		      sta	squarebot_position+1
    139  1263
    140  1263		       a5 0e		      lda	new_color_position
    141  1265		       85 13		      sta	squarebot_color_position
    142  1267		       a5 0f		      lda	new_color_position+1
    143  1269		       85 14		      sta	squarebot_color_position+1
    144  126b
    145  126b		       a0 00		      ldy	#0
    146  126d		       a9 01		      lda	#SQUAREBOT_CHAR
    147  126f		       91 11		      sta	(squarebot_position),y
    148  1271		       a9 02		      lda	#SQUAREBOT_COLOR
    149  1273		       91 13		      sta	(squarebot_color_position),y
    150  1275
    151  1275		       60		      rts
    152  1276
    153  1276
    154  1276				   move_new_position_to_right
    155  1276		       18		      clc
    156  1277		       a5 0c		      lda	new_position	; load and add to low byte
    157  1279		       69 01		      adc	#$1
    158  127b		       85 0c		      sta	new_position
    159  127d		       a5 0d		      lda	new_position+1
    160  127f		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
    161  1281		       85 0d		      sta	new_position+1
    162  1283		       18		      clc
    163  1284		       a5 0e		      lda	new_color_position	; load and add to low byte
    164  1286		       69 01		      adc	#$1
    165  1288		       85 0e		      sta	new_color_position
    166  128a		       a5 0f		      lda	new_color_position+1
    167  128c		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
    168  128e		       85 0f		      sta	new_color_position+1
    169  1290		       60		      rts
    170  1291
    171  1291				   move_new_position_to_left
    172  1291		       38		      sec
    173  1292		       a5 0c		      lda	new_position
    174  1294		       e9 01		      sbc	#$1
    175  1296		       85 0c		      sta	new_position
    176  1298		       a5 0d		      lda	new_position+1
    177  129a		       e9 00		      sbc	#$0
    178  129c		       85 0d		      sta	new_position+1
    179  129e		       38		      sec
    180  129f		       a5 0e		      lda	new_color_position
    181  12a1		       e9 01		      sbc	#$1
    182  12a3		       85 0e		      sta	new_color_position
    183  12a5		       a5 0f		      lda	new_color_position+1
    184  12a7		       e9 00		      sbc	#$0
    185  12a9		       85 0f		      sta	new_color_position+1
    186  12ab		       60		      rts
    187  12ac
    188  12ac
    189  12ac				   move_new_position_up
    190  12ac		       38		      sec
    191  12ad		       a5 0c		      lda	new_position
    192  12af		       e9 16		      sbc	#ROW_SIZE
    193  12b1		       85 0c		      sta	new_position
    194  12b3		       a5 0d		      lda	new_position+1
    195  12b5		       e9 00		      sbc	#$0
    196  12b7		       85 0d		      sta	new_position+1
    197  12b9		       38		      sec
    198  12ba		       a5 0e		      lda	new_color_position
    199  12bc		       e9 16		      sbc	#ROW_SIZE
    200  12be		       85 0e		      sta	new_color_position
    201  12c0		       a5 0f		      lda	new_color_position+1
    202  12c2		       e9 00		      sbc	#$0
    203  12c4		       85 0f		      sta	new_color_position+1
    204  12c6		       60		      rts
    205  12c7
    206  12c7				   move_new_position_down
    207  12c7		       18		      clc
    208  12c8		       a5 0c		      lda	new_position	; load and add to low byte
    209  12ca		       69 16		      adc	#ROW_SIZE
    210  12cc		       85 0c		      sta	new_position
    211  12ce		       a5 0d		      lda	new_position+1
    212  12d0		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
    213  12d2		       85 0d		      sta	new_position+1
    214  12d4		       18		      clc
    215  12d5		       a5 0e		      lda	new_color_position	; load and add to low byte
    216  12d7		       69 16		      adc	#ROW_SIZE
    217  12d9		       85 0e		      sta	new_color_position
    218  12db		       a5 0f		      lda	new_color_position+1
    219  12dd		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
    220  12df		       85 0f		      sta	new_color_position+1
    221  12e1		       60		      rts
    222  12e2
    223  12e2				   reset_new_position
    224  12e2		       a5 11		      lda	squarebot_position
    225  12e4		       85 0c		      sta	new_position
    226  12e6		       a5 12		      lda	squarebot_position+1
    227  12e8		       85 0d		      sta	new_position+1
    228  12ea
    229  12ea		       a5 13		      lda	squarebot_color_position
    230  12ec		       85 0e		      sta	new_color_position
    231  12ee		       a5 14		      lda	squarebot_color_position+1
    232  12f0		       85 14		      sta	squarebot_color_position+1
    233  12f2		       60		      rts
    234  12f3
    235  12f3				   remove_char		; remove squarebot from current screen location
    236  12f3		       a0 00		      ldy	#0
    237  12f5		       a9 20		      lda	#BLANK_CHAR
    238  12f7		       91 11		      sta	(squarebot_position),Y
    239  12f9		       a9 01		      lda	#1
    240  12fb		       91 13		      sta	(squarebot_color_position),Y
    241  12fd		       60		      rts
    242  12fe
    243  12fe				   squarebot_on_first_row		; set carry flag to 0 if squarebot_position is on bottom of screen; otherwise set to 1
    244  12fe		       a5 12		      lda	squarebot_position+1
    245  1300		       c9 1f		      cmp	#START_OF_FIRST_ROW_HIGH_BYTE
    246  1302		       90 08		      bcc	return_false	; compare high bits; return false if current position high bit is smaller than high bit of leftmost position on first row
    247  1304		       a5 11		      lda	squarebot_position
    248  1306		       c9 e4		      CMP	#START_OF_FIRST_ROW_LOW_BYTE
    249  1308		       90 02		      bcc	return_false
    250  130a
    251  130a				   return_true
    252  130a		       38		      sec
    253  130b		       60		      rts
    254  130c
    255  130c				   return_false
    256  130c		       18		      clc
    257  130d		       60		      rts
------- FILE src/main.s
    119  130e
    120  130e				   compressed_screen_data_start
    121  130e					      incbin	"../data/titleScreenData_compressed"	; got via 'bsave ""'
    122  1376
    123  1376				   level_data_start
    124  1376					      incbin	"../data/levels/binary_levels/1"
    125  1388					      incbin	"../data/levels/binary_levels/2"
    126  1394					      incbin	"../data/levels/binary_levels/3"
    127  13c8					      incbin	"../data/levels/binary_levels/4"
    128  13f0
------- FILE memoryCheck.s LEVEL 2 PASS 3
      0  13f0					      include	"memoryCheck.s"	; code to make sure the program isn't too large and enters screen memory
      1  13f0		       03 ef	   BYTES_USED =	.-$1001	; location counter minus starting location = total bytes used
      2  13f0		       1e 00	   SCREEN_MEMORY_START =	$1e00
 1007 bytes used
      3  13f0					      echo	[BYTES_USED]d, "bytes used"
 Ending program at memory location (base 10):  5104
      4  13f0					      echo	"Ending program at memory location (base 10): ", [.]d
      5  13f0				  -	      if	. >= SCREEN_MEMORY_START	; if program entering screen memory
      6  13f0				  -	      echo	"Throwing error because program is too large, and has entered screen memory!"
      7  13f0				  -	      err
      8  13f0					      endif
------- FILE src/main.s
    130  13f0
    131  13f0
    132  1c00					      org	character_set_begin
    133  1c00		       81 ff ff 81*	      BYTE.b	129,255,255,129,129,255,255,129	; ladder 0
    134  1c08		       ff 81 a5 81*	      BYTE.b	255,129,165,129,189,165,129,255	; squarebot 1
    135  1c10		       ff ff 00 00*	      BYTE.b	255,255,0,0,0,0,0,0	; platform 2
    136  1c18		       ff ff ff ff*	      BYTE.b	255,255,255,255,255,255,255,255	; wall 3
    137  1c20		       7e e7 81 81*	      BYTE.b	126,231,129,129,225,129,129,255	; exit (door) 4
    138  1c28		       18 24 18 18*	      BYTE.b	24,36,24,24,30,24,30,24	; key powerup 5 
    139  1c30		       ff ff ef ef*	      BYTE.b	255,255,239,239,239,227,255,255	;locked wall 6
    140  1c38		       ff bd fd b7*	      BYTE.b	255,189,253,183,127,239,231,255	; breakable wall 7
    141  1c40		       00 00 18 3c*	      BYTE.b	0,0,24,60,126,126,0,0	; spike 8
    142  1c48		       00 70 48 78*	      BYTE.b	0,112,72,120,72,72,112,0	; booster powerup 9
