------- FILE src/main.s LEVEL 1 PASS 3
      1  1c88 ????						; title screen program -- use hand-made compression method (esentially just RLE, see rleEncoding.py)
      2  1c88 ????				      processor	6502
      3  1c88 ????
      4 U001d ????				      seg.u	ZP
      5 U0000					      org	$0
      6 U0000
      7 U0000
      8 U0000		       00 00	   screen_cursor ds.w	1	; stores the current screen memory address
      9 U0002		       00 00	   color_cursor ds.w	1	; store current color memory address
     10 U0004		       00 00	   current_level ds.w	1
     11 U0006		       00 00	   next_level ds.w	1
     12 U0008		       00	   level_reset ds.b	1
     13 U0009		       00	   level_completed ds.b	1
     14 U000a		       00	   level_data_index ds.b	1	; for temporarily saving index registers
     15 U000b		       00	   temp       ds.b	1	; for temporarily saving index registers
     16 U000c		       00 00	   new_position ds.w	1	; use to store position of (proposed) new location for squarebot
     17 U000e		       00 00	   new_color_position ds.w	1	; use to store position of (proposed) new location for squarebot
     18 U0010		       00	   current_time ds.b	1	; store only the last byte of the jiffy clock
     19 U0011		       00 00	   squarebot_position ds.w	1
     20 U0013		       00 00	   squarebot_color_position ds.w	1
     21 U0015		       00	   has_key    ds.b	1
     22 U0016		       00	   has_booster ds.b	1
     23 U0017		       00	   jump_remaining ds.b	1	; number of times the character should continue to move upwards in the current jump
     24 U0018		       00 00 00    tileStore  ds.b	3	; 5 bits for the 4 powerup tiles, 4 bits for squarebot tile since many tiles can't go there. ordered U,D,L,R,M
     25 U001b		       00 00	   attached_powerups ds.w	1	; 4 bits for each side, ordered U,D,L,R. 0=none 1=boost 2=key 3=spike 4=shield
     26  1c88 ????				      seg
     27  1c88 ????
     28  1c88 ????						; constants
     29  1c88 ????	       00 20	   BLANK_CHAR =	$20
     30  1c88 ????
     31  1c88 ????	       00 00	   SCREEN_CURSOR_BEGINNING_LOW_BYTE =	$00
     32  1c88 ????	       00 1e	   SCREEN_CURSOR_BEGINNING_HIGH_BYTE =	$1e
     33  1c88 ????
     34  1c88 ????						; last screen location
     35  1c88 ????	       00 fa	   END_OF_SCREEN_LOW_BYTE =	$fa
     36  1c88 ????	       00 1f	   END_OF_SCREEN_HIGH_BYTE =	$1f
     37  1c88 ????
     38  1c88 ????						; beginning of color memory
     39  1c88 ????	       00 00	   COLOR_CURSOR_BEGINNING_LOW_BYTE =	$00
     40  1c88 ????	       00 96	   COLOR_CURSOR_BEGINNING_HIGH_BYTE =	$96
     41  1c88 ????	       00 00	   RED_COLOR_CODE =	0
     42  1c88 ????
     43  1c88 ????	       00 20	   SPACE_KEY  =	$20
     44  1c88 ????	       00 09	   W_KEY      =	$09
     45  1c88 ????	       00 11	   A_KEY      =	$11
     46  1c88 ????	       00 29	   S_KEY      =	$29
     47  1c88 ????	       00 12	   D_KEY      =	$12
     48  1c88 ????	       00 0d	   SECRET_KEY =	$0d	; press P to skip to next  level
     49  1c88 ????	       00 0a	   RESET_KEY  =	$0a	; press R to restart level i assume
     50  1c88 ????	       00 04	   JUMP_SIZE  =	$4	; number of characters a jump causes
     51  1c88 ????	       00 16	   ROW_SIZE   =	$16
     52  1c88 ????						; memory locations
     53  1c88 ????	       10 01	   user_memory_start =	$1001
     54  1c88 ????	       00 c5	   currently_pressed_key =	$c5
     55  1c88 ????	       00 a0	   jiffy_clock =	$A0
     56  1c88 ????	       90 05	   character_info_register =	$9005
     57  1c88 ????	       1c 00	   character_set_begin =	$1c00
     58  1c88 ????
     59  1c88 ????						; begin location counter at 4096 (user memory)
     60  1001					      org	user_memory_start
------- FILE stub.s LEVEL 2 PASS 3
      0  1001					      include	"stub.s"	; stub contains BASIC sys cmd to run the machine language code
      1  1001		       00 9e	   SYS_CMD_TOKEN =	$9e
      2  1001		       00 0a	   STUB_LINE_NUMBER =	10
      3  1001							; BASIC stub -- SYS cmd to run machine language
      4  1001		       0b 10		      dc.w	nextstmt	; link; beginning of basic
      5  1003		       0a 00		      dc.w	STUB_LINE_NUMBER	; line number
      6  1005		       9e 34 31 30*	      dc.b	SYS_CMD_TOKEN, [start]d, 0	; token for sys with operand as address to "start" label
      7  100b				   nextstmt
      8  100b		       00 00		      dc.w	0
------- FILE src/main.s
     62  100d
     63  100d				   start
     64  100d							; use combination of RAM (first 128 chars at 7168) & ROM character set
     65  100d		       a9 ff		      lda	#255
     66  100f		       8d 05 90 	      sta	character_info_register
     67  1012
     68  1012							; initialize some variables in the zero page
     69  1012		       a9 01		      lda	#1
     70  1014		       85 08		      sta	level_reset
     71  1016		       a9 00		      lda	#0
     72  1018		       85 09		      sta	level_completed
     73  101a
     74  101a		       a9 e5		      lda	#<level_data_start
     75  101c		       85 04		      sta	current_level
     76  101e		       a9 13		      lda	#>level_data_start
     77  1020		       85 05		      sta	current_level+1
     78  1022
     79  1022		       a9 00		      lda	#0
     80  1024		       85 17		      sta	jump_remaining
     81  1026		       85 16		      sta	has_booster
     82  1028		       85 15		      sta	has_key
     83  102a
------- FILE titleScreen.s LEVEL 2 PASS 3
      0  102a					      include	"titleScreen.s"
      1  102a				   display_title_screen
      2  102a		       a9 00		      lda	#SCREEN_CURSOR_BEGINNING_LOW_BYTE
      3  102c		       85 00		      sta	screen_cursor
      4  102e		       a9 1e		      lda	#SCREEN_CURSOR_BEGINNING_HIGH_BYTE	; store 1e in location 01
      5  1030		       85 01		      sta	screen_cursor+1
      6  1032
      7  1032		       a9 00		      lda	#COLOR_CURSOR_BEGINNING_LOW_BYTE
      8  1034		       85 02		      sta	color_cursor
      9  1036		       a9 96		      lda	#COLOR_CURSOR_BEGINNING_HIGH_BYTE
     10  1038		       85 03		      sta	color_cursor+1
     11  103a
     12  103a		       a0 00		      ldy	#$0	; to use for indirect indexed addressing
     13  103c		       a2 00		      ldx	#$0
     14  103e
     15  103e		       20 4a 10 	      jsr	draw_title_screen_loop
     16  1041
     17  1041				   infinite_loop
     18  1041		       a5 c5		      lda	currently_pressed_key
     19  1043		       c9 20		      cmp	#SPACE_KEY
     20  1045		       f0 5c		      beq	gameLoop
     21  1047		       4c 41 10 	      jmp	infinite_loop
     22  104a
     23  104a
     24  104a				   draw_title_screen_loop
     25  104a		       bd 7d 13 	      lda	compressed_screen_data_start,X	; accumulator stores num times to repeat the byte
     26  104d		       20 58 10 	      jsr	draw_character	; draw the character that many times
     27  1050		       e8		      inx
     28  1051		       e8		      inx
     29  1052		       20 93 10 	      jsr	check_if_screen_cursor_at_end
     30  1055		       90 f3		      bcc	draw_title_screen_loop
     31  1057		       60		      rts
     32  1058
     33  1058
     34  1058							; draw the character in Y register for (value of accumulator) number of times
     35  1058				   draw_character
     36  1058							; if accumulator == 0, return; otherwise, subtract 1 from accumulator and continue drawing the letter at Y
     37  1058		       f0 1d		      beq	draw_character_end
     38  105a		       38		      sec
     39  105b		       e9 01		      sbc	#1
     40  105d		       48		      pha		; push accumulator onto stack
     41  105e
     42  105e							; store current char at screen cursor location
     43  105e		       a0 00		      ldy	#0
     44  1060		       bd 7e 13 	      lda	compressed_screen_data_start+1,X	; load cur char to draw
     45  1063		       18		      clc
     46  1064		       69 80		      adc	#128
     47  1066		       91 00		      sta	(screen_cursor),Y	; draw it on screen
     48  1068
     49  1068							; add color to the screen location if it's not a space
     50  1068							; because our title screen only has one color, and only displays it for characters that arent space, we can get away with this "optimization",
     51  1068							; and avoid adding color data
     52  1068		       c9 20		      cmp	#BLANK_CHAR
     53  106a		       f0 04		      beq	dont_color
     54  106c		       a9 00		      lda	#RED_COLOR_CODE
     55  106e		       91 02		      sta	(color_cursor),Y
     56  1070
     57  1070				   dont_color
     58  1070		       20 78 10 	      jsr	add_one_to_screen_cursor
     59  1073		       68		      pla		; put the current 'count' (remaining times to draw character) back on accumulator
     60  1074		       4c 58 10 	      jmp	draw_character
     61  1077
     62  1077				   draw_character_end
     63  1077		       60		      rts
     64  1078
     65  1078
     66  1078
     67  1078				   add_one_to_screen_cursor
     68  1078		       18		      clc
     69  1079		       a5 00		      lda	screen_cursor	; load and add to low byte
     70  107b		       69 01		      adc	#$1
     71  107d		       85 00		      sta	screen_cursor
     72  107f		       a5 01		      lda	screen_cursor+1
     73  1081		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
     74  1083		       85 01		      sta	screen_cursor+1
     75  1085
     76  1085							; add to color cursor as well
     77  1085		       18		      clc
     78  1086		       a5 02		      lda	color_cursor	; load and add to low byte
     79  1088		       69 01		      adc	#$1
     80  108a		       85 02		      sta	color_cursor
     81  108c		       a5 03		      lda	color_cursor+1
     82  108e		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
     83  1090		       85 03		      sta	color_cursor+1
     84  1092		       60		      rts
     85  1093
     86  1093				   check_if_screen_cursor_at_end		; set carry flag if screen_cursor at position $1ff9 (8185
     87  1093		       a5 00		      lda	screen_cursor	; load value at screen_cursor low byte
     88  1095		       c9 fa		      cmp	#END_OF_SCREEN_LOW_BYTE
     89  1097		       d0 06		      bne	check_if_screen_cursor_at_end_return_false	; if low byte doesnt match, return with carry flag as neg
     90  1099
     91  1099		       a5 01		      lda	screen_cursor+1
     92  109b		       c9 1f		      cmp	#END_OF_SCREEN_HIGH_BYTE
     93  109d		       f0 02		      beq	check_if_screen_cursor_at_end_return_true	; if high byte matches, set carry flag
     94  109f
     95  109f				   check_if_screen_cursor_at_end_return_false
     96  109f		       18		      clc
     97  10a0		       60		      rts
     98  10a1
     99  10a1				   check_if_screen_cursor_at_end_return_true
    100  10a1		       38		      sec
    101  10a2		       60		      rts
------- FILE src/main.s
     85  10a3
     86  10a3
     87  10a3							; title screen code jumps here once space pressed
     88  10a3				   gameLoop
     89  10a3		       20 f5 10 	      jsr	update_level
     90  10a6		       a9 00		      lda	#0
     91  10a8		       85 08		      sta	level_reset
     92  10aa		       20 00 12 	      jsr	update_game_state
     93  10ad		       20 d1 10 	      jsr	check_for_secret_key
     94  10b0		       20 e0 10 	      jsr	check_for_reset_key
     95  10b3		       20 c8 10 	      jsr	wait_until_next_frame
     96  10b6		       20 c8 10 	      jsr	wait_until_next_frame
     97  10b9		       20 c8 10 	      jsr	wait_until_next_frame
     98  10bc		       20 c8 10 	      jsr	wait_until_next_frame
     99  10bf		       20 c8 10 	      jsr	wait_until_next_frame
    100  10c2		       20 c8 10 	      jsr	wait_until_next_frame
    101  10c5		       4c a3 10 	      JMP	gameLoop
    102  10c8
    103  10c8
    104  10c8				   wait_until_next_frame		; wait one jiffy before completing game loop
    105  10c8		       a5 a2		      lda	jiffy_clock+2
    106  10ca		       c5 10		      cmp	current_time
    107  10cc		       f0 fa		      beq	wait_until_next_frame
    108  10ce		       85 10		      sta	current_time
    109  10d0		       60		      rts
    110  10d1
    111  10d1							; update level_completed and level_reset if secret_key pressed
    112  10d1				   check_for_secret_key
    113  10d1		       a5 c5		      lda	currently_pressed_key
    114  10d3		       c9 0d		      cmp	#SECRET_KEY
    115  10d5		       d0 08		      bne	check_for_secret_key_return
    116  10d7		       a9 01		      lda	#1
    117  10d9		       85 09		      sta	level_completed
    118  10db		       a9 01		      lda	#1
    119  10dd		       85 08		      sta	level_reset
    120  10df
    121  10df				   check_for_secret_key_return
    122  10df		       60		      rts
    123  10e0
    124  10e0
    125  10e0				   check_for_reset_key
    126  10e0		       a5 c5		      lda	currently_pressed_key
    127  10e2		       c9 0a		      cmp	#RESET_KEY
    128  10e4		       d0 f9		      bne	check_for_secret_key_return	; todo -- reset  a bunch of state (has_key, )
    129  10e6		       a9 01		      lda	#1
    130  10e8		       85 08		      sta	level_reset
    131  10ea		       a9 00		      lda	#0
    132  10ec		       85 16		      sta	has_booster
    133  10ee		       85 15		      sta	has_key
    134  10f0		       85 17		      sta	jump_remaining
    135  10f2		       85 1b		      sta	attached_powerups
    136  10f4
    137  10f4				   check_for_reset_key_return
    138  10f4		       60		      rts
    139  10f5
------- FILE updateLevel.s LEVEL 2 PASS 3
      0  10f5					      include	"updateLevel.s"
      1  10f5		       00 01	   LEVEL_IS_DONE =	1
      2  10f5		       00 00	   LEVEL_NOT_DONE =	0
      3  10f5		       00 01	   SHOULD_RESET =	1
      4  10f5		       00 00	   SHOULD_NOT_RESET =	0
      5  10f5
      6  10f5							; only first 4 bits really matter here; refer to readme for guide on lvl format
      7  10f5		       00 00	   BLANK_SPACE =	0	; 000000000
      8  10f5		       00 10	   STARTING_POINT =	16	; 00010000
      9  10f5		       00 20	   WALL       =	32	; 00100000
     10  10f5		       00 30	   BREAKABLE_WALL =	48	; 00110000
     11  10f5		       00 40	   LOCKED_WALL =	64	; 01000000
     12  10f5		       00 50	   LADDER     =	80	; 01010000
     13  10f5		       00 60	   EXIT       =	96	; 01100000
     14  10f5		       00 70	   PLATFORM   =	112	; 01110000
     15  10f5		       00 80	   KEY	      =	128	; 10000000
     16  10f5		       00 90	   SPIKE      =	144	; 10010000
     17  10f5		       00 a0	   BOOSTER    =	160	;  10100000
     18  10f5
     19  10f5		       00 0d	   WALL_COLOR =	13
     20  10f5		       00 00	   BREAKABLE_WALL_COLOR =	0
     21  10f5		       00 0e	   LOCKED_WALL_COLOR =	14
     22  10f5		       00 08	   LADDER_COLOR =	8
     23  10f5		       00 09	   EXIT_COLOR =	9
     24  10f5		       00 0a	   PLATFORM_COLOR =	10
     25  10f5		       00 0b	   KEY_COLOR  =	11
     26  10f5		       00 02	   SPIKE_COLOR =	2
     27  10f5		       00 0c	   BOOSTER_COLOR =	12
     28  10f5
     29  10f5		       00 20	   BLANK_SPACE_CHAR =	$20
     30  10f5		       00 00	   LADDER_CHAR =	$0
     31  10f5							; no $1?
     32  10f5		       00 02	   PLATFORM_CHAR =	$2
     33  10f5		       00 03	   WALL_CHAR  =	$3
     34  10f5		       00 04	   EXIT_CHAR  =	$4
     35  10f5		       00 05	   KEY_CHAR   =	$5
     36  10f5		       00 06	   LOCKED_WALL_CHAR =	$6
     37  10f5		       00 07	   BREAKABLE_WALL_CHAR =	$7
     38  10f5		       00 08	   SPIKE_CHAR =	$8
     39  10f5		       00 09	   BOOSTER_CHAR =	$9
     40  10f5		       00 11	   CHAR_U     =	$11	; 17-20 in hex
     41  10f5		       00 12	   CHAR_D     =	$12
     42  10f5		       00 13	   CHAR_L     =	$13
     43  10f5		       00 14	   CHAR_R     =	$14
     44  10f5
     45  10f5
     46  10f5				   update_level
     47  10f5							; check if the level is completed; set current_level to next_level if so
     48  10f5		       a5 09		      lda	level_completed
     49  10f7		       c9 01		      cmp	#LEVEL_IS_DONE	; (try optimizing later)
     50  10f9		       d0 0c		      bne	dont_update
     51  10fb
     52  10fb							; level is done; reset level completed
     53  10fb		       a9 00		      lda	#LEVEL_NOT_DONE
     54  10fd		       85 09		      sta	level_completed
     55  10ff
     56  10ff							; now set current_level to next_level
     57  10ff		       a5 06		      lda	next_level
     58  1101		       85 04		      sta	current_level
     59  1103		       a5 07		      lda	next_level+1
     60  1105		       85 05		      sta	current_level+1
     61  1107
     62  1107				   dont_update
     63  1107							; now check if level reset was set
     64  1107		       a5 08		      lda	level_reset
     65  1109		       c9 00		      cmp	#0
     66  110b		       d0 01		      bne	continue_update	; if not, go back to game loop
     67  110d		       60		      rts
     68  110e
     69  110e				   continue_update
     70  110e							; if it was, update the level
     71  110e		       a9 00		      lda	#SCREEN_CURSOR_BEGINNING_LOW_BYTE
     72  1110		       85 00		      sta	screen_cursor
     73  1112		       a9 1e		      lda	#SCREEN_CURSOR_BEGINNING_HIGH_BYTE
     74  1114		       85 01		      sta	screen_cursor+1
     75  1116
     76  1116		       a9 00		      lda	#COLOR_CURSOR_BEGINNING_LOW_BYTE
     77  1118		       85 02		      sta	color_cursor
     78  111a		       a9 96		      lda	#COLOR_CURSOR_BEGINNING_HIGH_BYTE
     79  111c		       85 03		      sta	color_cursor+1
     80  111e
     81  111e		       a2 00		      ldx	#0
     82  1120		       a0 00		      ldy	#0
     83  1122		       84 0a		      sty	level_data_index
     84  1124
     85  1124							; draw (or redraw on reset) the current level
     86  1124				   draw_level_loop
     87  1124							; y stores our index in the current level data
     88  1124		       a4 0a		      ldy	level_data_index
     89  1126		       b1 04		      lda	(current_level),y	; accumulator stores the number of times to repeat the next byte
     90  1128
     91  1128		       20 44 11 	      jsr	draw_sequence
     92  112b
     93  112b		       a4 0a		      ldy	level_data_index
     94  112d		       c8		      iny		; set y to point to next length byte (iterate 2 at a time)
     95  112e		       c8		      iny
     96  112f		       84 0a		      sty	level_data_index
     97  1131
     98  1131
     99  1131		       20 93 10 	      jsr	check_if_screen_cursor_at_end
    100  1134		       90 ee		      bcc	draw_level_loop
    101  1136
    102  1136
    103  1136							; update next level pointer to point to byte after current level
    104  1136		       a5 04		      lda	current_level
    105  1138		       18		      clc
    106  1139		       65 0a		      adc	level_data_index
    107  113b		       85 06		      sta	next_level
    108  113d		       a5 05		      lda	current_level+1
    109  113f		       69 00		      adc	#0
    110  1141		       85 07		      sta	next_level+1
    111  1143		       60		      rts
    112  1144
    113  1144
    114  1144
    115  1144				   draw_sequence
    116  1144							; if acc == 0, return; otherwise subtract 1, draw the next 2 chars
    117  1144		       f0 1c		      beq	draw_sequence_end
    118  1146		       38		      sec
    119  1147		       e9 01		      sbc	#1
    120  1149		       48		      pha		; push accumulator onto stack
    121  114a
    122  114a		       a4 0a		      ldy	level_data_index
    123  114c		       c8		      iny		; (so we can access the "element" byte after the length byte)
    124  114d		       b1 04		      lda	(current_level),y	; get formatted byte (see squarebot doc)
    125  114f		       0a		      asl		; lol
    126  1150		       0a		      asl
    127  1151		       0a		      asl
    128  1152		       0a		      asl
    129  1153		       20 63 11 	      jsr	draw_high_bits	; draw char represented by the 4 high bits
    130  1156
    131  1156		       a4 0a		      ldy	level_data_index
    132  1158		       c8		      iny
    133  1159
    134  1159		       b1 04		      lda	(current_level),y
    135  115b		       20 63 11 	      jsr	draw_high_bits
    136  115e
    137  115e		       68		      pla
    138  115f		       4c 44 11 	      jmp	draw_sequence
    139  1162
    140  1162				   draw_sequence_end
    141  1162		       60		      rts
    142  1163
    143  1163
    144  1163							; put the character in the high 4 bits of accumulator on screen (see readme), and move the color and screen cursors ahead
    145  1163				   draw_high_bits
    146  1163		       29 f0		      and	#240	; shave off last 4 bits
    147  1165
    148  1165		       c9 00		      cmp	#BLANK_SPACE
    149  1167		       d0 08		      bne	check_if_starting_point
    150  1169		       a9 20		      lda	#BLANK_SPACE_CHAR	; todo; replace with actual chars
    151  116b		       a2 01		      ldx	#1
    152  116d		       20 f5 11 	      jsr	draw_char_in_accumulator
    153  1170		       60		      rts
    154  1171
    155  1171				   check_if_starting_point
    156  1171		       c9 10		      cmp	#STARTING_POINT
    157  1173		       d0 18		      bne	check_if_wall
    158  1175
    159  1175							; set squarebot to starting point
    160  1175		       a5 00		      lda	screen_cursor
    161  1177		       85 11		      sta	squarebot_position
    162  1179		       a5 01		      lda	screen_cursor+1
    163  117b		       85 12		      sta	squarebot_position+1
    164  117d
    165  117d		       a5 02		      lda	color_cursor
    166  117f		       85 13		      sta	squarebot_color_position
    167  1181		       a5 03		      lda	color_cursor+1
    168  1183		       85 14		      sta	squarebot_color_position+1
    169  1185
    170  1185		       a9 01		      lda	#$1
    171  1187		       a2 02		      ldx	#SQUAREBOT_COLOR
    172  1189		       20 f5 11 	      jsr	draw_char_in_accumulator
    173  118c
    174  118c		       60		      rts
    175  118d
    176  118d
    177  118d				   check_if_wall
    178  118d		       c9 20		      cmp	#WALL
    179  118f		       d0 08		      bne	check_if_breakable_wall
    180  1191		       a9 03		      lda	#WALL_CHAR
    181  1193		       a2 0d		      ldx	#WALL_COLOR
    182  1195		       20 f5 11 	      jsr	draw_char_in_accumulator
    183  1198		       60		      rts
    184  1199
    185  1199				   check_if_breakable_wall
    186  1199		       c9 30		      cmp	#BREAKABLE_WALL
    187  119b		       d0 08		      bne	check_if_locked_wall
    188  119d		       a9 07		      lda	#BREAKABLE_WALL_CHAR
    189  119f		       a2 00		      ldx	#BREAKABLE_WALL_COLOR
    190  11a1		       20 f5 11 	      jsr	draw_char_in_accumulator
    191  11a4		       60		      rts
    192  11a5
    193  11a5				   check_if_locked_wall
    194  11a5		       c9 40		      cmp	#LOCKED_WALL
    195  11a7		       d0 08		      bne	check_if_ladder
    196  11a9		       a9 06		      lda	#LOCKED_WALL_CHAR
    197  11ab		       a2 0e		      ldx	#LOCKED_WALL_COLOR
    198  11ad		       20 f5 11 	      jsr	draw_char_in_accumulator
    199  11b0		       60		      rts
    200  11b1
    201  11b1				   check_if_ladder
    202  11b1		       c9 50		      cmp	#LADDER
    203  11b3		       d0 08		      bne	check_if_exit
    204  11b5		       a9 00		      lda	#LADDER_CHAR
    205  11b7		       a2 08		      ldx	#LADDER_COLOR
    206  11b9		       20 f5 11 	      jsr	draw_char_in_accumulator
    207  11bc		       60		      rts
    208  11bd
    209  11bd				   check_if_exit
    210  11bd		       c9 60		      cmp	#EXIT
    211  11bf		       d0 08		      bne	check_if_platform
    212  11c1		       a9 04		      lda	#EXIT_CHAR
    213  11c3		       a2 09		      ldx	#EXIT_COLOR
    214  11c5		       20 f5 11 	      jsr	draw_char_in_accumulator
    215  11c8		       60		      rts
    216  11c9
    217  11c9				   check_if_platform
    218  11c9		       c9 70		      cmp	#PLATFORM
    219  11cb		       d0 08		      bne	check_if_key
    220  11cd		       a9 02		      lda	#PLATFORM_CHAR
    221  11cf		       a2 0a		      ldx	#PLATFORM_COLOR
    222  11d1		       20 f5 11 	      jsr	draw_char_in_accumulator
    223  11d4		       60		      rts
    224  11d5
    225  11d5
    226  11d5				   check_if_key
    227  11d5		       c9 80		      cmp	#KEY
    228  11d7		       d0 08		      bne	check_if_spike
    229  11d9		       a9 05		      lda	#KEY_CHAR
    230  11db		       a2 0b		      ldx	#KEY_COLOR
    231  11dd		       20 f5 11 	      jsr	draw_char_in_accumulator
    232  11e0		       60		      rts
    233  11e1
    234  11e1				   check_if_spike
    235  11e1		       c9 90		      cmp	#SPIKE
    236  11e3		       d0 08		      bne	check_if_booster
    237  11e5		       a9 08		      lda	#SPIKE_CHAR
    238  11e7		       a2 02		      ldx	#SPIKE_COLOR
    239  11e9		       20 f5 11 	      jsr	draw_char_in_accumulator
    240  11ec		       60		      rts
    241  11ed
    242  11ed				   check_if_booster
    243  11ed		       a9 09		      lda	#BOOSTER_CHAR
    244  11ef		       a2 0c		      ldx	#BOOSTER_COLOR
    245  11f1		       20 f5 11 	      jsr	draw_char_in_accumulator
    246  11f4		       60		      rts
    247  11f5
    248  11f5
    249  11f5							; char in accumulator goes in screen cursor, color in x register goes in color cursor, then update cursors
    250  11f5
    251  11f5				   draw_char_in_accumulator
    252  11f5		       a0 00		      ldy	#0
    253  11f7		       91 00		      sta	(screen_cursor),y
    254  11f9
    255  11f9		       8a		      txa
    256  11fa		       91 02		      sta	(color_cursor),y
    257  11fc
    258  11fc		       20 78 10 	      jsr	add_one_to_screen_cursor	; add to both screen and color cursor
    259  11ff		       60		      rts
------- FILE src/main.s
------- FILE updateGameState.s LEVEL 2 PASS 3
      0  1200					      include	"updateGameState.s"
      1  1200
      2  1200		       00 01	   MOVE_LEFT  =	1
      3  1200		       00 02	   MOVE_RIGHT =	2
      4  1200		       00 01	   SQUAREBOT_CHAR =	$1
      5  1200		       00 02	   SQUAREBOT_COLOR =	$2
      6  1200		       00 e4	   START_OF_FIRST_ROW_LOW_BYTE =	$e4
      7  1200		       00 1f	   START_OF_FIRST_ROW_HIGH_BYTE =	$1f
      8  1200
      9  1200				   update_game_state
     10  1200		       a5 11		      lda	squarebot_position
     11  1202		       85 0c		      sta	new_position
     12  1204		       a5 12		      lda	squarebot_position+1
     13  1206		       85 0d		      sta	new_position+1
     14  1208		       a5 13		      lda	squarebot_color_position
     15  120a		       85 0e		      sta	new_color_position
     16  120c		       a5 14		      lda	squarebot_color_position+1
     17  120e		       85 0f		      sta	new_color_position+1
     18  1210
     19  1210		       a5 c5		      lda	currently_pressed_key
     20  1212		       c9 11		      cmp	#A_KEY
     21  1214		       d0 06		      bne	check_if_d_pressed
     22  1216		       20 e6 12 	      jsr	move_new_position_to_left
     23  1219		       4c 26 12 	      jmp	check_if_new_position_valid
     24  121c
     25  121c				   check_if_d_pressed
     26  121c		       c9 12		      cmp	#D_KEY
     27  121e		       d0 06		      bne	check_if_new_position_valid
     28  1220		       20 cb 12 	      jsr	move_new_position_to_right
     29  1223		       4c 26 12 	      jmp	check_if_new_position_valid
     30  1226
     31  1226				   check_if_new_position_valid
     32  1226		       a0 00		      ldy	#0
     33  1228		       b1 0c		      lda	(new_position),y
     34  122a		       c9 04		      cmp	#EXIT_CHAR
     35  122c		       d0 04		      bne	continue_level
     36  122e		       20 c4 12 	      jsr	level_has_finished
     37  1231		       60		      rts
     38  1232
     39  1232				   continue_level
     40  1232		       20 42 13 	      jsr	collision_handler
     41  1235		       90 03		      bcc	handle_jump_logic
     42  1237
     43  1237		       20 a6 12 	      jsr	update_squarebot_position
     44  123a
     45  123a				   handle_jump_logic
     46  123a		       a5 17		      lda	jump_remaining	; how many more upward motions for current jump
     47  123c		       c9 00		      cmp	#0
     48  123e		       d0 2d		      bne	handle_jumps_remaining
     49  1240
     50  1240
     51  1240				   handle_no_jumps_remaining		; if no jumps left, then start jump if space is pressed, otherwise just skip and handle gravity
     52  1240		       a5 c5		      lda	currently_pressed_key
     53  1242		       c9 20		      cmp	#SPACE_KEY
     54  1244		       d0 47		      bne	handle_gravity
     55  1246
     56  1246
     57  1246
     58  1246		       20 6d 13 	      jsr	squarebot_on_first_row	; if on first row, we dont care about what character lies below
     59  1249		       b0 0d		      bcs	skip_validity_check
     60  124b
     61  124b							; check if character below is blank; if so dont allow us to set jump_remaining
     62  124b		       a0 16		      ldy	#ROW_SIZE
     63  124d		       b1 11		      lda	(squarebot_position),y
     64  124f
     65  124f		       c9 04		      cmp	#EXIT_CHAR
     66  1251		       f0 71		      beq	level_has_finished
     67  1253
     68  1253		       20 42 13 	      jsr	collision_handler
     69  1256		       b0 35		      bcs	handle_gravity
     70  1258
     71  1258				   skip_validity_check
     72  1258		       a5 16		      lda	has_booster	; if we have the booster, set jump_remaining to twice as high, then get rid of the booster
     73  125a		       c9 01		      cmp	#1
     74  125c		       d0 0b		      bne	regular_jump
     75  125e		       a9 08		      lda	#JUMP_SIZE*2
     76  1260		       85 17		      sta	jump_remaining
     77  1262		       a9 00		      lda	#0
     78  1264		       85 16		      sta	has_booster
     79  1266		       4c 6d 12 	      jmp	handle_jumps_remaining
     80  1269
     81  1269
     82  1269				   regular_jump
     83  1269		       a9 04		      lda	#JUMP_SIZE
     84  126b		       85 17		      sta	jump_remaining
     85  126d
     86  126d				   handle_jumps_remaining
     87  126d		       20 01 13 	      jsr	move_new_position_up
     88  1270		       a0 00		      ldy	#0
     89  1272		       b1 0c		      lda	(new_position),y
     90  1274		       c9 04		      cmp	#EXIT_CHAR
     91  1276		       f0 4c		      beq	level_has_finished
     92  1278
     93  1278		       20 42 13 	      jsr	collision_handler
     94  127b		       90 0b		      bcc	jump_is_invalid
     95  127d
     96  127d		       20 a6 12 	      jsr	update_squarebot_position
     97  1280
     98  1280		       a5 17		      lda	jump_remaining
     99  1282		       38		      sec
    100  1283		       e9 01		      sbc	#1
    101  1285		       85 17		      sta	jump_remaining
    102  1287		       60		      rts		; no gravity effect after moving upwards from jump
    103  1288
    104  1288
    105  1288				   jump_is_invalid
    106  1288		       a9 00		      lda	#0
    107  128a		       85 17		      sta	jump_remaining
    108  128c		       60		      rts
    109  128d
    110  128d				   handle_gravity		; on first row - do nothing
    111  128d		       20 1c 13 	      jsr	move_new_position_down
    112  1290
    113  1290		       20 6d 13 	      jsr	squarebot_on_first_row
    114  1293		       b0 10		      bcs	do_nothing
    115  1295
    116  1295		       a0 00		      ldy	#0
    117  1297		       b1 0c		      lda	(new_position),y
    118  1299
    119  1299		       c9 04		      cmp	#EXIT_CHAR
    120  129b		       f0 27		      beq	level_has_finished
    121  129d
    122  129d		       20 42 13 	      jsr	collision_handler
    123  12a0		       90 03		      bcc	do_nothing
    124  12a2
    125  12a2
    126  12a2		       20 a6 12 	      jsr	update_squarebot_position
    127  12a5
    128  12a5				   do_nothing
    129  12a5		       60		      rts
    130  12a6
    131  12a6				   update_squarebot_position
    132  12a6		       20 37 13 	      jsr	remove_char
    133  12a9							; new positions are valid; set them to current positions
    134  12a9
    135  12a9		       a5 0c		      lda	new_position
    136  12ab		       85 11		      sta	squarebot_position
    137  12ad		       a5 0d		      lda	new_position+1
    138  12af		       85 12		      sta	squarebot_position+1
    139  12b1
    140  12b1		       a5 0e		      lda	new_color_position
    141  12b3		       85 13		      sta	squarebot_color_position
    142  12b5		       a5 0f		      lda	new_color_position+1
    143  12b7		       85 14		      sta	squarebot_color_position+1
    144  12b9
    145  12b9		       a0 00		      ldy	#0
    146  12bb		       a9 01		      lda	#SQUAREBOT_CHAR
    147  12bd		       91 11		      sta	(squarebot_position),y
    148  12bf		       a9 02		      lda	#SQUAREBOT_COLOR
    149  12c1		       91 13		      sta	(squarebot_color_position),y
    150  12c3
    151  12c3		       60		      rts
    152  12c4
    153  12c4				   level_has_finished
    154  12c4		       a9 01		      lda	#1
    155  12c6		       85 09		      sta	level_completed
    156  12c8		       85 08		      sta	level_reset
    157  12ca		       60		      rts
    158  12cb
    159  12cb				   move_new_position_to_right
    160  12cb		       18		      clc
    161  12cc		       a5 0c		      lda	new_position	; load and add to low byte
    162  12ce		       69 01		      adc	#$1
    163  12d0		       85 0c		      sta	new_position
    164  12d2		       a5 0d		      lda	new_position+1
    165  12d4		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
    166  12d6		       85 0d		      sta	new_position+1
    167  12d8		       18		      clc
    168  12d9		       a5 0e		      lda	new_color_position	; load and add to low byte
    169  12db		       69 01		      adc	#$1
    170  12dd		       85 0e		      sta	new_color_position
    171  12df		       a5 0f		      lda	new_color_position+1
    172  12e1		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
    173  12e3		       85 0f		      sta	new_color_position+1
    174  12e5		       60		      rts
    175  12e6
    176  12e6				   move_new_position_to_left
    177  12e6		       38		      sec
    178  12e7		       a5 0c		      lda	new_position
    179  12e9		       e9 01		      sbc	#$1
    180  12eb		       85 0c		      sta	new_position
    181  12ed		       a5 0d		      lda	new_position+1
    182  12ef		       e9 00		      sbc	#$0
    183  12f1		       85 0d		      sta	new_position+1
    184  12f3		       38		      sec
    185  12f4		       a5 0e		      lda	new_color_position
    186  12f6		       e9 01		      sbc	#$1
    187  12f8		       85 0e		      sta	new_color_position
    188  12fa		       a5 0f		      lda	new_color_position+1
    189  12fc		       e9 00		      sbc	#$0
    190  12fe		       85 0f		      sta	new_color_position+1
    191  1300		       60		      rts
    192  1301
    193  1301
    194  1301				   move_new_position_up
    195  1301		       38		      sec
    196  1302		       a5 0c		      lda	new_position
    197  1304		       e9 16		      sbc	#ROW_SIZE
    198  1306		       85 0c		      sta	new_position
    199  1308		       a5 0d		      lda	new_position+1
    200  130a		       e9 00		      sbc	#$0
    201  130c		       85 0d		      sta	new_position+1
    202  130e		       38		      sec
    203  130f		       a5 0e		      lda	new_color_position
    204  1311		       e9 16		      sbc	#ROW_SIZE
    205  1313		       85 0e		      sta	new_color_position
    206  1315		       a5 0f		      lda	new_color_position+1
    207  1317		       e9 00		      sbc	#$0
    208  1319		       85 0f		      sta	new_color_position+1
    209  131b		       60		      rts
    210  131c
    211  131c				   move_new_position_down
    212  131c		       18		      clc
    213  131d		       a5 0c		      lda	new_position	; load and add to low byte
    214  131f		       69 16		      adc	#ROW_SIZE
    215  1321		       85 0c		      sta	new_position
    216  1323		       a5 0d		      lda	new_position+1
    217  1325		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
    218  1327		       85 0d		      sta	new_position+1
    219  1329		       18		      clc
    220  132a		       a5 0e		      lda	new_color_position	; load and add to low byte
    221  132c		       69 16		      adc	#ROW_SIZE
    222  132e		       85 0e		      sta	new_color_position
    223  1330		       a5 0f		      lda	new_color_position+1
    224  1332		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
    225  1334		       85 0f		      sta	new_color_position+1
    226  1336		       60		      rts
    227  1337
    228  1337
    229  1337				   remove_char		; remove squarebot from current screen location
    230  1337		       a0 00		      ldy	#0
    231  1339		       a9 20		      lda	#BLANK_CHAR
    232  133b		       91 11		      sta	(squarebot_position),Y
    233  133d		       a9 01		      lda	#1
    234  133f		       91 13		      sta	(squarebot_color_position),Y
    235  1341		       60		      rts
    236  1342
    237  1342				   collision_handler		; accumulator is the character (the actual character code) in the position that squarebot wants to move to
    238  1342							; set carry flag if we can move to this char, otherwise clear it
    239  1342		       c9 20		      cmp	#BLANK_CHAR
    240  1344		       f0 33		      beq	return_true
    241  1346
    242  1346		       c9 09		      CMP	#BOOSTER_CHAR
    243  1348		       d0 07		      bne	key_check
    244  134a		       a9 01		      lda	#1
    245  134c		       85 16		      sta	has_booster
    246  134e		       4c 79 13 	      jmp	return_true
    247  1351
    248  1351				   key_check
    249  1351		       c9 05		      cmp	#KEY_CHAR
    250  1353		       d0 07		      bne	locked_wall_check
    251  1355		       a9 01		      lda	#1
    252  1357		       85 15		      sta	has_key
    253  1359		       4c 79 13 	      jmp	return_true
    254  135c
    255  135c				   locked_wall_check
    256  135c		       c9 06		      cmp	#LOCKED_WALL_CHAR
    257  135e		       d0 1b		      bne	return_false
    258  1360
    259  1360		       a5 15		      lda	has_key	; if locked wall, but player doesnt have key, cant do anything
    260  1362		       c9 00		      cmp	#0
    261  1364		       f0 15		      beq	return_false
    262  1366
    263  1366		       a9 00		      lda	#0	; but if locked wall and has key, get rid of the locked wall and the key
    264  1368		       85 15		      sta	has_key
    265  136a		       4c 79 13 	      jmp	return_true
    266  136d
    267  136d
    268  136d				   squarebot_on_first_row		; set carry flag to 0 if squarebot_position is on bottom of screen; otherwise set to 1
    269  136d		       a5 12		      lda	squarebot_position+1
    270  136f		       c9 1f		      cmp	#START_OF_FIRST_ROW_HIGH_BYTE
    271  1371		       90 08		      bcc	return_false	; compare high bits; return false if current position high bit is smaller than high bit of leftmost position on first row
    272  1373		       a5 11		      lda	squarebot_position
    273  1375		       c9 e4		      cmp	#START_OF_FIRST_ROW_LOW_BYTE
    274  1377		       90 02		      bcc	return_false
    275  1379
    276  1379				   return_true
    277  1379		       38		      sec
    278  137a		       60		      rts
    279  137b
    280  137b				   return_false
    281  137b		       18		      clc
    282  137c		       60		      rts
    283  137d
    284  137d
    285  137d							;plan for attachable powerups
    286  137d							;5 variables to store the 5 tiles the player is on: tileU, tileD, tileR, tileL, tileM
    287  137d							;maybe combine to save space?
    288  137d							;4 characters to store each powerup spot: charU, charD, charR, charL
    289  137d							;1 variable to store character's current powerups: attached_powerups
    290  137d
    291  137d							;when moving the character right: ASSUMING THIS DOESN'T FLICKER
    292  137d							;  delete L, U and D and draw original tiles there
    293  137d							;  tileU = new, tileD = new, tileL = tileM, tileM = tileR, tileR = new
    294  137d							;  update chars
    295  137d							;  draw chars in the new place
    296  137d							;same deal for moving in any direction
    297  137d
    298  137d
    299  137d							;for moving while jumping, something about register 028C which counts down until a refresh on the button or something
    300  137d
    301  137d
    302  137d							;this is for drawing the attachable powerup.
    303  137d							;first draw the tile onto the character
    304  137d
    305  137d							;set x to the address of the attachment
    306  137d							;set y to 1
    307  137d							;go to nestedloop
    308  137d
    309  137d							;outerloop:
    310  137d							;if y && 128 = 1 end loop
    311  137d							;otherwise shift y right 1
    312  137d							;run nestedloop
    313  137d
    314  137d							;nestedloop:
    315  137d							;lda [character_set_begin+[16*8]]^[[character_set_begin+[16*8]]&arithTemp]
    316  137d
    317  137d							;target row = targetrow ^ [x & y]
    318  137d							;go through each row at x, check if x && y = 1
    319  137d							;if yes, XOR the correct bit on the character with 1 I think xor is ^
    320  137d							;if the loop is done go to outerloop
    321  137d							;otherwise nestedloop
    322  137d
    323  137d
    324  137d							;option 2:
    325  137d
    326  137d							;store each row of charL ^ powerup in tempArith
    327  137d							;load tempArith into accumulator and store it in charL
    328  137d							;clear tempArith
    329  137d
    330  137d							;so
    331  137d							;for each a=1 a<<1 a < 129
    332  137d							;and charL
    333  137d
    334  137d							;I don't think there is a generalized way to do this
    335  137d							;it has to be brute force, unique for each direction i think
    336  137d							;there is no simple way to store the fact that a bit is 1 and dynamically figure out how to change the character accordingly
    337  137d							;unless?
    338  137d
    339  137d
    340  137d
    341  137d							;variables: position (first 4 bits are byte position, second 4 bits are bit position)
    342  137d							;good gosh you can't shift accumulator multiple bits at a time.
    343  137d
    344  137d							;check each bit of the attachment, if its 1 set accumulator to 1 - nested for loop
    345  137d							;go to directional implementation
    346  137d
    347  137d							;right
    348  137d							;shift accumulator to the correct bit - for loop since accumulator only shifts 1 bit at a time
    349  137d							; ldx -1
    350  137d							;shiftloop:
    351  137d							; inx
    352  137d							; asl
    353  137d							; cpx [position>>4]%16
    354  137d							; bne shiftloop
    355  137d
    356  137d							;eor accumulator with the correct row in charR - EOR charR+[position%16]
    357  137d							;increase position
    358  137d
    359  137d							;
    360  137d
    361  137d							;lets figure out the rest of the logic.
    362  137d
    363  137d
    364  137d
    365  137d
    366  137d							;feedback:
    367  137d							;more intermediate levels
    368  137d							;jump left and jump right (uncontrollable jump movement)
    369  137d							;better colored powerups
    370  137d							;tutorial text
    371  137d							;jumping animation? change his face.
------- FILE src/main.s
    142  137d
    143  137d				   compressed_screen_data_start
    144  137d					      incbin	"../data/titleScreenData_compressed"	; got via 'bsave ""'
    145  13e5
    146  13e5				   level_data_start
    147  13e5					      incbin	"../data/levels/binary_levels/1"
    148  13ed					      incbin	"../data/levels/binary_levels/booster_test"
    149  13fb					      incbin	"../data/levels/binary_levels/key_test"
    150  1411					      incbin	"../data/levels/binary_levels/2"
    151  1429					      incbin	"../data/levels/binary_levels/3"
    152  1481					      incbin	"../data/levels/binary_levels/4"
    153  14ad					      incbin	"../data/levels/binary_levels/5"
    154  14d9					      incbin	"../data/levels/binary_levels/6"
    155  150b
------- FILE memoryCheck.s LEVEL 2 PASS 3
      0  150b					      include	"memoryCheck.s"	; code to make sure the program isn't too large and enters screen memory
      1  150b		       05 0a	   BYTES_USED =	.-$1001	; location counter minus starting location = total bytes used
      2  150b		       1e 00	   SCREEN_MEMORY_START =	$1e00
 1290 bytes used
      3  150b					      echo	[BYTES_USED]d, "bytes used"
 Ending program at memory location (base 10):  5387
      4  150b					      echo	"Ending program at memory location (base 10): ", [.]d
      5  150b				  -	      if	. >= SCREEN_MEMORY_START	; if program entering screen memory
      6  150b				  -	      echo	"Throwing error because program is too large, and has entered screen memory!"
      7  150b				  -	      err
      8  150b					      endif
------- FILE src/main.s
    157  150b
    158  150b
    159  1c00					      org	character_set_begin
    160  1c00		       7e 42 7e 42*	      BYTE.b	$7E, $42, $7E, $42, $7E, $42, $7E, $42	; ladder 0
    161  1c08		       ff 81 a5 81*	      BYTE.b	$FF, $81, $A5, $81, $BD, $81, $81, $FF	; squarebot 1
    162  1c10		       ff 5a 00 00*	      BYTE.b	$FF, $5A, $00, $00, $00, $00, $00, $00	; platform 2
    163  1c18		       ff ff ff ff*	      BYTE.b	$FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF	; wall 3
    164  1c20		       ff 9d a3 ac*	      BYTE.b	$FF, $9D, $A3, $AC, $A5, $99, $C3, $FF	; exit (door) 4
    165  1c28		       3c 42 99 99*	      BYTE.b	$3C, $42, $99, $99, $91, $99, $42, $3C	; key powerup 5
    166  1c30		       ff ff c3 c3*	      BYTE.b	$FF, $FF, $C3, $C3, $E7, $E7, $E7, $FF	; locked wall 6
    167  1c38		       ff ee f1 ef*	      BYTE.b	$FF, $EE, $F1, $EF, $57, $8F, $F3, $FF	; breakable wall 7
    168  1c40		       3c 42 91 99*	      BYTE.b	$3C, $42, $91, $99, $BD, $81, $42, $3C	; spike 8
    169  1c48		       3c 42 99 bd*	      BYTE.b	$3C, $42, $99, $BD, $89, $91, $42, $3C	; booster powerup 9
    170  1c50		       80 c0 f0 fe*	      BYTE.b	$80, $C0, $F0, $FE, $F0, $C0, $80, $00	; spike attachment (R)
    171  1c58		       08 38 f0 fd*	      BYTE.b	$08, $38, $F0, $FD, $FA, $F0, $38, $08	; booster attachment (R)
    172  1c60		       00 00 fe fe*	      BYTE.b	$00, $00, $FE, $FE, $6A, $0A, $0E, $00	; key attachment (R)
    173  1c68		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; charU
    174  1c70		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; charD
    175  1c78		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; charL
    176  1c80		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; charR
    177  1c88
    178  1c88							; there appears to be no simple way to turn the characters
    179  1c88							; but its still worth since storing 24 more bytes for each powerup probably takes more space than brute force flip/rotate array.
