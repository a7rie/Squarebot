------- FILE src/main.s LEVEL 1 PASS 3
      1  133c ????						; title screen program -- use hand-made compression method (esentially just RLE, see rleEncoding.py)
      2  133c ????				      processor	6502
      3  133c ????
      4 U000f ????				      seg.u	ZP
      5 U0000					      org	$0
      6 U0000
      7 U0000
      8 U0000		       00 00	   screen_cursor ds.w	1	; stores the current screen memory address
      9 U0002		       00 00	   color_cursor ds.w	1	; store current color memory address
     10 U0004		       00 00	   current_level ds.w	1
     11 U0006		       00 00	   next_level ds.w	1
     12 U0008		       00	   level_reset ds.b	1
     13 U0009		       00	   level_completed ds.b	1
     14 U000a		       00	   level_data_index ds.b	1	; for temporarily saving index registers
     15 U000b		       00	   temp       ds.b	1	; for temporarily saving index registers
     16 U000c		       00 00 00    current_time ds	3	; store only the last byte of the jiffy clock
     17 U000f
     18  133c ????				      seg
     19  133c ????
     20  133c ????						; constants
     21  133c ????	       00 20	   BLANK_CHAR =	$20
     22  133c ????
     23  133c ????	       00 00	   SCREEN_CURSOR_BEGINNING_LOW_BYTE =	$00
     24  133c ????	       00 1e	   SCREEN_CURSOR_BEGINNING_HIGH_BYTE =	$1e
     25  133c ????
     26  133c ????						; last screen location
     27  133c ????	       00 fa	   END_OF_SCREEN_LOW_BYTE =	$fa
     28  133c ????	       00 1f	   END_OF_SCREEN_HIGH_BYTE =	$1f
     29  133c ????
     30  133c ????						; beginning of color memory
     31  133c ????	       00 00	   COLOR_CURSOR_BEGINNING_LOW_BYTE =	$00
     32  133c ????	       00 96	   COLOR_CURSOR_BEGINNING_HIGH_BYTE =	$96
     33  133c ????	       00 02	   RED_COLOR_CODE =	2
     34  133c ????	       00 20	   SPACE_KEY  =	$20
     35  133c ????
     36  133c ????	       00 0d	   SECRET_KEY =	$0d	; translates to "P"
     37  133c ????
     38  133c ????						; memory locations
     39  133c ????	       10 01	   user_memory_start =	$1001
     40  133c ????	       00 c5	   currently_pressed_key =	$c5
     41  133c ????	       00 a0	   jiffy_clock =	$A0
     42  133c ????
     43  133c ????
     44  133c ????
     45  133c ????						; begin location counter at 4096 (user memory)
     46  1001					      org	user_memory_start
------- FILE stub.s LEVEL 2 PASS 3
      0  1001					      include	"stub.s"	; stub contains BASIC sys cmd to run the machine language code
      1  1001		       00 9e	   SYS_CMD_TOKEN =	$9e
      2  1001		       00 0a	   STUB_LINE_NUMBER =	10
      3  1001							; BASIC stub -- SYS cmd to run machine language 
      4  1001		       0b 10		      dc.w	nextstmt	; link; beginning of basic
      5  1003		       0a 00		      dc.w	STUB_LINE_NUMBER	; line number 
      6  1005		       9e 34 31 30*	      dc.b	SYS_CMD_TOKEN, [start]d, 0	; token for sys with operand as address to "start" label
      7  100b				   nextstmt
      8  100b		       00 00		      dc.w	0
------- FILE src/main.s
     48  100d
     49  100d				   start
     50  100d							; initialize some variables in the zero page
     51  100d		       a9 01		      lda	#1
     52  100f		       85 08		      sta	level_reset
     53  1011		       a9 00		      lda	#0
     54  1013		       85 09		      sta	level_completed
     55  1015
     56  1015		       a9 2c		      lda	#<level_data_start
     57  1017		       85 04		      sta	current_level
     58  1019		       a9 12		      lda	#>level_data_start
     59  101b		       85 05		      sta	current_level+1
     60  101d
     61  101d		       a9 00		      lda	#0
     62  101f
     63  101f
------- FILE titleScreen.s LEVEL 2 PASS 3
      0  101f					      include	"titleScreen.s"
      1  101f				   display_title_screen
      2  101f		       a9 00		      lda	#SCREEN_CURSOR_BEGINNING_LOW_BYTE
      3  1021		       85 00		      sta	screen_cursor
      4  1023		       a9 1e		      lda	#SCREEN_CURSOR_BEGINNING_HIGH_BYTE	; store 1e in location 01
      5  1025		       85 01		      sta	screen_cursor+1
      6  1027
      7  1027		       a9 00		      lda	#COLOR_CURSOR_BEGINNING_LOW_BYTE
      8  1029		       85 02		      sta	color_cursor
      9  102b		       a9 96		      lda	#COLOR_CURSOR_BEGINNING_HIGH_BYTE
     10  102d		       85 03		      sta	color_cursor+1
     11  102f
     12  102f		       a0 00		      ldy	#$0	; to use for indirect indexed addressing
     13  1031		       a2 00		      ldx	#$0
     14  1033
     15  1033		       20 3f 10 	      jsr	draw_title_screen_loop
     16  1036
     17  1036				   infinite_loop
     18  1036		       a5 c5		      lda	currently_pressed_key
     19  1038		       c9 20		      cmp	#SPACE_KEY
     20  103a		       f0 59		      beq	gameLoop
     21  103c		       4c 36 10 	      jmp	infinite_loop
     22  103f
     23  103f
     24  103f				   draw_title_screen_loop
     25  103f		       bd c4 11 	      lda	compressed_screen_data_start,X	; accumulator stores num times to repeat the byte
     26  1042		       20 4d 10 	      jsr	draw_character	; draw the character that many times
     27  1045		       e8		      inx
     28  1046		       e8		      inx
     29  1047		       20 85 10 	      jsr	check_if_screen_cursor_at_end
     30  104a		       90 f3		      bcc	draw_title_screen_loop
     31  104c		       60		      rts
     32  104d
     33  104d
     34  104d							; draw the character in Y register for (value of accumulator) number of times
     35  104d				   draw_character
     36  104d							; if accumulator == 0, return; otherwise, subtract 1 from accumulator and continue drawing the letter at Y
     37  104d		       f0 1a		      beq	draw_character_end
     38  104f		       38		      sec
     39  1050		       e9 01		      sbc	#1
     40  1052		       48		      pha		; push accumulator onto stack
     41  1053
     42  1053							; store current char at screen cursor location
     43  1053		       a0 00		      ldy	#0
     44  1055		       bd c5 11 	      lda	compressed_screen_data_start+1,X	; load cur char to draw
     45  1058		       91 00		      sta	(screen_cursor),Y	; draw it on screen
     46  105a
     47  105a							; add color to the screen location if it's not a space
     48  105a							; because our title screen only has one color, and only displays it for characters that arent space, we can get away with this "optimization",
     49  105a							; and avoid adding color data
     50  105a		       c9 20		      cmp	#BLANK_CHAR
     51  105c		       f0 04		      beq	dont_color
     52  105e		       a9 02		      lda	#RED_COLOR_CODE
     53  1060		       91 02		      sta	(color_cursor),Y
     54  1062
     55  1062				   dont_color
     56  1062		       20 6a 10 	      jsr	add_one_to_screen_cursor
     57  1065		       68		      pla		; put the current 'count' (remaining times to draw character) back on accumulator
     58  1066		       4c 4d 10 	      jmp	draw_character
     59  1069
     60  1069				   draw_character_end
     61  1069		       60		      rts
     62  106a
     63  106a
     64  106a
     65  106a				   add_one_to_screen_cursor
     66  106a		       18		      clc
     67  106b		       a5 00		      lda	screen_cursor	; load and add to low byte
     68  106d		       69 01		      adc	#$1
     69  106f		       85 00		      sta	screen_cursor
     70  1071		       a5 01		      lda	screen_cursor+1
     71  1073		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
     72  1075		       85 01		      sta	screen_cursor+1
     73  1077
     74  1077							; add to color cursor as well
     75  1077		       18		      clc
     76  1078		       a5 02		      lda	color_cursor	; load and add to low byte
     77  107a		       69 01		      adc	#$1
     78  107c		       85 02		      sta	color_cursor
     79  107e		       a5 03		      lda	color_cursor+1
     80  1080		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
     81  1082		       85 03		      sta	color_cursor+1
     82  1084		       60		      rts
     83  1085
     84  1085				   check_if_screen_cursor_at_end		; set carry flag if screen_cursor at position $1ff9 (8185
     85  1085		       a5 00		      lda	screen_cursor	; load value at screen_cursor low byte
     86  1087		       c9 fa		      cmp	#END_OF_SCREEN_LOW_BYTE
     87  1089		       d0 06		      bne	check_if_screen_cursor_at_end_return_false	; if low byte doesnt match, return with carry flag as neg
     88  108b
     89  108b		       a5 01		      lda	screen_cursor+1
     90  108d		       c9 1f		      cmp	#END_OF_SCREEN_HIGH_BYTE
     91  108f		       f0 02		      beq	check_if_screen_cursor_at_end_return_true	; if high byte matches, set carry flag
     92  1091
     93  1091				   check_if_screen_cursor_at_end_return_false
     94  1091		       18		      clc
     95  1092		       60		      rts
     96  1093
     97  1093				   check_if_screen_cursor_at_end_return_true
     98  1093		       38		      sec
     99  1094		       60		      rts
------- FILE src/main.s
     65  1095
     66  1095
     67  1095							; title screen code jumps here once space pressed
     68  1095				   gameLoop
     69  1095		       20 c9 10 	      jsr	update_level
     70  1098		       a9 00		      lda	#0
     71  109a		       85 08		      sta	level_reset
     72  109c
     73  109c		       20 ba 10 	      jsr	check_for_secret_key
     74  109f		       20 b1 10 	      jsr	wait_until_next_frame
     75  10a2		       20 b1 10 	      jsr	wait_until_next_frame
     76  10a5		       20 b1 10 	      jsr	wait_until_next_frame
     77  10a8		       20 b1 10 	      jsr	wait_until_next_frame
     78  10ab		       20 b1 10 	      jsr	wait_until_next_frame
     79  10ae		       4c 95 10 	      JMP	gameLoop
     80  10b1
     81  10b1
     82  10b1				   wait_until_next_frame		; wait one jiffy before completing game loop
     83  10b1		       a5 a2		      lda	jiffy_clock+2
     84  10b3		       c5 0c		      cmp	current_time
     85  10b5		       f0 fa		      beq	wait_until_next_frame
     86  10b7		       85 0c		      sta	current_time
     87  10b9		       60		      rts
     88  10ba
     89  10ba							; update level_completed and level_reset if secret_key pressed
     90  10ba				   check_for_secret_key
     91  10ba		       a5 c5		      lda	currently_pressed_key
     92  10bc		       c9 0d		      cmp	#SECRET_KEY
     93  10be		       d0 08		      bne	check_for_secret_key_return
     94  10c0		       a9 01		      lda	#1
     95  10c2		       85 09		      sta	level_completed
     96  10c4		       a9 01		      lda	#1
     97  10c6		       85 08		      sta	level_reset
     98  10c8
     99  10c8				   check_for_secret_key_return
    100  10c8		       60		      rts
    101  10c9
------- FILE updateLevel.s LEVEL 2 PASS 3
      0  10c9					      include	"updateLevel.s"
      1  10c9		       00 01	   LEVEL_IS_DONE =	1
      2  10c9		       00 00	   LEVEL_NOT_DONE =	0
      3  10c9		       00 01	   SHOULD_RESET =	1
      4  10c9		       00 00	   SHOULD_NOT_RESET =	0
      5  10c9
      6  10c9							; only first 4 bits really matter here; refer to readme for guide on lvl format
      7  10c9		       00 00	   BLANK_SPACE =	0	; 000000000
      8  10c9		       00 10	   STARTING_POINT =	16	; 00010000
      9  10c9		       00 20	   WALL       =	32	; 00100000
     10  10c9		       00 30	   BREAKABLE_WALL =	48	; 00110000
     11  10c9		       00 40	   LOCKED_WALL =	64	; 01000000
     12  10c9		       00 50	   LADDER     =	80	; 01010000
     13  10c9		       00 60	   EXIT       =	96	; 01100000
     14  10c9		       00 70	   PLATFORM   =	112	; 01110000
     15  10c9		       00 80	   KEY	      =	128	; 10000000
     16  10c9		       00 90	   SPIKE      =	144	; 10010000
     17  10c9		       00 a0	   BOOSTER    =	160	;  10100000
     18  10c9
     19  10c9		       00 00	   WALL_COLOR =	0
     20  10c9		       00 00	   BREAKABLE_WALL_COLOR =	0
     21  10c9		       00 00	   LOCKED_WALL_COLOR =	0
     22  10c9		       00 00	   LADDER_COLOR =	0
     23  10c9		       00 00	   EXIT_COLOR =	0
     24  10c9		       00 00	   PLATFORM_COLOR =	0
     25  10c9		       00 00	   KEY_COLOR  =	0
     26  10c9		       00 00	   SPIKE_COLOR =	0
     27  10c9		       00 00	   BOOSTER_COLOR =	0
     28  10c9
     29  10c9		       00 20	   BLANK_SPACE_CHAR =	$20
     30  10c9		       00 17	   WALL_CHAR  =	'W-64
     31  10c9		       00 14	   BREAKABLE_WALL_CHAR =	'T-64
     32  10c9		       00 0c	   LOCKED_WALL_CHAR =	'L-64
     33  10c9		       00 23	   LADDER_CHAR =	$23
     34  10c9		       00 05	   EXIT_CHAR  =	'E-64
     35  10c9		       00 64	   PLATFORM_CHAR =	$64
     36  10c9		       00 0b	   KEY_CHAR   =	'K-64
     37  10c9		       00 13	   SPIKE_CHAR =	'S-64
     38  10c9		       00 02	   BOOSTER_CHAR =	'B-64
     39  10c9
     40  10c9
     41  10c9				   update_level
     42  10c9							; check if the level is completed; set current_level to next_level if so
     43  10c9		       a5 09		      lda	level_completed
     44  10cb		       c9 01		      cmp	#LEVEL_IS_DONE	; (try optimizing later)
     45  10cd		       d0 0c		      bne	dont_update
     46  10cf
     47  10cf							; level is done; reset level completed
     48  10cf		       a9 00		      lda	#LEVEL_NOT_DONE
     49  10d1		       85 09		      sta	level_completed
     50  10d3
     51  10d3							; now set current_level to next_level
     52  10d3		       a5 06		      lda	next_level
     53  10d5		       85 04		      sta	current_level
     54  10d7		       a5 07		      lda	next_level+1
     55  10d9		       85 05		      sta	current_level+1
     56  10db
     57  10db				   dont_update
     58  10db							; now check if level reset was set
     59  10db		       a5 08		      lda	level_reset
     60  10dd		       c9 00		      cmp	#0
     61  10df		       d0 01		      bne	continue_update	; if not, go back to game loop
     62  10e1		       60		      rts
     63  10e2
     64  10e2				   continue_update
     65  10e2							; if it was, update the level
     66  10e2		       a9 00		      lda	#SCREEN_CURSOR_BEGINNING_LOW_BYTE
     67  10e4		       85 00		      sta	screen_cursor
     68  10e6		       a9 1e		      lda	#SCREEN_CURSOR_BEGINNING_HIGH_BYTE
     69  10e8		       85 01		      sta	screen_cursor+1
     70  10ea
     71  10ea		       a9 00		      lda	#COLOR_CURSOR_BEGINNING_LOW_BYTE
     72  10ec		       85 02		      sta	color_cursor
     73  10ee		       a9 96		      lda	#COLOR_CURSOR_BEGINNING_HIGH_BYTE
     74  10f0		       85 03		      sta	color_cursor+1
     75  10f2
     76  10f2		       a2 00		      ldx	#0
     77  10f4		       a0 00		      ldy	#0
     78  10f6		       84 0a		      sty	level_data_index
     79  10f8							; draw (or redraw) the current level
     80  10f8				   draw_level_loop
     81  10f8							; y stores our index in the current level data
     82  10f8		       a4 0a		      ldy	level_data_index
     83  10fa		       b1 04		      lda	(current_level),y	; accumulator stores the number of times to repeat the next byte  
     84  10fc
     85  10fc		       20 18 11 	      jsr	draw_sequence
     86  10ff
     87  10ff		       a4 0a		      ldy	level_data_index
     88  1101		       c8		      iny		; set y to point to next length byte (iterate 2 at a time)
     89  1102		       c8		      iny
     90  1103		       84 0a		      sty	level_data_index
     91  1105
     92  1105
     93  1105		       20 85 10 	      jsr	check_if_screen_cursor_at_end
     94  1108		       90 ee		      bcc	draw_level_loop
     95  110a
     96  110a
     97  110a							; update next level pointer to point to byte after current level
     98  110a		       a5 04		      lda	current_level
     99  110c		       18		      clc
    100  110d		       65 0a		      adc	level_data_index
    101  110f		       85 06		      sta	next_level
    102  1111		       a5 05		      lda	current_level+1
    103  1113		       69 00		      adc	#0
    104  1115		       85 07		      sta	next_level+1
    105  1117		       60		      rts
    106  1118
    107  1118
    108  1118
    109  1118							; i love writing decompression code in assembly. i love writing decompression code in assembly. i love writing decompression code in assembly. 
    110  1118				   draw_sequence
    111  1118							; if acc == 0, return; otherwise subtract 1, draw the next 2 chars
    112  1118		       f0 1c		      beq	draw_sequence_end
    113  111a		       38		      sec
    114  111b		       e9 01		      sbc	#1
    115  111d		       48		      pha		; push accumulator onto stack
    116  111e
    117  111e		       a4 0a		      ldy	level_data_index
    118  1120		       c8		      iny		; (so we can access the "element" byte after the length byte)
    119  1121		       b1 04		      lda	(current_level),y	; get formatted byte (see squarebot doc)
    120  1123		       0a		      asl		; lol
    121  1124		       0a		      asl
    122  1125		       0a		      asl
    123  1126		       0a		      asl
    124  1127		       20 37 11 	      jsr	draw_high_bits	; draw char represented by the 4 high bits
    125  112a
    126  112a		       a4 0a		      ldy	level_data_index
    127  112c		       c8		      iny
    128  112d
    129  112d		       b1 04		      lda	(current_level),y
    130  112f		       20 37 11 	      jsr	draw_high_bits
    131  1132
    132  1132		       68		      pla
    133  1133		       4c 18 11 	      jmp	draw_sequence
    134  1136
    135  1136				   draw_sequence_end
    136  1136		       60		      rts
    137  1137
    138  1137
    139  1137							; put the character in the high 4 bits of accumulator on screen (see readme), and move the color and screen cursors ahead
    140  1137				   draw_high_bits
    141  1137		       29 f0		      and	#240	; shave off last 4 bits
    142  1139
    143  1139		       c9 00		      cmp	#BLANK_SPACE
    144  113b		       d0 08		      bne	check_if_starting_point
    145  113d		       a9 20		      lda	#BLANK_SPACE_CHAR	; todo; replace with actual chars
    146  113f		       a2 01		      ldx	#1
    147  1141		       20 b9 11 	      jsr	draw_char_in_accumulator
    148  1144		       60		      rts
    149  1145
    150  1145				   check_if_starting_point
    151  1145		       c9 10		      cmp	#STARTING_POINT
    152  1147		       d0 08		      bne	check_if_wall
    153  1149		       a9 30		      lda	#0+48	; fix later will need to update squarre bot position
    154  114b		       a2 00		      ldx	#0
    155  114d		       20 b9 11 	      jsr	draw_char_in_accumulator
    156  1150		       60		      rts
    157  1151
    158  1151				   check_if_wall
    159  1151		       c9 20		      cmp	#WALL
    160  1153		       d0 08		      bne	check_if_breakable_wall
    161  1155		       a9 17		      lda	#WALL_CHAR
    162  1157		       a2 00		      ldx	#WALL_COLOR
    163  1159		       20 b9 11 	      jsr	draw_char_in_accumulator
    164  115c		       60		      rts
    165  115d
    166  115d				   check_if_breakable_wall
    167  115d		       c9 30		      cmp	#BREAKABLE_WALL
    168  115f		       d0 08		      bne	check_if_locked_wall
    169  1161		       a9 14		      lda	#BREAKABLE_WALL_CHAR
    170  1163		       a2 00		      ldx	#BREAKABLE_WALL_COLOR
    171  1165		       20 b9 11 	      jsr	draw_char_in_accumulator
    172  1168		       60		      rts
    173  1169
    174  1169				   check_if_locked_wall
    175  1169		       c9 40		      cmp	#LOCKED_WALL
    176  116b		       d0 08		      bne	check_if_ladder
    177  116d		       a9 0c		      lda	#LOCKED_WALL_CHAR
    178  116f		       a2 00		      ldx	#LOCKED_WALL_COLOR
    179  1171		       20 b9 11 	      jsr	draw_char_in_accumulator
    180  1174		       60		      rts
    181  1175
    182  1175				   check_if_ladder
    183  1175		       c9 50		      cmp	#LADDER
    184  1177		       d0 08		      bne	check_if_exit
    185  1179		       a9 23		      lda	#LADDER_CHAR
    186  117b		       a2 00		      ldx	#LADDER_COLOR
    187  117d		       20 b9 11 	      jsr	draw_char_in_accumulator
    188  1180		       60		      rts
    189  1181
    190  1181				   check_if_exit
    191  1181		       c9 60		      cmp	#EXIT
    192  1183		       d0 08		      bne	check_if_platform
    193  1185		       a9 05		      lda	#EXIT_CHAR
    194  1187		       a2 00		      ldx	#EXIT_COLOR
    195  1189		       20 b9 11 	      jsr	draw_char_in_accumulator
    196  118c		       60		      rts
    197  118d
    198  118d				   check_if_platform
    199  118d		       c9 70		      cmp	#PLATFORM
    200  118f		       d0 08		      bne	check_if_key
    201  1191		       a9 64		      lda	#PLATFORM_CHAR
    202  1193		       a2 00		      ldx	#PLATFORM_COLOR
    203  1195		       20 b9 11 	      jsr	draw_char_in_accumulator
    204  1198		       60		      rts
    205  1199
    206  1199
    207  1199				   check_if_key
    208  1199		       c9 80		      cmp	#KEY
    209  119b		       d0 08		      bne	check_if_spike
    210  119d		       a9 0b		      lda	#KEY_CHAR
    211  119f		       a2 00		      ldx	#KEY_COLOR
    212  11a1		       20 b9 11 	      jsr	draw_char_in_accumulator
    213  11a4		       60		      rts
    214  11a5
    215  11a5				   check_if_spike
    216  11a5		       c9 90		      cmp	#SPIKE
    217  11a7		       d0 08		      bne	check_if_booster
    218  11a9		       a9 13		      lda	#SPIKE_CHAR
    219  11ab		       a2 00		      ldx	#SPIKE_COLOR
    220  11ad		       20 b9 11 	      jsr	draw_char_in_accumulator
    221  11b0		       60		      rts
    222  11b1
    223  11b1				   check_if_booster
    224  11b1		       a9 02		      lda	#BOOSTER_CHAR
    225  11b3		       a2 00		      ldx	#BOOSTER_COLOR
    226  11b5		       20 b9 11 	      jsr	draw_char_in_accumulator
    227  11b8		       60		      rts
    228  11b9
    229  11b9
    230  11b9							; char in accumulator goes in screen cursor, color in x register goes in color cursor, then update cursors
    231  11b9
    232  11b9				   draw_char_in_accumulator
    233  11b9		       a0 00		      ldy	#0
    234  11bb		       91 00		      sta	(screen_cursor),y
    235  11bd
    236  11bd		       8a		      txa
    237  11be		       91 02		      sta	(color_cursor),y
    238  11c0
    239  11c0		       20 6a 10 	      jsr	add_one_to_screen_cursor	; add to both screen and color cursor
    240  11c3		       60		      rts
------- FILE src/main.s
    103  11c4
    104  11c4
    105  11c4				   compressed_screen_data_start
    106  11c4					      incbin	"../data/titleScreenData_compressed"	; got via 'bsave ""'
    107  122c
    108  122c				   level_data_start
    109  122c					      incbin	"../data/levels/binary_levels/1"
    110  127a					      incbin	"../data/levels/binary_levels/2"
    111  12c8					      incbin	"../data/levels/binary_levels/3"
    112  12f6					      incbin	"../data/levels/binary_levels/4"
    113  133c
------- FILE memoryCheck.s LEVEL 2 PASS 3
      0  133c					      include	"memoryCheck.s"	; code to make sure the program isn't too large and enters screen memory
      1  133c		       03 3b	   BYTES_USED =	.-$1001	; location counter minus starting location = total bytes used
      2  133c		       1e 00	   SCREEN_MEMORY_START =	$1e00
 827 bytes used
      3  133c					      echo	[BYTES_USED]d, "bytes used"
 Ending program at memory location (base 10):  4924
      4  133c					      echo	"Ending program at memory location (base 10): ", [.]d
      5  133c				  -	      if	. >= SCREEN_MEMORY_START	; if program entering screen memory
      6  133c				  -	      echo	"Throwing error because program is too large, and has entered screen memory!"
      7  133c				  -	      err
      8  133c					      endif
------- FILE src/main.s
