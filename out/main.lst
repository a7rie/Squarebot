------- FILE src/main.s LEVEL 1 PASS 4
      1  1c98 ????						; title screen program -- use hand-made compression method (esentially just RLE, see rleEncoding.py)
      2  1c98 ????				      processor	6502
      3  1c98 ????
      4 U0021 ????				      seg.u	ZP
      5 U0000					      org	$0
      6 U0000
      7 U0000
      8 U0000		       00 00	   screen_cursor ds.w	1	; stores the current screen memory address
      9 U0002		       00 00	   color_cursor ds.w	1	; store current color memory address
     10 U0004		       00 00	   current_level ds.w	1
     11 U0006		       00 00	   next_level ds.w	1
     12 U0008		       00	   level_reset ds.b	1
     13 U0009		       00	   level_completed ds.b	1
     14 U000a		       00	   level_data_index ds.b	1	; for temporarily saving index registers
     15 U000b		       00 00	   new_position ds.w	1	; use to store position of (proposed) new location for squarebot
     16 U000d		       00 00	   new_color_position ds.w	1	; use to store position of (proposed) new location for squarebot
     17 U000f		       00	   current_time ds.b	1	; store only the last byte of the jiffy clock
     18 U0010		       00 00	   squarebot_position ds.w	1
     19 U0012		       00 00	   squarebot_color_position ds.w	1
     20 U0014		       00	   has_key    ds.b	1
     21 U0015		       00	   has_booster ds.b	1
     22 U0016		       00	   jump_remaining ds.b	1	; number of times the character should continue to move upwards in the current jump
     23 U0017		       00 00 00    tileStore  ds.b	3	; UUUUDDDD LLLLRRRR 0000MMMM
     24 U001a							;colorStore ds.b 3 ; 0UUU0DDD 0LLL0RRR 00000MMM   not the most efficient storage but it needs to also be efficient to decompress
     25 U001a		       00 00	   attached_powerups ds.w	1	; 4 bits for each side, ordered U,D,L,R. 0=none 1=boost 2=activeBoost 3=key 4=spike 5=shield
     26 U001c		       00 00	   temp       ds.w	1	; for temporary storage of things. mainly used in updateGameState
     27 U001e		       00 00 00    charandr   ds.b	3	; for the incredibly complex operation of anding chars
     28  1c98 ????				      seg
     29  1c98 ????
     30  1c98 ????						; constants
     31  1c98 ????	       00 20	   BLANK_CHAR =	$20
     32  1c98 ????
     33  1c98 ????	       00 00	   SCREEN_CURSOR_BEGINNING_LOW_BYTE =	$00
     34  1c98 ????	       00 1e	   SCREEN_CURSOR_BEGINNING_HIGH_BYTE =	$1e
     35  1c98 ????
     36  1c98 ????						; last screen location
     37  1c98 ????	       00 fa	   END_OF_SCREEN_LOW_BYTE =	$fa
     38  1c98 ????	       00 1f	   END_OF_SCREEN_HIGH_BYTE =	$1f
     39  1c98 ????
     40  1c98 ????						; beginning of color memory
     41  1c98 ????	       00 00	   COLOR_CURSOR_BEGINNING_LOW_BYTE =	$00
     42  1c98 ????	       00 96	   COLOR_CURSOR_BEGINNING_HIGH_BYTE =	$96
     43  1c98 ????	       00 00	   RED_COLOR_CODE =	0
     44  1c98 ????
     45  1c98 ????	       00 20	   SPACE_KEY  =	$20
     46  1c98 ????	       00 09	   W_KEY      =	$09
     47  1c98 ????	       00 11	   A_KEY      =	$11
     48  1c98 ????	       00 29	   S_KEY      =	$29
     49  1c98 ????	       00 12	   D_KEY      =	$12
     50  1c98 ????	       00 0d	   SECRET_KEY =	$0d	; press P to skip to next  level
     51  1c98 ????	       00 0a	   RESET_KEY  =	$0a	; press R to restart level i assume
     52  1c98 ????	       00 03	   JUMP_SIZE  =	$3	; number of characters a jump causes
     53  1c98 ????	       00 16	   ROW_SIZE   =	$16
     54  1c98 ????						; memory locations
     55  1c98 ????	       10 01	   user_memory_start =	$1001
     56  1c98 ????	       00 c5	   currently_pressed_key =	$c5
     57  1c98 ????	       00 a0	   jiffy_clock =	$A0
     58  1c98 ????	       90 05	   character_info_register =	$9005
     59  1c98 ????	       1c 00	   character_set_begin =	$1c00
     60  1c98 ????
     61  1c98 ????						; begin location counter at 4096 (user memory)
     62  1001					      org	user_memory_start
------- FILE stub.s LEVEL 2 PASS 4
      0  1001					      include	"stub.s"	; stub contains BASIC sys cmd to run the machine language code
      1  1001		       00 9e	   SYS_CMD_TOKEN =	$9e
      2  1001		       00 0a	   STUB_LINE_NUMBER =	10
      3  1001							; BASIC stub -- SYS cmd to run machine language
      4  1001		       0b 10		      dc.w	nextstmt	; link; beginning of basic
      5  1003		       0a 00		      dc.w	STUB_LINE_NUMBER	; line number
      6  1005		       9e 34 31 30*	      dc.b	SYS_CMD_TOKEN, [start]d, 0	; token for sys with operand as address to "start" label
      7  100b				   nextstmt
      8  100b		       00 00		      dc.w	0
------- FILE src/main.s
     64  100d
     65  100d				   start
     66  100d							; use combination of RAM (first 128 chars at 7168) & ROM character set
     67  100d		       a9 ff		      lda	#255
     68  100f		       8d 05 90 	      sta	character_info_register
     69  1012
     70  1012							; initialize some variables in the zero page
     71  1012		       a9 01		      lda	#1
     72  1014		       85 08		      sta	level_reset
     73  1016		       a9 00		      lda	#0
     74  1018		       85 09		      sta	level_completed
     75  101a
     76  101a		       a9 3b		      lda	#<level_data_start
     77  101c		       85 04		      sta	current_level
     78  101e		       a9 15		      lda	#>level_data_start
     79  1020		       85 05		      sta	current_level+1
     80  1022
     81  1022		       a9 00		      lda	#0
     82  1024		       85 16		      sta	jump_remaining
     83  1026		       85 15		      sta	has_booster
     84  1028		       85 14		      sta	has_key
     85  102a
------- FILE titleScreen.s LEVEL 2 PASS 4
      0  102a					      include	"titleScreen.s"
      1  102a				   display_title_screen
      2  102a		       a9 00		      lda	#SCREEN_CURSOR_BEGINNING_LOW_BYTE
      3  102c		       85 00		      sta	screen_cursor
      4  102e		       a9 1e		      lda	#SCREEN_CURSOR_BEGINNING_HIGH_BYTE	; store 1e in location 01
      5  1030		       85 01		      sta	screen_cursor+1
      6  1032
      7  1032		       a9 00		      lda	#COLOR_CURSOR_BEGINNING_LOW_BYTE
      8  1034		       85 02		      sta	color_cursor
      9  1036		       a9 96		      lda	#COLOR_CURSOR_BEGINNING_HIGH_BYTE
     10  1038		       85 03		      sta	color_cursor+1
     11  103a
     12  103a		       a0 00		      ldy	#$0	; to use for indirect indexed addressing
     13  103c		       a2 00		      ldx	#$0
     14  103e
     15  103e		       20 4a 10 	      jsr	draw_title_screen_loop
     16  1041
     17  1041				   infinite_loop
     18  1041		       a5 c5		      lda	currently_pressed_key
     19  1043		       c9 20		      cmp	#SPACE_KEY
titleScreen.s (20): error: Branch out of range (1080 bytes).
     20  1045		       f0 00		      beq	gameLoop
     21  1047		       4c 41 10 	      jmp	infinite_loop
     22  104a
     23  104a
     24  104a				   draw_title_screen_loop
     25  104a		       bd d3 14 	      lda	compressed_screen_data_start,X	; accumulator stores num times to repeat the byte
     26  104d		       20 58 10 	      jsr	draw_character	; draw the character that many times
     27  1050		       e8		      inx
     28  1051		       e8		      inx
     29  1052		       20 93 10 	      jsr	check_if_screen_cursor_at_end
     30  1055		       90 f3		      bcc	draw_title_screen_loop
     31  1057		       60		      rts
     32  1058
     33  1058
     34  1058							; draw the character in Y register for (value of accumulator) number of times
     35  1058				   draw_character
     36  1058							; if accumulator == 0, return; otherwise, subtract 1 from accumulator and continue drawing the letter at Y
     37  1058		       f0 1d		      beq	draw_character_end
     38  105a		       38		      sec
     39  105b		       e9 01		      sbc	#1
     40  105d		       48		      pha		; push accumulator onto stack
     41  105e
     42  105e							; store current char at screen cursor location
     43  105e		       a0 00		      ldy	#0
     44  1060		       bd d4 14 	      lda	compressed_screen_data_start+1,X	; load cur char to draw
     45  1063		       18		      clc
     46  1064		       69 80		      adc	#128
     47  1066		       91 00		      sta	(screen_cursor),Y	; draw it on screen
     48  1068
     49  1068							; add color to the screen location if it's not a space
     50  1068							; because our title screen only has one color, and only displays it for characters that arent space, we can get away with this "optimization",
     51  1068							; and avoid adding color data
     52  1068		       c9 20		      cmp	#BLANK_CHAR
     53  106a		       f0 04		      beq	dont_color
     54  106c		       a9 00		      lda	#RED_COLOR_CODE
     55  106e		       91 02		      sta	(color_cursor),Y
     56  1070
     57  1070				   dont_color
     58  1070		       20 78 10 	      jsr	add_one_to_screen_cursor
     59  1073		       68		      pla		; put the current 'count' (remaining times to draw character) back on accumulator
     60  1074		       4c 58 10 	      jmp	draw_character
     61  1077
     62  1077				   draw_character_end
     63  1077		       60		      rts
     64  1078
     65  1078
     66  1078
     67  1078				   add_one_to_screen_cursor
     68  1078		       18		      clc
     69  1079		       a5 00		      lda	screen_cursor	; load and add to low byte
     70  107b		       69 01		      adc	#$1
     71  107d		       85 00		      sta	screen_cursor
     72  107f		       a5 01		      lda	screen_cursor+1
     73  1081		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
     74  1083		       85 01		      sta	screen_cursor+1
     75  1085
     76  1085							; add to color cursor as well
     77  1085		       18		      clc
     78  1086		       a5 02		      lda	color_cursor	; load and add to low byte
     79  1088		       69 01		      adc	#$1
     80  108a		       85 02		      sta	color_cursor
     81  108c		       a5 03		      lda	color_cursor+1
     82  108e		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
     83  1090		       85 03		      sta	color_cursor+1
     84  1092		       60		      rts
     85  1093
     86  1093				   check_if_screen_cursor_at_end		; set carry flag if screen_cursor at position $1ff9 (8185
     87  1093		       a5 00		      lda	screen_cursor	; load value at screen_cursor low byte
     88  1095		       c9 fa		      cmp	#END_OF_SCREEN_LOW_BYTE
     89  1097		       d0 06		      bne	check_if_screen_cursor_at_end_return_false	; if low byte doesnt match, return with carry flag as neg
     90  1099
     91  1099		       a5 01		      lda	screen_cursor+1
     92  109b		       c9 1f		      cmp	#END_OF_SCREEN_HIGH_BYTE
     93  109d		       f0 02		      beq	check_if_screen_cursor_at_end_return_true	; if high byte matches, set carry flag
     94  109f
     95  109f				   check_if_screen_cursor_at_end_return_false
     96  109f		       18		      clc
     97  10a0		       60		      rts
     98  10a1
     99  10a1				   check_if_screen_cursor_at_end_return_true
    100  10a1		       38		      sec
    101  10a2		       60		      rts
------- FILE src/main.s
------- FILE updateLevel.s LEVEL 2 PASS 4
      0  10a3					      include	"updateLevel.s"
      1  10a3		       00 01	   LEVEL_IS_DONE =	1
      2  10a3		       00 00	   LEVEL_NOT_DONE =	0
      3  10a3		       00 01	   SHOULD_RESET =	1
      4  10a3		       00 00	   SHOULD_NOT_RESET =	0
      5  10a3
      6  10a3							; only first 4 bits really matter here; refer to readme for guide on lvl format
      7  10a3		       00 00	   BLANK_SPACE =	0	; 000000000
      8  10a3		       00 10	   STARTING_POINT =	16	; 00010000
      9  10a3		       00 20	   WALL       =	32	; 00100000
     10  10a3		       00 30	   BREAKABLE_WALL =	48	; 00110000
     11  10a3		       00 40	   LOCKED_WALL =	64	; 01000000
     12  10a3		       00 50	   LADDER     =	80	; 01010000
     13  10a3		       00 60	   EXIT       =	96	; 01100000
     14  10a3		       00 70	   PLATFORM   =	112	; 01110000
     15  10a3		       00 80	   KEY	      =	128	; 10000000
     16  10a3		       00 90	   SPIKE      =	144	; 10010000
     17  10a3		       00 a0	   BOOSTER    =	160	; 10100000
     18  10a3
     19  10a3		       00 00	   WALL_COLOR =	0
     20  10a3		       00 00	   BREAKABLE_WALL_COLOR =	0
     21  10a3		       00 00	   LOCKED_WALL_COLOR =	0
     22  10a3		       00 00	   LADDER_COLOR =	0	;6
     23  10a3		       00 00	   EXIT_COLOR =	0	;6
     24  10a3		       00 00	   PLATFORM_COLOR =	0	;4
     25  10a3		       00 00	   SPIKE_COLOR =	0	;2
     26  10a3		       00 00	   KEY_P_COLOR =	0	;7
     27  10a3		       00 00	   SPIKE_P_COLOR =	0	;6
     28  10a3		       00 00	   BOOSTER_P_COLOR =	0	;6
     29  10a3		       00 02	   SQUAREBOT_COLOR =	2
     30  10a3
     31  10a3		       00 20	   BLANK_SPACE_CHAR =	$20
     32  10a3		       00 00	   BLANK_TILE_CHAR =	$00	; for ease of use with tileStore
     33  10a3		       00 01	   LADDER_CHAR =	$01
     34  10a3		       00 02	   PLATFORM_CHAR =	$02
     35  10a3		       00 03	   WALL_CHAR  =	$03
     36  10a3		       00 04	   EXIT_CHAR  =	$04
     37  10a3		       00 05	   LOCKED_WALL_CHAR =	$05
     38  10a3		       00 06	   BREAKABLE_WALL_CHAR =	$06
     39  10a3		       00 07	   BOOSTER_P_CHAR =	$07
     40  10a3		       00 08	   KEY_P_CHAR =	$08
     41  10a3		       00 09	   SPIKE_P_CHAR =	$09
     42  10a3		       00 0a	   BOOSTER_A_CHAR =	$0A
     43  10a3		       00 0b	   BOOSTER_AA_CHAR =	$0B
     44  10a3		       00 0c	   KEY_A_CHAR =	$0C
     45  10a3		       00 0d	   SPIKE_A_CHAR =	$0D
     46  10a3		       00 0e	   CHAR_U     =	$0E
     47  10a3		       00 0f	   CHAR_D     =	$0F
     48  10a3		       00 10	   CHAR_L     =	$10
     49  10a3		       00 11	   CHAR_R     =	$11
     50  10a3		       00 12	   SQUAREBOT_CHAR =	$12
     51  10a3
     52  10a3
     53  10a3				   update_level
     54  10a3							; check if the level is completed; set current_level to next_level if so
     55  10a3		       a5 09		      lda	level_completed
     56  10a5		       c9 01		      cmp	#LEVEL_IS_DONE	; (try optimizing later)
     57  10a7		       d0 0c		      bne	dont_update
     58  10a9
     59  10a9							; level is done; reset level completed
     60  10a9		       a9 00		      lda	#LEVEL_NOT_DONE
     61  10ab		       85 09		      sta	level_completed
     62  10ad
     63  10ad							; now set current_level to next_level
     64  10ad		       a5 06		      lda	next_level
     65  10af		       85 04		      sta	current_level
     66  10b1		       a5 07		      lda	next_level+1
     67  10b3		       85 05		      sta	current_level+1
     68  10b5
     69  10b5				   dont_update
     70  10b5							; now check if level reset was set
     71  10b5		       a5 08		      lda	level_reset
     72  10b7		       c9 00		      cmp	#0
     73  10b9		       d0 01		      bne	continue_update	; if not, go back to game loop
     74  10bb		       60		      rts
     75  10bc
     76  10bc				   continue_update
     77  10bc							; if it was, update the level
     78  10bc		       a9 00		      lda	#SCREEN_CURSOR_BEGINNING_LOW_BYTE
     79  10be		       85 00		      sta	screen_cursor
     80  10c0		       a9 1e		      lda	#SCREEN_CURSOR_BEGINNING_HIGH_BYTE
     81  10c2		       85 01		      sta	screen_cursor+1
     82  10c4
     83  10c4		       a9 00		      lda	#COLOR_CURSOR_BEGINNING_LOW_BYTE
     84  10c6		       85 02		      sta	color_cursor
     85  10c8		       a9 96		      lda	#COLOR_CURSOR_BEGINNING_HIGH_BYTE
     86  10ca		       85 03		      sta	color_cursor+1
     87  10cc
     88  10cc							; reset tileStore, assume squarebot is surrounded by blank tiles
     89  10cc		       a9 00		      lda	#$0
     90  10ce		       85 17		      sta	tileStore
     91  10d0		       85 18		      sta	tileStore+1
     92  10d2		       85 19		      sta	tileStore+2
     93  10d4
     94  10d4		       a2 00		      ldx	#0
     95  10d6		       a0 00		      ldy	#0
     96  10d8		       84 0a		      sty	level_data_index
     97  10da
     98  10da							; draw (or redraw on reset) the current level
     99  10da				   draw_level_loop
    100  10da							; y stores our index in the current level data
    101  10da		       a4 0a		      ldy	level_data_index
    102  10dc		       b1 04		      lda	(current_level),y	; accumulator stores the number of times to repeat the next byte
    103  10de
    104  10de		       20 fa 10 	      jsr	draw_sequence
    105  10e1
    106  10e1		       a4 0a		      ldy	level_data_index
    107  10e3		       c8		      iny		; set y to point to next length byte (iterate 2 at a time)
    108  10e4		       c8		      iny
    109  10e5		       84 0a		      sty	level_data_index
    110  10e7
    111  10e7
    112  10e7		       20 93 10 	      jsr	check_if_screen_cursor_at_end
    113  10ea		       90 ee		      bcc	draw_level_loop
    114  10ec
    115  10ec
    116  10ec							; update next level pointer to point to byte after current level
    117  10ec		       a5 04		      lda	current_level
    118  10ee		       18		      clc
    119  10ef		       65 0a		      adc	level_data_index
    120  10f1		       85 06		      sta	next_level
    121  10f3		       a5 05		      lda	current_level+1
    122  10f5		       69 00		      adc	#0
    123  10f7		       85 07		      sta	next_level+1
    124  10f9		       60		      rts
    125  10fa
    126  10fa
    127  10fa
    128  10fa				   draw_sequence
    129  10fa							; if acc == 0, return; otherwise subtract 1, draw the next 2 chars
    130  10fa		       f0 1c		      beq	draw_sequence_end
    131  10fc		       38		      sec
    132  10fd		       e9 01		      sbc	#1
    133  10ff		       48		      pha		; push accumulator onto stack
    134  1100
    135  1100		       a4 0a		      ldy	level_data_index
    136  1102		       c8		      iny		; (so we can access the "element" byte after the length byte)
    137  1103		       b1 04		      lda	(current_level),y	; get formatted byte (see squarebot doc)
    138  1105		       0a		      asl		; lol
    139  1106		       0a		      asl
    140  1107		       0a		      asl
    141  1108		       0a		      asl
    142  1109		       20 19 11 	      jsr	draw_high_bits	; draw char represented by the 4 high bits
    143  110c
    144  110c		       a4 0a		      ldy	level_data_index
    145  110e		       c8		      iny
    146  110f
    147  110f		       b1 04		      lda	(current_level),y
    148  1111		       20 19 11 	      jsr	draw_high_bits
    149  1114
    150  1114		       68		      pla
    151  1115		       4c fa 10 	      jmp	draw_sequence
    152  1118
    153  1118				   draw_sequence_end
    154  1118		       60		      rts
    155  1119
    156  1119
    157  1119							; put the character in the high 4 bits of accumulator on screen (see readme), and move the color and screen cursors ahead
    158  1119				   draw_high_bits
    159  1119		       29 f0		      and	#240	; shave off last 4 bits
    160  111b
    161  111b		       c9 00		      cmp	#BLANK_SPACE
    162  111d		       d0 08		      bne	check_if_starting_point
    163  111f		       a9 20		      lda	#BLANK_SPACE_CHAR	; todo; replace with actual chars
    164  1121		       a2 01		      ldx	#1
    165  1123		       20 ab 11 	      jsr	draw_char_in_accumulator
    166  1126		       60		      rts
    167  1127
    168  1127				   check_if_starting_point
    169  1127		       c9 10		      cmp	#STARTING_POINT
    170  1129		       d0 18		      bne	check_if_wall
    171  112b
    172  112b							; set squarebot to starting point
    173  112b		       a5 00		      lda	screen_cursor
    174  112d		       85 10		      sta	squarebot_position
    175  112f		       a5 01		      lda	screen_cursor+1
    176  1131		       85 11		      sta	squarebot_position+1
    177  1133
    178  1133		       a5 02		      lda	color_cursor
    179  1135		       85 12		      sta	squarebot_color_position
    180  1137		       a5 03		      lda	color_cursor+1
    181  1139		       85 13		      sta	squarebot_color_position+1
    182  113b
    183  113b		       a9 12		      lda	#SQUAREBOT_CHAR
    184  113d		       a2 02		      ldx	#SQUAREBOT_COLOR
    185  113f		       20 ab 11 	      jsr	draw_char_in_accumulator
    186  1142
    187  1142		       60		      rts
    188  1143
    189  1143
    190  1143				   check_if_wall
    191  1143		       c9 20		      cmp	#WALL
    192  1145		       d0 08		      bne	check_if_breakable_wall
    193  1147		       a9 03		      lda	#WALL_CHAR
    194  1149		       a2 00		      ldx	#WALL_COLOR
    195  114b		       20 ab 11 	      jsr	draw_char_in_accumulator
    196  114e		       60		      rts
    197  114f
    198  114f				   check_if_breakable_wall
    199  114f		       c9 30		      cmp	#BREAKABLE_WALL
    200  1151		       d0 08		      bne	check_if_locked_wall
    201  1153		       a9 06		      lda	#BREAKABLE_WALL_CHAR
    202  1155		       a2 00		      ldx	#BREAKABLE_WALL_COLOR
    203  1157		       20 ab 11 	      jsr	draw_char_in_accumulator
    204  115a		       60		      rts
    205  115b
    206  115b				   check_if_locked_wall
    207  115b		       c9 40		      cmp	#LOCKED_WALL
    208  115d		       d0 08		      bne	check_if_ladder
    209  115f		       a9 05		      lda	#LOCKED_WALL_CHAR
    210  1161		       a2 00		      ldx	#LOCKED_WALL_COLOR
    211  1163		       20 ab 11 	      jsr	draw_char_in_accumulator
    212  1166		       60		      rts
    213  1167
    214  1167				   check_if_ladder
    215  1167		       c9 50		      cmp	#LADDER
    216  1169		       d0 08		      bne	check_if_exit
    217  116b		       a9 01		      lda	#LADDER_CHAR
    218  116d		       a2 00		      ldx	#LADDER_COLOR
    219  116f		       20 ab 11 	      jsr	draw_char_in_accumulator
    220  1172		       60		      rts
    221  1173
    222  1173				   check_if_exit
    223  1173		       c9 60		      cmp	#EXIT
    224  1175		       d0 08		      bne	check_if_platform
    225  1177		       a9 04		      lda	#EXIT_CHAR
    226  1179		       a2 00		      ldx	#EXIT_COLOR
    227  117b		       20 ab 11 	      jsr	draw_char_in_accumulator
    228  117e		       60		      rts
    229  117f
    230  117f				   check_if_platform
    231  117f		       c9 70		      cmp	#PLATFORM
    232  1181		       d0 08		      bne	check_if_key
    233  1183		       a9 02		      lda	#PLATFORM_CHAR
    234  1185		       a2 00		      ldx	#PLATFORM_COLOR
    235  1187		       20 ab 11 	      jsr	draw_char_in_accumulator
    236  118a		       60		      rts
    237  118b
    238  118b				   check_if_key
    239  118b		       c9 80		      cmp	#KEY
    240  118d		       d0 08		      bne	check_if_spike
    241  118f		       a9 08		      lda	#KEY_P_CHAR
    242  1191		       a2 00		      ldx	#KEY_P_COLOR
    243  1193		       20 ab 11 	      jsr	draw_char_in_accumulator
    244  1196		       60		      rts
    245  1197
    246  1197				   check_if_spike
    247  1197		       c9 90		      cmp	#SPIKE
    248  1199		       d0 08		      bne	check_if_booster
    249  119b		       a9 09		      lda	#SPIKE_P_CHAR
    250  119d		       a2 00		      ldx	#SPIKE_P_COLOR
    251  119f		       20 ab 11 	      jsr	draw_char_in_accumulator
    252  11a2		       60		      rts
    253  11a3
    254  11a3				   check_if_booster
    255  11a3		       a9 07		      lda	#BOOSTER_P_CHAR
    256  11a5		       a2 00		      ldx	#BOOSTER_P_COLOR
    257  11a7		       20 ab 11 	      jsr	draw_char_in_accumulator
    258  11aa		       60		      rts
    259  11ab
    260  11ab
    261  11ab
    262  11ab							; char in accumulator goes in screen cursor, color in x register goes in color cursor, then update cursors
    263  11ab
    264  11ab				   draw_char_in_accumulator
    265  11ab		       a0 00		      ldy	#0
    266  11ad		       91 00		      sta	(screen_cursor),y
    267  11af
    268  11af		       8a		      txa
    269  11b0		       91 02		      sta	(color_cursor),y
    270  11b2
    271  11b2		       20 78 10 	      jsr	add_one_to_screen_cursor	; add to both screen and color cursor
    272  11b5		       60		      rts
------- FILE src/main.s
------- FILE updateGameState_new.s LEVEL 2 PASS 4
      0  11b6					      include	"updateGameState_new.s"
      1  11b6		       00 e4	   START_OF_FIRST_ROW_LOW_BYTE =	$e4
      2  11b6		       00 1f	   START_OF_FIRST_ROW_HIGH_BYTE =	$1f
      3  11b6
      4  11b6				   update_game_state
      5  11b6		       a5 10		      lda	squarebot_position
      6  11b8		       85 0b		      sta	new_position
      7  11ba		       a5 11		      lda	squarebot_position+1
      8  11bc		       85 0c		      sta	new_position+1
      9  11be		       a5 12		      lda	squarebot_color_position
     10  11c0		       85 0d		      sta	new_color_position
     11  11c2		       a5 13		      lda	squarebot_color_position+1
     12  11c4		       85 0e		      sta	new_color_position+1
     13  11c6
     14  11c6				   check_if_d_pressed
     15  11c6		       c9 12		      cmp	#D_KEY
     16  11c8		       d0 69		      bne	check_if_a_pressed
     17  11ca				   d_pressed
     18  11ca		       20 92 13 	      jsr	get_right
     19  11cd		       c9 04		      cmp	#EXIT_CHAR	; check here if we finish the level so we can rts to game loop
     20  11cf		       f0 74		      beq	level_has_finished
     21  11d1		       20 4c 12 	      jsr	collision_handler	; returns true if we can move
     22  11d4		       90 76		      bcc	handle_jump_logic	; no move
     23  11d6		       a5 1c		      lda	temp	; check for powerup
     24  11d8		       c9 00		      cmp	#$0
     25  11da		       f0 0e		      beq	post_powerup_r	;no powerup
     26  11dc		       a9 f0		      lda	#$F0
     27  11de		       25 1a		      and	attached_powerups	; clear original powerup
     28  11e0		       65 1c		      adc	temp
     29  11e2		       85 1a		      sta	attached_powerups	; insert new one
     30  11e4		       a9 f0		      lda	#$F0
     31  11e6		       25 19		      and	tileStore+2
     32  11e8		       85 19		      sta	tileStore+2	; clear powerup tile
     33  11ea				   post_powerup_r
     34  11ea		       20 e3 13 	      jsr	move_new_position_to_right
     35  11ed							;get new tiles
     36  11ed		       20 aa 13 	      jsr	get_mid
     37  11f0		       20 b9 13 	      jsr	set_left
     38  11f3		       20 92 13 	      jsr	get_right
     39  11f6		       20 df 13 	      jsr	set_mid
     40  11f9		       20 4f 14 	      jsr	get_squarebot_draw_position
     41  11fc		       a0 19		      ldy	#[ROW_SIZE+3]
     42  11fe		       b1 10		      lda	(squarebot_position),y
     43  1200		       20 af 13 	      jsr	set_right
     44  1203		       a0 02		      ldy	#2
     45  1205		       b1 10		      lda	(squarebot_position),y
     46  1207		       20 d1 13 	      jsr	set_up
     47  120a		       a0 2e		      ldy	#[[ROW_SIZE*2]+2]
     48  120c		       b1 10		      lda	(squarebot_position),y
     49  120e		       20 c7 13 	      jsr	set_down
     50  1211		       20 00 00 	      jsr	apply_powerup_logic
     51  1214		       a5 1b		      lda	attached_powerups+1
     52  1216		       29 f0		      and	#$F0
     53  1218		       c9 10		      cmp	#$10
     54  121a		       d0 08		      bne	no_booster_r
     55  121c		       a5 1b		      lda	attached_powerups+1
     56  121e		       29 0f		      and	#$0F
     57  1220		       69 20		      adc	#$20
     58  1222		       85 1b		      sta	attached_powerups+1	;boosted booster
     59  1224				   no_booster_r
     60  1224		       20 6a 12 	      jsr	delete_squarebot
     61  1227		       20 a6 12 	      jsr	update_squarebot
     62  122a		       20 b7 12 	      jsr	update_chars
     63  122d		       20 59 13 	      jsr	draw_squarebot
     64  1230		       4c 4c 12 	      jmp	handle_jump_logic
     65  1233
     66  1233
     67  1233				   check_if_a_pressed
     68  1233		       a5 c5		      lda	currently_pressed_key
     69  1235		       c9 11		      cmp	#A_KEY
     70  1237		       d0 13		      bne	handle_jump_logic
     71  1239				   a_pressed
     72  1239		       20 97 13 	      jsr	get_left
     73  123c		       c9 04		      cmp	#EXIT_CHAR
     74  123e		       f0 05		      beq	level_has_finished
     75  1240		       20 4c 12 	      jsr	collision_handler
     76  1243		       90 07		      bcc	handle_jump_logic
     77  1245
     78  1245				   level_has_finished
     79  1245		       a9 01		      lda	#1
     80  1247		       85 09		      sta	level_completed
     81  1249		       85 08		      sta	level_reset
     82  124b		       60		      rts
     83  124c
     84  124c				   handle_jump_logic
     85  124c
     86  124c				   collision_handler		; accumulator is the character (the actual character code) in the position that squarebot wants to move to
     87  124c							; set carry flag if we can move to this char, otherwise clear it
     88  124c		       c9 20		      cmp	#BLANK_CHAR
     89  124e		       f0 16		      beq	return_true
     90  1250
     91  1250		       c9 07		      cmp	#BOOSTER_P_CHAR
     92  1252		       d0 07		      bne	key_check
     93  1254		       a9 01		      lda	#1
     94  1256		       85 15		      sta	has_booster
     95  1258		       4c 66 12 	      jmp	return_true
     96  125b
     97  125b				   key_check
     98  125b		       c9 08		      cmp	#KEY_P_CHAR
     99  125d		       d0 09		      bne	return_false
    100  125f		       a9 01		      lda	#1
    101  1261		       85 14		      sta	has_key
    102  1263		       4c 66 12 	      jmp	return_true
    103  1266
    104  1266				   return_true		;beq and bne HATE going to a different file because why would anything be easy
    105  1266		       38		      sec
    106  1267		       60		      rts
    107  1268
    108  1268				   return_false
    109  1268		       18		      clc
    110  1269		       60		      rts
    111  126a
    112  126a				   delete_squarebot
    113  126a		       20 4f 14 	      jsr	get_squarebot_draw_position
    114  126d
    115  126d		       a0 17		      ldy	#[ROW_SIZE + 1]
    116  126f		       20 aa 13 	      jsr	get_mid
    117  1272		       91 10		      sta	(squarebot_position),y
    118  1274		       a9 01		      lda	#1
    119  1276		       91 12		      sta	(squarebot_color_position),y
    120  1278
    121  1278		       a0 01		      ldy	#1
    122  127a		       20 a3 13 	      jsr	get_up
    123  127d		       91 10		      sta	(squarebot_position),y
    124  127f		       a9 01		      lda	#1
    125  1281		       91 12		      sta	(squarebot_color_position),y
    126  1283
    127  1283		       a0 2d		      ldy	#[[ROW_SIZE*2] + 1]
    128  1285		       20 9e 13 	      jsr	get_down
    129  1288		       91 10		      sta	(squarebot_position),y
    130  128a		       a9 01		      lda	#1
    131  128c		       91 12		      sta	(squarebot_color_position),y
    132  128e
    133  128e		       a0 16		      ldy	#ROW_SIZE
    134  1290		       20 97 13 	      jsr	get_left
    135  1293		       91 10		      sta	(squarebot_position),y
    136  1295		       a9 01		      lda	#1
    137  1297		       91 12		      sta	(squarebot_color_position),y
    138  1299
    139  1299		       a0 18		      ldy	#[ROW_SIZE + 2]
    140  129b		       20 92 13 	      jsr	get_right
    141  129e		       91 10		      sta	(squarebot_position),y
    142  12a0		       a9 01		      lda	#1
    143  12a2
    144  12a2		       20 67 14 	      jsr	get_squarebot_game_position
    145  12a5
    146  12a5		       60		      rts
    147  12a6
    148  12a6
    149  12a6				   update_squarebot
    150  12a6		       a5 0b		      lda	new_position
    151  12a8		       85 10		      sta	squarebot_position
    152  12aa		       a5 0c		      lda	new_position+1
    153  12ac		       85 11		      sta	squarebot_position+1
    154  12ae
    155  12ae		       a5 0d		      lda	new_color_position
    156  12b0		       85 12		      sta	squarebot_color_position
    157  12b2		       a5 0e		      lda	new_color_position+1
    158  12b4		       85 13		      sta	squarebot_color_position+1
    159  12b6
    160  12b6		       60		      rts
    161  12b7
    162  12b7
    163  12b7				   update_chars
    164  12b7		       20 a3 13 	      jsr	get_up
    165  12ba		       0a		      asl
    166  12bb		       0a		      asl
    167  12bc		       0a		      asl		; multiply by 8
    168  12bd		       85 1e		      sta	charandr
    169  12bf
    170  12bf		       a5 1a		      lda	attached_powerups
    171  12c1		       4a		      lsr
    172  12c2		       4a		      lsr
    173  12c3		       4a		      lsr
    174  12c4		       4a		      lsr
    175  12c5		       c9 00		      cmp	#0
    176  12c7		       f0 05		      beq	update_blank_u
    177  12c9		       69 09		      adc	#9
    178  12cb		       0a		      asl
    179  12cc		       0a		      asl
    180  12cd		       0a		      asl		; we could simplify this but at this rate a few more asls isn't going to be the main thing slowing down the code
    181  12ce				   update_blank_u
    182  12ce		       85 1f		      sta	charandr+1
    183  12d0
    184  12d0		       a9 70		      lda	#[CHAR_U << 3]
    185  12d2		       85 20		      sta	charandr+2
    186  12d4
    187  12d4		       20 34 13 	      jsr	update_char
    188  12d7							;keep in mind we haven't rotated it yet
    189  12d7
    190  12d7		       20 9e 13 	      jsr	get_down
    191  12da		       0a		      asl
    192  12db		       0a		      asl
    193  12dc		       0a		      asl
    194  12dd		       85 1e		      sta	charandr
    195  12df
    196  12df		       a5 1a		      lda	attached_powerups
    197  12e1		       25 0f		      and	$0F
    198  12e3		       c9 00		      cmp	#0
    199  12e5		       f0 05		      beq	update_blank_d
    200  12e7		       69 09		      adc	#9
    201  12e9		       0a		      asl
    202  12ea		       0a		      asl
    203  12eb		       0a		      asl
    204  12ec				   update_blank_d
    205  12ec		       85 1f		      sta	charandr+1
    206  12ee
    207  12ee		       a9 78		      lda	#[CHAR_D << 3]
    208  12f0		       85 20		      sta	charandr+2
    209  12f2
    210  12f2		       20 34 13 	      jsr	update_char
    211  12f5
    212  12f5
    213  12f5		       20 97 13 	      jsr	get_left
    214  12f8		       0a		      asl
    215  12f9		       0a		      asl
    216  12fa		       0a		      asl
    217  12fb		       85 1e		      sta	charandr
    218  12fd
    219  12fd		       a5 1b		      lda	attached_powerups+1
    220  12ff		       4a		      lsr
    221  1300		       4a		      lsr
    222  1301		       4a		      lsr
    223  1302		       4a		      lsr
    224  1303		       c9 00		      cmp	#0
    225  1305		       f0 05		      beq	update_blank_l
    226  1307		       69 09		      adc	#9
    227  1309		       0a		      asl
    228  130a		       0a		      asl
    229  130b		       0a		      asl
    230  130c				   update_blank_l
    231  130c		       85 1f		      sta	charandr+1
    232  130e
    233  130e		       a9 80		      lda	#[CHAR_L << 3]
    234  1310		       85 20		      sta	charandr+2
    235  1312
    236  1312		       20 34 13 	      jsr	update_char
    237  1315
    238  1315		       20 92 13 	      jsr	get_right
    239  1318		       0a		      asl
    240  1319		       0a		      asl
    241  131a		       0a		      asl
    242  131b		       85 1e		      sta	charandr
    243  131d
    244  131d		       a5 1b		      lda	attached_powerups+1
    245  131f		       25 0f		      and	$0F
    246  1321		       c9 00		      cmp	#0
    247  1323		       f0 05		      beq	update_blank_r
    248  1325		       69 09		      adc	#9
    249  1327		       0a		      asl
    250  1328		       0a		      asl
    251  1329		       0a		      asl
    252  132a				   update_blank_r
    253  132a		       85 1f		      sta	charandr+1
    254  132c
    255  132c		       a9 88		      lda	#[CHAR_R << 3]
    256  132e		       85 20		      sta	charandr+2
    257  1330
    258  1330		       20 34 13 	      jsr	update_char
    259  1333
    260  1333		       60		      rts		;casual 98 line function
    261  1334
    262  1334
    263  1334				   update_char
    264  1334		       a2 00		      ldx	#0
    265  1336				   update_char_loop
    266  1336		       8a		      txa
    267  1337		       65 1e		      adc	charandr
    268  1339		       a8		      tay
    269  133a		       b9 00 1c 	      lda	(#character_set_begin),y
    270  133d		       85 1c		      sta	temp
    271  133f
    272  133f		       8a		      txa
    273  1340		       65 1f		      adc	charandr+1
    274  1342		       a8		      tay
    275  1343		       b9 00 1c 	      lda	(#character_set_begin),y
    276  1346		       45 1c		      eor	temp
    277  1348		       85 1c		      sta	temp
    278  134a
    279  134a		       8a		      txa
    280  134b		       65 20		      adc	charandr+2
    281  134d		       a8		      tay
    282  134e		       a5 1c		      lda	temp
    283  1350		       99 00 1c 	      sta	(#character_set_begin),y
    284  1353
    285  1353		       e8		      inx
    286  1354		       e0 08		      cpx	#8
    287  1356		       d0 de		      bne	update_char_loop
    288  1358		       60		      rts
    289  1359
    290  1359							; if there is a powerup:
    291  1359							; for each of 8 bytes:
    292  1359							; load tile byte
    293  1359							; eor with powerup tile byte
    294  1359							; store in char byte
    295  1359
    296  1359				   draw_squarebot
    297  1359		       20 4f 14 	      jsr	get_squarebot_draw_position
    298  135c
    299  135c		       a9 0e		      lda	#CHAR_U
    300  135e		       a0 01		      ldy	#1
    301  1360		       91 10		      sta	(squarebot_position),y
    302  1362		       a9 00		      lda	#0
    303  1364		       91 12		      sta	(squarebot_color_position),y
    304  1366
    305  1366		       a9 0f		      lda	#CHAR_D
    306  1368		       a0 2d		      ldy	#[[ROW_SIZE*2]+1]
    307  136a		       91 10		      sta	(squarebot_position),y
    308  136c		       a9 00		      lda	#0
    309  136e		       91 12		      sta	(squarebot_color_position),y
    310  1370
    311  1370		       a9 10		      lda	#CHAR_L
    312  1372		       a0 16		      ldy	#ROW_SIZE
    313  1374		       91 10		      sta	(squarebot_position),y
    314  1376		       a9 00		      lda	#0
    315  1378		       91 12		      sta	(squarebot_color_position),y
    316  137a
    317  137a		       a9 11		      lda	#CHAR_R
    318  137c		       a0 18		      ldy	#[ROW_SIZE+2]
    319  137e		       91 10		      sta	(squarebot_position),y
    320  1380		       a9 00		      lda	#0
    321  1382		       91 12		      sta	(squarebot_color_position),y
    322  1384
    323  1384		       a9 12		      lda	#SQUAREBOT_CHAR
    324  1386		       a0 17		      ldy	#[ROW_SIZE+1]
    325  1388		       91 10		      sta	(squarebot_position),y
    326  138a		       a9 02		      lda	#SQUAREBOT_COLOR
    327  138c		       91 12		      sta	(squarebot_color_position),y
    328  138e
    329  138e		       20 67 14 	      jsr	get_squarebot_game_position
    330  1391		       60		      rts
    331  1392
    332  1392							;start of level need to set the tiles and chars and everything, and when you reset too
    333  1392
    334  1392							;check if you press a or d:
    335  1392							; check tile if you can move
    336  1392							; if you can't, jump/fall
    337  1392							; otherwise, move new position and apply powerup if you collide with one
    338  1392							; refresh tiles
    339  1392							; call powerup logic for each powerup.
    340  1392							; draw powerup characters
    341  1392							; delete old character
    342  1392							; display character and powerups
    343  1392							; wait a jiffy probably
    344  1392							; booster check, if booster activated do this move again
    345  1392
    346  1392							;check if you are falling or jumping
    347  1392							; basically do all the same stuff but for up and down
    348  1392
    349  1392
    350  1392							;real how it works:
    351  1392
    352  1392							;l/r movement:
    353  1392							;store l/r tile you want to move to
    354  1392							;if you win, win
    355  1392							;check collision:
    356  1392							;  store powerup in temp
    357  1392							;  return whether you can move or not
    358  1392							;if you can't move, goto j/f movement
    359  1392							;apply powerup
    360  1392							;get new position
    361  1392							;refresh tiles
    362  1392							;apply powerup logic
    363  1392							;delete old position
    364  1392							;update position
    365  1392							;redraw chars
    366  1392							;draw new position
    367  1392							;wait a jiffy maybe
    368  1392							;check booster
    369  1392							;
    370  1392							;j/f movement
    371  1392							;do similar thing
------- FILE src/main.s
------- FILE updateGameStateHelper.s LEVEL 2 PASS 4
      0  1392					      include	"updateGameStateHelper.s"
      1  1392							; Helper functions for updateGameState
      2  1392
      3  1392				   get_right
      4  1392		       a5 18		      lda	tileStore+1
      5  1394		       29 0f		      and	#$0F
      6  1396		       60		      rts
      7  1397
      8  1397				   get_left
      9  1397		       a5 18		      lda	tileStore+1
     10  1399		       4a		      lsr
     11  139a		       4a		      lsr
     12  139b		       4a		      lsr
     13  139c		       4a		      lsr
     14  139d		       60		      rts
     15  139e
     16  139e				   get_down
     17  139e		       a5 17		      lda	tileStore
     18  13a0		       29 0f		      and	#$0F
     19  13a2		       60		      rts
     20  13a3
     21  13a3				   get_up
     22  13a3		       a5 17		      lda	tileStore
     23  13a5		       4a		      lsr
     24  13a6		       4a		      lsr
     25  13a7		       4a		      lsr
     26  13a8		       4a		      lsr
     27  13a9		       60		      rts
     28  13aa
     29  13aa				   get_mid
     30  13aa		       a5 19		      lda	tileStore+2
     31  13ac		       25 0f		      and	$0F
     32  13ae		       60		      rts
     33  13af
     34  13af
     35  13af				   set_right
     36  13af		       85 1c		      sta	temp
     37  13b1		       a9 f0		      lda	#$F0
     38  13b3		       25 18		      and	tileStore+1
     39  13b5		       65 1c		      adc	temp
     40  13b7		       85 18		      sta	tileStore+1
     41  13b9
     42  13b9				   set_left
     43  13b9		       0a		      asl
     44  13ba		       0a		      asl
     45  13bb		       0a		      asl
     46  13bc		       0a		      asl
     47  13bd		       85 1c		      sta	temp
     48  13bf		       a9 0f		      lda	#$0F
     49  13c1		       25 18		      and	tileStore+1
     50  13c3		       65 1c		      adc	temp
     51  13c5		       85 18		      sta	tileStore+1
     52  13c7
     53  13c7				   set_down
     54  13c7		       85 1c		      sta	temp
     55  13c9		       a9 f0		      lda	#$F0
     56  13cb		       25 17		      and	tileStore
     57  13cd		       65 1c		      adc	temp
     58  13cf		       85 17		      sta	tileStore
     59  13d1
     60  13d1				   set_up
     61  13d1		       0a		      asl
     62  13d2		       0a		      asl
     63  13d3		       0a		      asl
     64  13d4		       0a		      asl
     65  13d5		       85 1c		      sta	temp
     66  13d7		       a9 0f		      lda	#$0F
     67  13d9		       25 17		      and	tileStore
     68  13db		       65 1c		      adc	temp
     69  13dd		       85 17		      sta	tileStore
     70  13df
     71  13df				   set_mid
     72  13df		       29 0f		      and	#$0F
     73  13e1		       85 19		      sta	tileStore+2
     74  13e3
     75  13e3				   move_new_position_to_right
     76  13e3		       18		      clc
     77  13e4		       a5 0b		      lda	new_position	; load and add to low byte
     78  13e6		       69 01		      adc	#$1
     79  13e8		       85 0b		      sta	new_position
     80  13ea		       a5 0c		      lda	new_position+1
     81  13ec		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
     82  13ee		       85 0c		      sta	new_position+1
     83  13f0		       18		      clc
     84  13f1		       a5 0d		      lda	new_color_position	; load and add to low byte
     85  13f3		       69 01		      adc	#$1
     86  13f5		       85 0d		      sta	new_color_position
     87  13f7		       a5 0e		      lda	new_color_position+1
     88  13f9		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
     89  13fb		       85 0e		      sta	new_color_position+1
     90  13fd		       60		      rts
     91  13fe
     92  13fe				   move_new_position_to_left
     93  13fe		       38		      sec
     94  13ff		       a5 0b		      lda	new_position
     95  1401		       e9 01		      sbc	#$1
     96  1403		       85 0b		      sta	new_position
     97  1405		       a5 0c		      lda	new_position+1
     98  1407		       e9 00		      sbc	#$0
     99  1409		       85 0c		      sta	new_position+1
    100  140b		       38		      sec
    101  140c		       a5 0d		      lda	new_color_position
    102  140e		       e9 01		      sbc	#$1
    103  1410		       85 0d		      sta	new_color_position
    104  1412		       a5 0e		      lda	new_color_position+1
    105  1414		       e9 00		      sbc	#$0
    106  1416		       85 0e		      sta	new_color_position+1
    107  1418		       60		      rts
    108  1419
    109  1419
    110  1419				   move_new_position_up
    111  1419		       38		      sec
    112  141a		       a5 0b		      lda	new_position
    113  141c		       e9 16		      sbc	#ROW_SIZE
    114  141e		       85 0b		      sta	new_position
    115  1420		       a5 0c		      lda	new_position+1
    116  1422		       e9 00		      sbc	#$0
    117  1424		       85 0c		      sta	new_position+1
    118  1426		       38		      sec
    119  1427		       a5 0d		      lda	new_color_position
    120  1429		       e9 16		      sbc	#ROW_SIZE
    121  142b		       85 0d		      sta	new_color_position
    122  142d		       a5 0e		      lda	new_color_position+1
    123  142f		       e9 00		      sbc	#$0
    124  1431		       85 0e		      sta	new_color_position+1
    125  1433		       60		      rts
    126  1434
    127  1434				   move_new_position_down
    128  1434		       18		      clc
    129  1435		       a5 0b		      lda	new_position	; load and add to low byte
    130  1437		       69 16		      adc	#ROW_SIZE
    131  1439		       85 0b		      sta	new_position
    132  143b		       a5 0c		      lda	new_position+1
    133  143d		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
    134  143f		       85 0c		      sta	new_position+1
    135  1441		       18		      clc
    136  1442		       a5 0d		      lda	new_color_position	; load and add to low byte
    137  1444		       69 16		      adc	#ROW_SIZE
    138  1446		       85 0d		      sta	new_color_position
    139  1448		       a5 0e		      lda	new_color_position+1
    140  144a		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
    141  144c		       85 0e		      sta	new_color_position+1
    142  144e		       60		      rts
    143  144f
    144  144f				   get_squarebot_draw_position
    145  144f		       a5 10		      lda	squarebot_position
    146  1451		       e9 17		      sbc	#[ROW_SIZE+1]
    147  1453		       85 10		      sta	squarebot_position
    148  1455		       a5 11		      lda	squarebot_position+1
    149  1457		       e9 00		      sbc	#0
    150  1459		       85 11		      sta	squarebot_position+1
    151  145b
    152  145b		       a5 12		      lda	squarebot_color_position
    153  145d		       e9 17		      sbc	#[ROW_SIZE+1]
    154  145f		       85 12		      sta	squarebot_color_position
    155  1461		       a5 13		      lda	squarebot_color_position+1
    156  1463		       e9 00		      sbc	#0
    157  1465		       85 13		      sta	squarebot_color_position+1
    158  1467
    159  1467				   get_squarebot_game_position
    160  1467		       a5 10		      lda	squarebot_position
    161  1469		       69 17		      adc	#[ROW_SIZE+1]
    162  146b		       85 10		      sta	squarebot_position
    163  146d		       a5 11		      lda	squarebot_position+1
    164  146f		       69 00		      adc	#0
    165  1471		       85 11		      sta	squarebot_position+1
    166  1473
    167  1473		       a5 12		      lda	squarebot_color_position
    168  1475		       69 17		      adc	#[ROW_SIZE+1]
    169  1477		       85 12		      sta	squarebot_color_position
    170  1479		       a5 13		      lda	squarebot_color_position+1
    171  147b		       69 00		      adc	#0
    172  147d		       85 13		      sta	squarebot_color_position+1
------- FILE src/main.s
     90  147f
     91  147f
     92  147f							; title screen code jumps here once space pressed
     93  147f				   gameLoop
     94  147f		       20 a3 10 	      jsr	update_level
     95  1482		       a9 00		      lda	#0
     96  1484		       85 08		      sta	level_reset
     97  1486		       20 b6 11 	      jsr	update_game_state
     98  1489		       20 ad 14 	      jsr	check_for_secret_key
     99  148c		       20 bc 14 	      jsr	check_for_reset_key
    100  148f		       20 a4 14 	      jsr	wait_until_next_frame
    101  1492		       20 a4 14 	      jsr	wait_until_next_frame
    102  1495		       20 a4 14 	      jsr	wait_until_next_frame
    103  1498		       20 a4 14 	      jsr	wait_until_next_frame
    104  149b		       20 a4 14 	      jsr	wait_until_next_frame
    105  149e		       20 a4 14 	      jsr	wait_until_next_frame
    106  14a1		       4c 7f 14 	      jmp	gameLoop
    107  14a4
    108  14a4
    109  14a4				   wait_until_next_frame		; wait one jiffy before completing game loop
    110  14a4		       a5 a2		      lda	jiffy_clock+2
    111  14a6		       c5 0f		      cmp	current_time
    112  14a8		       f0 fa		      beq	wait_until_next_frame
    113  14aa		       85 0f		      sta	current_time
    114  14ac		       60		      rts
    115  14ad
    116  14ad							; update level_completed and level_reset if secret_key pressed
    117  14ad				   check_for_secret_key
    118  14ad		       a5 c5		      lda	currently_pressed_key
    119  14af		       c9 0d		      cmp	#SECRET_KEY
    120  14b1		       d0 08		      bne	check_for_secret_key_return
    121  14b3		       a9 01		      lda	#1
    122  14b5		       85 09		      sta	level_completed
    123  14b7		       a9 01		      lda	#1
    124  14b9		       85 08		      sta	level_reset
    125  14bb
    126  14bb				   check_for_secret_key_return
    127  14bb		       60		      rts		; what is this for?
    128  14bc
    129  14bc
    130  14bc				   check_for_reset_key
    131  14bc		       a5 c5		      lda	currently_pressed_key
    132  14be		       c9 0a		      cmp	#RESET_KEY
    133  14c0		       d0 f9		      bne	check_for_secret_key_return	; todo -- reset  a bunch of state (has_key, )
    134  14c2		       a9 01		      lda	#1
    135  14c4		       85 08		      sta	level_reset
    136  14c6		       a9 00		      lda	#0
    137  14c8		       85 15		      sta	has_booster
    138  14ca		       85 14		      sta	has_key
    139  14cc		       85 16		      sta	jump_remaining
    140  14ce		       85 1a		      sta	attached_powerups
    141  14d0		       85 1b		      sta	attached_powerups+1
    142  14d2
    143  14d2				   check_for_reset_key_return
    144  14d2		       60		      rts		; what is this for?
    145  14d3
    146  14d3				   compressed_screen_data_start
    147  14d3					      incbin	"../data/titleScreenData_compressed"	; got via 'bsave ""'
    148  153b
    149  153b				   level_data_start
    150  153b					      incbin	"../data/levels/binary_levels/1"
    151  1543					      incbin	"../data/levels/binary_levels/booster_test"
    152  1551					      incbin	"../data/levels/binary_levels/key_test"
    153  1567					      incbin	"../data/levels/binary_levels/2"
    154  157f					      incbin	"../data/levels/binary_levels/3"
    155  15d7					      incbin	"../data/levels/binary_levels/4"
    156  1603					      incbin	"../data/levels/binary_levels/5"
    157  162f					      incbin	"../data/levels/binary_levels/6"
    158  1661
------- FILE memoryCheck.s LEVEL 2 PASS 4
      0  1661					      include	"memoryCheck.s"	; code to make sure the program isn't too large and enters screen memory
      1  1661		       06 60	   BYTES_USED =	.-$1001	; location counter minus starting location = total bytes used
      2  1661		       1e 00	   SCREEN_MEMORY_START =	$1e00
 1632 bytes used
      3  1661					      echo	[BYTES_USED]d, "bytes used"
 Ending program at memory location (base 10):  5729
      4  1661					      echo	"Ending program at memory location (base 10): ", [.]d
      5  1661				  -	      if	. >= SCREEN_MEMORY_START	; if program entering screen memory
      6  1661				  -	      echo	"Throwing error because program is too large, and has entered screen memory!"
      7  1661				  -	      err
      8  1661					      endif
------- FILE src/main.s
    160  1661
    161  1661
    162  1c00					      org	character_set_begin
    163  1c00		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; blank 0
    164  1c08		       7e 42 7e 42*	      BYTE.b	$7E, $42, $7E, $42, $7E, $42, $7E, $42	; ladder 1
    165  1c10		       ff 5a 00 00*	      BYTE.b	$FF, $5A, $00, $00, $00, $00, $00, $00	; platform 2
    166  1c18		       ff ff ff ff*	      BYTE.b	$FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF	; wall 3
    167  1c20		       ff 9d a3 ac*	      BYTE.b	$FF, $9D, $A3, $AC, $A5, $99, $C3, $FF	; exit (door) 4
    168  1c28		       ff ff c3 c3*	      BYTE.b	$FF, $FF, $C3, $C3, $E7, $E7, $E7, $FF	; locked wall 5
    169  1c30		       ff ee f1 ef*	      BYTE.b	$FF, $EE, $F1, $EF, $57, $8F, $F3, $FF	; breakable wall 6
    170  1c38		       3c 42 99 bd*	      BYTE.b	$3C, $42, $99, $BD, $89, $91, $42, $3C	; booster powerup 7
    171  1c40		       3c 42 99 99*	      BYTE.b	$3C, $42, $99, $99, $91, $99, $42, $3C	; key powerup 8
    172  1c48		       3c 42 91 99*	      BYTE.b	$3C, $42, $91, $99, $BD, $81, $42, $3C	; spike powerup 9
    173  1c50		       08 38 f0 f0*	      BYTE.b	$08, $38, $F0, $F0, $F0, $F0, $38, $08	; booster attachment (R) 10
    174  1c58		       08 38 f1 ff*	      BYTE.b	$08, $38, $F1, $FF, $FE, $F1, $38, $08	; activated booster attachment (R) 11
    175  1c60		       00 00 fe fe*	      BYTE.b	$00, $00, $FE, $FE, $6A, $0A, $0E, $00	; key attachment (R) 12
    176  1c68		       80 c0 f0 fe*	      BYTE.b	$80, $C0, $F0, $FE, $F0, $C0, $80, $00	; spike attachment (R) 13
    177  1c70		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; charU 14
    178  1c78		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; charD 15
    179  1c80		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; charL 16
    180  1c88		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; charR 17
    181  1c90		       ff 81 a5 81*	      BYTE.b	$FF, $81, $A5, $81, $BD, $81, $81, $FF	; squarebot 18
