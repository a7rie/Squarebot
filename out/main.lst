------- FILE src/main.s LEVEL 1 PASS 3
      1  1c50 ????						; title screen program -- use hand-made compression method (esentially just RLE, see rleEncoding.py)
      2  1c50 ????				      processor	6502
      3  1c50 ????
      4 U0018 ????				      seg.u	ZP
      5 U0000					      org	$0
      6 U0000
      7 U0000
      8 U0000		       00 00	   screen_cursor ds.w	1	; stores the current screen memory address
      9 U0002		       00 00	   color_cursor ds.w	1	; store current color memory address
     10 U0004		       00 00	   current_level ds.w	1
     11 U0006		       00 00	   next_level ds.w	1
     12 U0008		       00	   level_reset ds.b	1
     13 U0009		       00	   level_completed ds.b	1
     14 U000a		       00	   level_data_index ds.b	1	; for temporarily saving index registers
     15 U000b		       00	   temp       ds.b	1	; for temporarily saving index registers
     16 U000c		       00 00	   new_position ds.w	1	; use to store position of (proposed) new location for squarebot
     17 U000e		       00 00	   new_color_position ds.w	1	; use to store position of (proposed) new location for squarebot
     18 U0010		       00	   current_time ds.b	1	; store only the last byte of the jiffy clock
     19 U0011		       00 00	   squarebot_position ds.w	1
     20 U0013		       00 00	   squarebot_color_position ds.w	1
     21 U0015		       00	   has_key    ds.b	1
     22 U0016		       00	   has_booster ds.b	1
     23 U0017		       00	   jump_remaining ds.b	1	; number of times the character should continue to move upwards in the current jump
     24  1c50 ????				      seg
     25  1c50 ????
     26  1c50 ????						; constants
     27  1c50 ????	       00 20	   BLANK_CHAR =	$20
     28  1c50 ????
     29  1c50 ????	       00 00	   SCREEN_CURSOR_BEGINNING_LOW_BYTE =	$00
     30  1c50 ????	       00 1e	   SCREEN_CURSOR_BEGINNING_HIGH_BYTE =	$1e
     31  1c50 ????
     32  1c50 ????						; last screen location
     33  1c50 ????	       00 fa	   END_OF_SCREEN_LOW_BYTE =	$fa
     34  1c50 ????	       00 1f	   END_OF_SCREEN_HIGH_BYTE =	$1f
     35  1c50 ????
     36  1c50 ????						; beginning of color memory
     37  1c50 ????	       00 00	   COLOR_CURSOR_BEGINNING_LOW_BYTE =	$00
     38  1c50 ????	       00 96	   COLOR_CURSOR_BEGINNING_HIGH_BYTE =	$96
     39  1c50 ????	       00 00	   RED_COLOR_CODE =	0
     40  1c50 ????
     41  1c50 ????	       00 20	   SPACE_KEY  =	$20
     42  1c50 ????	       00 09	   W_KEY      =	$09
     43  1c50 ????	       00 11	   A_KEY      =	$11
     44  1c50 ????	       00 29	   S_KEY      =	$29
     45  1c50 ????	       00 12	   D_KEY      =	$12
     46  1c50 ????	       00 0d	   SECRET_KEY =	$0d	; press P to skip to next  level
     47  1c50 ????	       00 34	   RESET_KEY  =	$34
     48  1c50 ????	       00 04	   JUMP_SIZE  =	$4	; number of characters a jump causes
     49  1c50 ????	       00 16	   ROW_SIZE   =	$16
     50  1c50 ????						; memory locations
     51  1c50 ????	       10 01	   user_memory_start =	$1001
     52  1c50 ????	       00 c5	   currently_pressed_key =	$c5
     53  1c50 ????	       00 a0	   jiffy_clock =	$A0
     54  1c50 ????	       90 05	   character_info_register =	$9005
     55  1c50 ????	       1c 00	   character_set_begin =	$1c00
     56  1c50 ????
     57  1c50 ????						; begin location counter at 4096 (user memory)
     58  1001					      org	user_memory_start
------- FILE stub.s LEVEL 2 PASS 3
      0  1001					      include	"stub.s"	; stub contains BASIC sys cmd to run the machine language code
      1  1001		       00 9e	   SYS_CMD_TOKEN =	$9e
      2  1001		       00 0a	   STUB_LINE_NUMBER =	10
      3  1001							; BASIC stub -- SYS cmd to run machine language
      4  1001		       0b 10		      dc.w	nextstmt	; link; beginning of basic
      5  1003		       0a 00		      dc.w	STUB_LINE_NUMBER	; line number
      6  1005		       9e 34 31 30*	      dc.b	SYS_CMD_TOKEN, [start]d, 0	; token for sys with operand as address to "start" label
      7  100b				   nextstmt
      8  100b		       00 00		      dc.w	0
------- FILE src/main.s
     60  100d
     61  100d				   start
     62  100d							; use combination of RAM (first 128 chars at 7168) & ROM character set
     63  100d		       a9 ff		      lda	#255
     64  100f		       8d 05 90 	      sta	character_info_register
     65  1012
     66  1012							; initialize some variables in the zero page
     67  1012		       a9 01		      lda	#1
     68  1014		       85 08		      sta	level_reset
     69  1016		       a9 00		      lda	#0
     70  1018		       85 09		      sta	level_completed
     71  101a
     72  101a		       a9 da		      lda	#<level_data_start
     73  101c		       85 04		      sta	current_level
     74  101e		       a9 13		      lda	#>level_data_start
     75  1020		       85 05		      sta	current_level+1
     76  1022
     77  1022		       a9 00		      lda	#0
     78  1024		       85 17		      sta	jump_remaining
     79  1026		       85 16		      sta	has_booster
     80  1028		       85 15		      sta	has_key
     81  102a
------- FILE titleScreen.s LEVEL 2 PASS 3
      0  102a					      include	"titleScreen.s"
      1  102a				   display_title_screen
      2  102a		       a9 00		      lda	#SCREEN_CURSOR_BEGINNING_LOW_BYTE
      3  102c		       85 00		      sta	screen_cursor
      4  102e		       a9 1e		      lda	#SCREEN_CURSOR_BEGINNING_HIGH_BYTE	; store 1e in location 01
      5  1030		       85 01		      sta	screen_cursor+1
      6  1032
      7  1032		       a9 00		      lda	#COLOR_CURSOR_BEGINNING_LOW_BYTE
      8  1034		       85 02		      sta	color_cursor
      9  1036		       a9 96		      lda	#COLOR_CURSOR_BEGINNING_HIGH_BYTE
     10  1038		       85 03		      sta	color_cursor+1
     11  103a
     12  103a		       a0 00		      ldy	#$0	; to use for indirect indexed addressing
     13  103c		       a2 00		      ldx	#$0
     14  103e
     15  103e		       20 4a 10 	      jsr	draw_title_screen_loop
     16  1041
     17  1041				   infinite_loop
     18  1041		       a5 c5		      lda	currently_pressed_key
     19  1043		       c9 20		      cmp	#SPACE_KEY
     20  1045		       f0 5c		      beq	gameLoop
     21  1047		       4c 41 10 	      jmp	infinite_loop
     22  104a
     23  104a
     24  104a				   draw_title_screen_loop
     25  104a		       bd 72 13 	      lda	compressed_screen_data_start,X	; accumulator stores num times to repeat the byte
     26  104d		       20 58 10 	      jsr	draw_character	; draw the character that many times
     27  1050		       e8		      inx
     28  1051		       e8		      inx
     29  1052		       20 93 10 	      jsr	check_if_screen_cursor_at_end
     30  1055		       90 f3		      bcc	draw_title_screen_loop
     31  1057		       60		      rts
     32  1058
     33  1058
     34  1058							; draw the character in Y register for (value of accumulator) number of times
     35  1058				   draw_character
     36  1058							; if accumulator == 0, return; otherwise, subtract 1 from accumulator and continue drawing the letter at Y
     37  1058		       f0 1d		      beq	draw_character_end
     38  105a		       38		      sec
     39  105b		       e9 01		      sbc	#1
     40  105d		       48		      pha		; push accumulator onto stack
     41  105e
     42  105e							; store current char at screen cursor location
     43  105e		       a0 00		      ldy	#0
     44  1060		       bd 73 13 	      lda	compressed_screen_data_start+1,X	; load cur char to draw
     45  1063		       18		      clc
     46  1064		       69 80		      adc	#128
     47  1066		       91 00		      sta	(screen_cursor),Y	; draw it on screen
     48  1068
     49  1068							; add color to the screen location if it's not a space
     50  1068							; because our title screen only has one color, and only displays it for characters that arent space, we can get away with this "optimization",
     51  1068							; and avoid adding color data
     52  1068		       c9 20		      cmp	#BLANK_CHAR
     53  106a		       f0 04		      beq	dont_color
     54  106c		       a9 00		      lda	#RED_COLOR_CODE
     55  106e		       91 02		      sta	(color_cursor),Y
     56  1070
     57  1070				   dont_color
     58  1070		       20 78 10 	      jsr	add_one_to_screen_cursor
     59  1073		       68		      pla		; put the current 'count' (remaining times to draw character) back on accumulator
     60  1074		       4c 58 10 	      jmp	draw_character
     61  1077
     62  1077				   draw_character_end
     63  1077		       60		      rts
     64  1078
     65  1078
     66  1078
     67  1078				   add_one_to_screen_cursor
     68  1078		       18		      clc
     69  1079		       a5 00		      lda	screen_cursor	; load and add to low byte
     70  107b		       69 01		      adc	#$1
     71  107d		       85 00		      sta	screen_cursor
     72  107f		       a5 01		      lda	screen_cursor+1
     73  1081		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
     74  1083		       85 01		      sta	screen_cursor+1
     75  1085
     76  1085							; add to color cursor as well
     77  1085		       18		      clc
     78  1086		       a5 02		      lda	color_cursor	; load and add to low byte
     79  1088		       69 01		      adc	#$1
     80  108a		       85 02		      sta	color_cursor
     81  108c		       a5 03		      lda	color_cursor+1
     82  108e		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
     83  1090		       85 03		      sta	color_cursor+1
     84  1092		       60		      rts
     85  1093
     86  1093				   check_if_screen_cursor_at_end		; set carry flag if screen_cursor at position $1ff9 (8185
     87  1093		       a5 00		      lda	screen_cursor	; load value at screen_cursor low byte
     88  1095		       c9 fa		      cmp	#END_OF_SCREEN_LOW_BYTE
     89  1097		       d0 06		      bne	check_if_screen_cursor_at_end_return_false	; if low byte doesnt match, return with carry flag as neg
     90  1099
     91  1099		       a5 01		      lda	screen_cursor+1
     92  109b		       c9 1f		      cmp	#END_OF_SCREEN_HIGH_BYTE
     93  109d		       f0 02		      beq	check_if_screen_cursor_at_end_return_true	; if high byte matches, set carry flag
     94  109f
     95  109f				   check_if_screen_cursor_at_end_return_false
     96  109f		       18		      clc
     97  10a0		       60		      rts
     98  10a1
     99  10a1				   check_if_screen_cursor_at_end_return_true
    100  10a1		       38		      sec
    101  10a2		       60		      rts
------- FILE src/main.s
     83  10a3
     84  10a3
     85  10a3							; title screen code jumps here once space pressed
     86  10a3				   gameLoop
     87  10a3		       20 ed 10 	      jsr	update_level
     88  10a6		       a9 00		      lda	#0
     89  10a8		       85 08		      sta	level_reset
     90  10aa		       20 f8 11 	      jsr	update_game_state
     91  10ad		       20 cb 10 	      jsr	check_for_secret_key
     92  10b0		       20 da 10 	      jsr	check_for_reset_key
     93  10b3		       20 c2 10 	      jsr	wait_until_next_frame
     94  10b6		       20 c2 10 	      jsr	wait_until_next_frame
     95  10b9		       20 c2 10 	      jsr	wait_until_next_frame
     96  10bc		       20 c2 10 	      jsr	wait_until_next_frame
     97  10bf		       4c a3 10 	      JMP	gameLoop
     98  10c2
     99  10c2
    100  10c2				   wait_until_next_frame		; wait one jiffy before completing game loop
    101  10c2		       a5 a2		      lda	jiffy_clock+2
    102  10c4		       c5 10		      cmp	current_time
    103  10c6		       f0 fa		      beq	wait_until_next_frame
    104  10c8		       85 10		      sta	current_time
    105  10ca		       60		      rts
    106  10cb
    107  10cb							; update level_completed and level_reset if secret_key pressed
    108  10cb				   check_for_secret_key
    109  10cb		       a5 c5		      lda	currently_pressed_key
    110  10cd		       c9 0d		      cmp	#SECRET_KEY
    111  10cf		       d0 08		      bne	check_for_secret_key_return
    112  10d1		       a9 01		      lda	#1
    113  10d3		       85 09		      sta	level_completed
    114  10d5		       a9 01		      lda	#1
    115  10d7		       85 08		      sta	level_reset
    116  10d9
    117  10d9				   check_for_secret_key_return
    118  10d9		       60		      rts
    119  10da
    120  10da
    121  10da				   check_for_reset_key
    122  10da		       a5 c5		      lda	currently_pressed_key
    123  10dc		       c9 34		      cmp	#RESET_KEY
    124  10de		       d0 f9		      bne	check_for_secret_key_return	; todo -- reset  a bunch of state (has_key, )
    125  10e0		       a9 01		      lda	#1
    126  10e2		       85 08		      sta	level_reset
    127  10e4		       a9 00		      lda	#0
    128  10e6		       85 16		      sta	has_booster
    129  10e8		       85 15		      sta	has_key
    130  10ea		       85 17		      sta	jump_remaining
    131  10ec
    132  10ec				   check_for_reset_key_return
    133  10ec		       60		      rts
    134  10ed
------- FILE updateLevel.s LEVEL 2 PASS 3
      0  10ed					      include	"updateLevel.s"
      1  10ed		       00 01	   LEVEL_IS_DONE =	1
      2  10ed		       00 00	   LEVEL_NOT_DONE =	0
      3  10ed		       00 01	   SHOULD_RESET =	1
      4  10ed		       00 00	   SHOULD_NOT_RESET =	0
      5  10ed
      6  10ed							; only first 4 bits really matter here; refer to readme for guide on lvl format
      7  10ed		       00 00	   BLANK_SPACE =	0	; 000000000
      8  10ed		       00 10	   STARTING_POINT =	16	; 00010000
      9  10ed		       00 20	   WALL       =	32	; 00100000
     10  10ed		       00 30	   BREAKABLE_WALL =	48	; 00110000
     11  10ed		       00 40	   LOCKED_WALL =	64	; 01000000
     12  10ed		       00 50	   LADDER     =	80	; 01010000
     13  10ed		       00 60	   EXIT       =	96	; 01100000
     14  10ed		       00 70	   PLATFORM   =	112	; 01110000
     15  10ed		       00 80	   KEY	      =	128	; 10000000
     16  10ed		       00 90	   SPIKE      =	144	; 10010000
     17  10ed		       00 a0	   BOOSTER    =	160	;  10100000
     18  10ed
     19  10ed		       00 00	   WALL_COLOR =	0
     20  10ed		       00 00	   BREAKABLE_WALL_COLOR =	0
     21  10ed		       00 00	   LOCKED_WALL_COLOR =	0
     22  10ed		       00 08	   LADDER_COLOR =	8
     23  10ed		       00 02	   EXIT_COLOR =	2
     24  10ed		       00 02	   PLATFORM_COLOR =	2
     25  10ed		       00 07	   KEY_COLOR  =	7
     26  10ed		       00 06	   SPIKE_COLOR =	6
     27  10ed		       00 03	   BOOSTER_COLOR =	3
     28  10ed
     29  10ed		       00 20	   BLANK_SPACE_CHAR =	$20
     30  10ed		       00 03	   WALL_CHAR  =	$3
     31  10ed		       00 07	   BREAKABLE_WALL_CHAR =	$7
     32  10ed		       00 06	   LOCKED_WALL_CHAR =	$6
     33  10ed		       00 00	   LADDER_CHAR =	$0
     34  10ed		       00 04	   EXIT_CHAR  =	$4
     35  10ed		       00 02	   PLATFORM_CHAR =	$2
     36  10ed		       00 05	   KEY_CHAR   =	$5
     37  10ed		       00 08	   SPIKE_CHAR =	$8
     38  10ed		       00 09	   BOOSTER_CHAR =	$9
     39  10ed
     40  10ed
     41  10ed				   update_level
     42  10ed							; check if the level is completed; set current_level to next_level if so
     43  10ed		       a5 09		      lda	level_completed
     44  10ef		       c9 01		      cmp	#LEVEL_IS_DONE	; (try optimizing later)
     45  10f1		       d0 0c		      bne	dont_update
     46  10f3
     47  10f3							; level is done; reset level completed
     48  10f3		       a9 00		      lda	#LEVEL_NOT_DONE
     49  10f5		       85 09		      sta	level_completed
     50  10f7
     51  10f7							; now set current_level to next_level
     52  10f7		       a5 06		      lda	next_level
     53  10f9		       85 04		      sta	current_level
     54  10fb		       a5 07		      lda	next_level+1
     55  10fd		       85 05		      sta	current_level+1
     56  10ff
     57  10ff				   dont_update
     58  10ff							; now check if level reset was set
     59  10ff		       a5 08		      lda	level_reset
     60  1101		       c9 00		      cmp	#0
     61  1103		       d0 01		      bne	continue_update	; if not, go back to game loop
     62  1105		       60		      rts
     63  1106
     64  1106				   continue_update
     65  1106							; if it was, update the level
     66  1106		       a9 00		      lda	#SCREEN_CURSOR_BEGINNING_LOW_BYTE
     67  1108		       85 00		      sta	screen_cursor
     68  110a		       a9 1e		      lda	#SCREEN_CURSOR_BEGINNING_HIGH_BYTE
     69  110c		       85 01		      sta	screen_cursor+1
     70  110e
     71  110e		       a9 00		      lda	#COLOR_CURSOR_BEGINNING_LOW_BYTE
     72  1110		       85 02		      sta	color_cursor
     73  1112		       a9 96		      lda	#COLOR_CURSOR_BEGINNING_HIGH_BYTE
     74  1114		       85 03		      sta	color_cursor+1
     75  1116
     76  1116		       a2 00		      ldx	#0
     77  1118		       a0 00		      ldy	#0
     78  111a		       84 0a		      sty	level_data_index
     79  111c
     80  111c							; draw (or redraw on reset) the current level
     81  111c				   draw_level_loop
     82  111c							; y stores our index in the current level data
     83  111c		       a4 0a		      ldy	level_data_index
     84  111e		       b1 04		      lda	(current_level),y	; accumulator stores the number of times to repeat the next byte
     85  1120
     86  1120		       20 3c 11 	      jsr	draw_sequence
     87  1123
     88  1123		       a4 0a		      ldy	level_data_index
     89  1125		       c8		      iny		; set y to point to next length byte (iterate 2 at a time)
     90  1126		       c8		      iny
     91  1127		       84 0a		      sty	level_data_index
     92  1129
     93  1129
     94  1129		       20 93 10 	      jsr	check_if_screen_cursor_at_end
     95  112c		       90 ee		      bcc	draw_level_loop
     96  112e
     97  112e
     98  112e							; update next level pointer to point to byte after current level
     99  112e		       a5 04		      lda	current_level
    100  1130		       18		      clc
    101  1131		       65 0a		      adc	level_data_index
    102  1133		       85 06		      sta	next_level
    103  1135		       a5 05		      lda	current_level+1
    104  1137		       69 00		      adc	#0
    105  1139		       85 07		      sta	next_level+1
    106  113b		       60		      rts
    107  113c
    108  113c
    109  113c
    110  113c				   draw_sequence
    111  113c							; if acc == 0, return; otherwise subtract 1, draw the next 2 chars
    112  113c		       f0 1c		      beq	draw_sequence_end
    113  113e		       38		      sec
    114  113f		       e9 01		      sbc	#1
    115  1141		       48		      pha		; push accumulator onto stack
    116  1142
    117  1142		       a4 0a		      ldy	level_data_index
    118  1144		       c8		      iny		; (so we can access the "element" byte after the length byte)
    119  1145		       b1 04		      lda	(current_level),y	; get formatted byte (see squarebot doc)
    120  1147		       0a		      asl		; lol
    121  1148		       0a		      asl
    122  1149		       0a		      asl
    123  114a		       0a		      asl
    124  114b		       20 5b 11 	      jsr	draw_high_bits	; draw char represented by the 4 high bits
    125  114e
    126  114e		       a4 0a		      ldy	level_data_index
    127  1150		       c8		      iny
    128  1151
    129  1151		       b1 04		      lda	(current_level),y
    130  1153		       20 5b 11 	      jsr	draw_high_bits
    131  1156
    132  1156		       68		      pla
    133  1157		       4c 3c 11 	      jmp	draw_sequence
    134  115a
    135  115a				   draw_sequence_end
    136  115a		       60		      rts
    137  115b
    138  115b
    139  115b							; put the character in the high 4 bits of accumulator on screen (see readme), and move the color and screen cursors ahead
    140  115b				   draw_high_bits
    141  115b		       29 f0		      and	#240	; shave off last 4 bits
    142  115d
    143  115d		       c9 00		      cmp	#BLANK_SPACE
    144  115f		       d0 08		      bne	check_if_starting_point
    145  1161		       a9 20		      lda	#BLANK_SPACE_CHAR	; todo; replace with actual chars
    146  1163		       a2 01		      ldx	#1
    147  1165		       20 ed 11 	      jsr	draw_char_in_accumulator
    148  1168		       60		      rts
    149  1169
    150  1169				   check_if_starting_point
    151  1169		       c9 10		      cmp	#STARTING_POINT
    152  116b		       d0 18		      bne	check_if_wall
    153  116d
    154  116d							; set squarebot to starting point
    155  116d		       a5 00		      lda	screen_cursor
    156  116f		       85 11		      sta	squarebot_position
    157  1171		       a5 01		      lda	screen_cursor+1
    158  1173		       85 12		      sta	squarebot_position+1
    159  1175
    160  1175		       a5 02		      lda	color_cursor
    161  1177		       85 13		      sta	squarebot_color_position
    162  1179		       a5 03		      lda	color_cursor+1
    163  117b		       85 14		      sta	squarebot_color_position+1
    164  117d
    165  117d		       a9 01		      lda	#$1
    166  117f		       a2 02		      ldx	#SQUAREBOT_COLOR
    167  1181		       20 ed 11 	      jsr	draw_char_in_accumulator
    168  1184
    169  1184
    170  1184
    171  1184		       60		      rts
    172  1185
    173  1185				   check_if_wall
    174  1185		       c9 20		      cmp	#WALL
    175  1187		       d0 08		      bne	check_if_breakable_wall
    176  1189		       a9 03		      lda	#WALL_CHAR
    177  118b		       a2 00		      ldx	#WALL_COLOR
    178  118d		       20 ed 11 	      jsr	draw_char_in_accumulator
    179  1190		       60		      rts
    180  1191
    181  1191				   check_if_breakable_wall
    182  1191		       c9 30		      cmp	#BREAKABLE_WALL
    183  1193		       d0 08		      bne	check_if_locked_wall
    184  1195		       a9 07		      lda	#BREAKABLE_WALL_CHAR
    185  1197		       a2 00		      ldx	#BREAKABLE_WALL_COLOR
    186  1199		       20 ed 11 	      jsr	draw_char_in_accumulator
    187  119c		       60		      rts
    188  119d
    189  119d				   check_if_locked_wall
    190  119d		       c9 40		      cmp	#LOCKED_WALL
    191  119f		       d0 08		      bne	check_if_ladder
    192  11a1		       a9 06		      lda	#LOCKED_WALL_CHAR
    193  11a3		       a2 00		      ldx	#LOCKED_WALL_COLOR
    194  11a5		       20 ed 11 	      jsr	draw_char_in_accumulator
    195  11a8		       60		      rts
    196  11a9
    197  11a9				   check_if_ladder
    198  11a9		       c9 50		      cmp	#LADDER
    199  11ab		       d0 08		      bne	check_if_exit
    200  11ad		       a9 00		      lda	#LADDER_CHAR
    201  11af		       a2 08		      ldx	#LADDER_COLOR
    202  11b1		       20 ed 11 	      jsr	draw_char_in_accumulator
    203  11b4		       60		      rts
    204  11b5
    205  11b5				   check_if_exit
    206  11b5		       c9 60		      cmp	#EXIT
    207  11b7		       d0 08		      bne	check_if_platform
    208  11b9		       a9 04		      lda	#EXIT_CHAR
    209  11bb		       a2 02		      ldx	#EXIT_COLOR
    210  11bd		       20 ed 11 	      jsr	draw_char_in_accumulator
    211  11c0		       60		      rts
    212  11c1
    213  11c1				   check_if_platform
    214  11c1		       c9 70		      cmp	#PLATFORM
    215  11c3		       d0 08		      bne	check_if_key
    216  11c5		       a9 02		      lda	#PLATFORM_CHAR
    217  11c7		       a2 02		      ldx	#PLATFORM_COLOR
    218  11c9		       20 ed 11 	      jsr	draw_char_in_accumulator
    219  11cc		       60		      rts
    220  11cd
    221  11cd
    222  11cd				   check_if_key
    223  11cd		       c9 80		      cmp	#KEY
    224  11cf		       d0 08		      bne	check_if_spike
    225  11d1		       a9 05		      lda	#KEY_CHAR
    226  11d3		       a2 07		      ldx	#KEY_COLOR
    227  11d5		       20 ed 11 	      jsr	draw_char_in_accumulator
    228  11d8		       60		      rts
    229  11d9
    230  11d9				   check_if_spike
    231  11d9		       c9 90		      cmp	#SPIKE
    232  11db		       d0 08		      bne	check_if_booster
    233  11dd		       a9 08		      lda	#SPIKE_CHAR
    234  11df		       a2 06		      ldx	#SPIKE_COLOR
    235  11e1		       20 ed 11 	      jsr	draw_char_in_accumulator
    236  11e4		       60		      rts
    237  11e5
    238  11e5				   check_if_booster
    239  11e5		       a9 09		      lda	#BOOSTER_CHAR
    240  11e7		       a2 03		      ldx	#BOOSTER_COLOR
    241  11e9		       20 ed 11 	      jsr	draw_char_in_accumulator
    242  11ec		       60		      rts
    243  11ed
    244  11ed
    245  11ed							; char in accumulator goes in screen cursor, color in x register goes in color cursor, then update cursors
    246  11ed
    247  11ed				   draw_char_in_accumulator
    248  11ed		       a0 00		      ldy	#0
    249  11ef		       91 00		      sta	(screen_cursor),y
    250  11f1
    251  11f1		       8a		      txa
    252  11f2		       91 02		      sta	(color_cursor),y
    253  11f4
    254  11f4		       20 78 10 	      jsr	add_one_to_screen_cursor	; add to both screen and color cursor
    255  11f7		       60		      rts
------- FILE src/main.s
------- FILE updateGameState.s LEVEL 2 PASS 3
      0  11f8					      include	"updateGameState.s"
      1  11f8
      2  11f8		       00 01	   MOVE_LEFT  =	1
      3  11f8		       00 02	   MOVE_RIGHT =	2
      4  11f8		       00 01	   SQUAREBOT_CHAR =	$1
      5  11f8		       00 02	   SQUAREBOT_COLOR =	$2
      6  11f8		       00 e4	   START_OF_FIRST_ROW_LOW_BYTE =	$e4
      7  11f8		       00 1f	   START_OF_FIRST_ROW_HIGH_BYTE =	$1f
      8  11f8
      9  11f8				   update_game_state
     10  11f8		       a5 11		      lda	squarebot_position
     11  11fa		       85 0c		      sta	new_position
     12  11fc		       a5 12		      lda	squarebot_position+1
     13  11fe		       85 0d		      sta	new_position+1
     14  1200		       a5 13		      lda	squarebot_color_position
     15  1202		       85 0e		      sta	new_color_position
     16  1204		       a5 14		      lda	squarebot_color_position+1
     17  1206		       85 0f		      sta	new_color_position+1
     18  1208
     19  1208		       a5 c5		      lda	currently_pressed_key
     20  120a		       c9 11		      cmp	#A_KEY
     21  120c		       d0 06		      bne	check_if_d_pressed
     22  120e		       20 db 12 	      jsr	move_new_position_to_left
     23  1211		       4c 1b 12 	      jmp	check_if_new_position_valid
     24  1214
     25  1214				   check_if_d_pressed
     26  1214		       c9 12		      cmp	#D_KEY
     27  1216		       d0 03		      bne	check_if_new_position_valid
     28  1218		       20 c0 12 	      jsr	move_new_position_to_right
     29  121b
     30  121b				   check_if_new_position_valid
     31  121b		       a0 00		      ldy	#0
     32  121d		       b1 0c		      lda	(new_position),y
     33  121f		       c9 04		      cmp	#EXIT_CHAR
     34  1221		       d0 04		      bne	continue_level
     35  1223		       20 b9 12 	      jsr	level_has_finished
     36  1226		       60		      rts
     37  1227
     38  1227				   continue_level
     39  1227		       20 37 13 	      jsr	collision_handler
     40  122a		       90 03		      bcc	handle_jump_logic
     41  122c
     42  122c		       20 9b 12 	      jsr	update_squarebot_position
     43  122f
     44  122f				   handle_jump_logic
     45  122f		       a5 17		      lda	jump_remaining	; how many more upward motions for current jump
     46  1231		       c9 00		      cmp	#0
     47  1233		       d0 2d		      bne	handle_jumps_remaining
     48  1235
     49  1235
     50  1235				   handle_no_jumps_remaining		; if no jumps left, then start jump if space is pressed, otherwise just skip and handle gravity
     51  1235		       a5 c5		      lda	currently_pressed_key
     52  1237		       c9 20		      cmp	#SPACE_KEY
     53  1239		       d0 47		      bne	handle_gravity
     54  123b
     55  123b
     56  123b
     57  123b		       20 62 13 	      jsr	squarebot_on_first_row	; if on first row, we dont care about what character lies below
     58  123e		       b0 0d		      bcs	skip_validity_check
     59  1240
     60  1240							; check if character below is blank; if so dont allow us to set jump_remaining
     61  1240		       a0 16		      ldy	#ROW_SIZE
     62  1242		       b1 11		      lda	(squarebot_position),y
     63  1244
     64  1244		       c9 04		      cmp	#EXIT_CHAR
     65  1246		       f0 71		      beq	level_has_finished
     66  1248
     67  1248		       20 37 13 	      jsr	collision_handler
     68  124b		       b0 35		      bcs	handle_gravity
     69  124d
     70  124d				   skip_validity_check
     71  124d		       a5 16		      lda	has_booster	; if we have the booster, set jump_remaining to twice as high, then get rid of the booster
     72  124f		       c9 01		      cmp	#1
     73  1251		       d0 0b		      bne	regular_jump
     74  1253		       a9 08		      lda	#JUMP_SIZE*2
     75  1255		       85 17		      sta	jump_remaining
     76  1257		       a9 00		      lda	#0
     77  1259		       85 16		      sta	has_booster
     78  125b		       4c 62 12 	      jmp	handle_jumps_remaining
     79  125e
     80  125e
     81  125e				   regular_jump
     82  125e		       a9 04		      lda	#JUMP_SIZE
     83  1260		       85 17		      sta	jump_remaining
     84  1262
     85  1262				   handle_jumps_remaining
     86  1262		       20 f6 12 	      jsr	move_new_position_up
     87  1265		       a0 00		      ldy	#0
     88  1267		       b1 0c		      lda	(new_position),y
     89  1269		       c9 04		      cmp	#EXIT_CHAR
     90  126b		       f0 4c		      beq	level_has_finished
     91  126d
     92  126d		       20 37 13 	      jsr	collision_handler
     93  1270		       90 0b		      bcc	jump_is_invalid
     94  1272
     95  1272		       20 9b 12 	      jsr	update_squarebot_position
     96  1275
     97  1275		       a5 17		      lda	jump_remaining
     98  1277		       38		      sec
     99  1278		       e9 01		      sbc	#1
    100  127a		       85 17		      sta	jump_remaining
    101  127c		       60		      rts		; no gravity effect after moving upwards from jump
    102  127d
    103  127d
    104  127d				   jump_is_invalid
    105  127d		       a9 00		      lda	#0
    106  127f		       85 17		      sta	jump_remaining
    107  1281		       60		      rts
    108  1282
    109  1282				   handle_gravity		; on first row - do nothing
    110  1282		       20 11 13 	      jsr	move_new_position_down
    111  1285
    112  1285		       20 62 13 	      jsr	squarebot_on_first_row
    113  1288		       b0 10		      bcs	do_nothing
    114  128a
    115  128a		       a0 00		      ldy	#0
    116  128c		       b1 0c		      lda	(new_position),y
    117  128e
    118  128e		       c9 04		      cmp	#EXIT_CHAR
    119  1290		       f0 27		      beq	level_has_finished
    120  1292
    121  1292		       20 37 13 	      jsr	collision_handler
    122  1295		       90 03		      bcc	do_nothing
    123  1297
    124  1297
    125  1297		       20 9b 12 	      jsr	update_squarebot_position
    126  129a
    127  129a				   do_nothing
    128  129a		       60		      rts
    129  129b
    130  129b				   update_squarebot_position
    131  129b		       20 2c 13 	      jsr	remove_char
    132  129e							; new positions are valid; set them to current positions
    133  129e
    134  129e		       a5 0c		      lda	new_position
    135  12a0		       85 11		      sta	squarebot_position
    136  12a2		       a5 0d		      lda	new_position+1
    137  12a4		       85 12		      sta	squarebot_position+1
    138  12a6
    139  12a6		       a5 0e		      lda	new_color_position
    140  12a8		       85 13		      sta	squarebot_color_position
    141  12aa		       a5 0f		      lda	new_color_position+1
    142  12ac		       85 14		      sta	squarebot_color_position+1
    143  12ae
    144  12ae		       a0 00		      ldy	#0
    145  12b0		       a9 01		      lda	#SQUAREBOT_CHAR
    146  12b2		       91 11		      sta	(squarebot_position),y
    147  12b4		       a9 02		      lda	#SQUAREBOT_COLOR
    148  12b6		       91 13		      sta	(squarebot_color_position),y
    149  12b8
    150  12b8		       60		      rts
    151  12b9
    152  12b9				   level_has_finished
    153  12b9		       a9 01		      lda	#1
    154  12bb		       85 09		      sta	level_completed
    155  12bd		       85 08		      sta	level_reset
    156  12bf		       60		      rts
    157  12c0
    158  12c0				   move_new_position_to_right
    159  12c0		       18		      clc
    160  12c1		       a5 0c		      lda	new_position	; load and add to low byte
    161  12c3		       69 01		      adc	#$1
    162  12c5		       85 0c		      sta	new_position
    163  12c7		       a5 0d		      lda	new_position+1
    164  12c9		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
    165  12cb		       85 0d		      sta	new_position+1
    166  12cd		       18		      clc
    167  12ce		       a5 0e		      lda	new_color_position	; load and add to low byte
    168  12d0		       69 01		      adc	#$1
    169  12d2		       85 0e		      sta	new_color_position
    170  12d4		       a5 0f		      lda	new_color_position+1
    171  12d6		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
    172  12d8		       85 0f		      sta	new_color_position+1
    173  12da		       60		      rts
    174  12db
    175  12db				   move_new_position_to_left
    176  12db		       38		      sec
    177  12dc		       a5 0c		      lda	new_position
    178  12de		       e9 01		      sbc	#$1
    179  12e0		       85 0c		      sta	new_position
    180  12e2		       a5 0d		      lda	new_position+1
    181  12e4		       e9 00		      sbc	#$0
    182  12e6		       85 0d		      sta	new_position+1
    183  12e8		       38		      sec
    184  12e9		       a5 0e		      lda	new_color_position
    185  12eb		       e9 01		      sbc	#$1
    186  12ed		       85 0e		      sta	new_color_position
    187  12ef		       a5 0f		      lda	new_color_position+1
    188  12f1		       e9 00		      sbc	#$0
    189  12f3		       85 0f		      sta	new_color_position+1
    190  12f5		       60		      rts
    191  12f6
    192  12f6
    193  12f6				   move_new_position_up
    194  12f6		       38		      sec
    195  12f7		       a5 0c		      lda	new_position
    196  12f9		       e9 16		      sbc	#ROW_SIZE
    197  12fb		       85 0c		      sta	new_position
    198  12fd		       a5 0d		      lda	new_position+1
    199  12ff		       e9 00		      sbc	#$0
    200  1301		       85 0d		      sta	new_position+1
    201  1303		       38		      sec
    202  1304		       a5 0e		      lda	new_color_position
    203  1306		       e9 16		      sbc	#ROW_SIZE
    204  1308		       85 0e		      sta	new_color_position
    205  130a		       a5 0f		      lda	new_color_position+1
    206  130c		       e9 00		      sbc	#$0
    207  130e		       85 0f		      sta	new_color_position+1
    208  1310		       60		      rts
    209  1311
    210  1311				   move_new_position_down
    211  1311		       18		      clc
    212  1312		       a5 0c		      lda	new_position	; load and add to low byte
    213  1314		       69 16		      adc	#ROW_SIZE
    214  1316		       85 0c		      sta	new_position
    215  1318		       a5 0d		      lda	new_position+1
    216  131a		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
    217  131c		       85 0d		      sta	new_position+1
    218  131e		       18		      clc
    219  131f		       a5 0e		      lda	new_color_position	; load and add to low byte
    220  1321		       69 16		      adc	#ROW_SIZE
    221  1323		       85 0e		      sta	new_color_position
    222  1325		       a5 0f		      lda	new_color_position+1
    223  1327		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
    224  1329		       85 0f		      sta	new_color_position+1
    225  132b		       60		      rts
    226  132c
    227  132c
    228  132c				   remove_char		; remove squarebot from current screen location
    229  132c		       a0 00		      ldy	#0
    230  132e		       a9 20		      lda	#BLANK_CHAR
    231  1330		       91 11		      sta	(squarebot_position),Y
    232  1332		       a9 01		      lda	#1
    233  1334		       91 13		      sta	(squarebot_color_position),Y
    234  1336		       60		      rts
    235  1337
    236  1337				   collision_handler		; accumulator is the character (the actual character code) in the position that squarbeot wants to move to
    237  1337							; set carry flag if we can move to this char, otherwise clear it
    238  1337		       c9 20		      cmp	#BLANK_CHAR
    239  1339		       f0 33		      beq	return_true
    240  133b
    241  133b		       c9 09		      CMP	#BOOSTER_CHAR
    242  133d		       d0 07		      bne	key_check
    243  133f		       a9 01		      lda	#1
    244  1341		       85 16		      sta	has_booster
    245  1343		       4c 6e 13 	      jmp	return_true
    246  1346
    247  1346				   key_check
    248  1346		       c9 05		      cmp	#KEY_CHAR
    249  1348		       d0 07		      bne	locked_wall_check
    250  134a		       a9 01		      lda	#1
    251  134c		       85 15		      sta	has_key
    252  134e		       4c 6e 13 	      jmp	return_true
    253  1351
    254  1351				   locked_wall_check
    255  1351		       c9 06		      cmp	#LOCKED_WALL_CHAR
    256  1353		       d0 1b		      bne	return_false
    257  1355
    258  1355		       a5 15		      lda	has_key	; if locked wall, but player doesnt have key, cant do anything
    259  1357		       c9 00		      cmp	#0
    260  1359		       f0 15		      beq	return_false
    261  135b
    262  135b		       a9 00		      lda	#0	; but if locked wall and has key, get rid of the locked wall and the key
    263  135d		       85 15		      sta	has_key
    264  135f		       4c 6e 13 	      jmp	return_true
    265  1362
    266  1362
    267  1362				   squarebot_on_first_row		; set carry flag to 0 if squarebot_position is on bottom of screen; otherwise set to 1
    268  1362		       a5 12		      lda	squarebot_position+1
    269  1364		       c9 1f		      cmp	#START_OF_FIRST_ROW_HIGH_BYTE
    270  1366		       90 08		      bcc	return_false	; compare high bits; return false if current position high bit is smaller than high bit of leftmost position on first row
    271  1368		       a5 11		      lda	squarebot_position
    272  136a		       c9 e4		      cmp	#START_OF_FIRST_ROW_LOW_BYTE
    273  136c		       90 02		      bcc	return_false
    274  136e
    275  136e				   return_true
    276  136e		       38		      sec
    277  136f		       60		      rts
    278  1370
    279  1370				   return_false
    280  1370		       18		      clc
    281  1371		       60		      rts
------- FILE src/main.s
    137  1372
    138  1372				   compressed_screen_data_start
    139  1372					      incbin	"../data/titleScreenData_compressed"	; got via 'bsave ""'
    140  13da
    141  13da				   level_data_start
    142  13da					      incbin	"../data/levels/binary_levels/1"
    143  13e2					      incbin	"../data/levels/binary_levels/booster_test"
    144  13f0					      incbin	"../data/levels/binary_levels/key_test"
    145  1406					      incbin	"../data/levels/binary_levels/2"
    146  141e					      incbin	"../data/levels/binary_levels/3"
    147  1476					      incbin	"../data/levels/binary_levels/4"
    148  14a2					      incbin	"../data/levels/binary_levels/5"
    149  14ce					      incbin	"../data/levels/binary_levels/6"
    150  14fe					      incbin	"../data/levels/binary_levels/7"
    151  156e					      incbin	"../data/levels/binary_levels/8"
    152  15f6
------- FILE memoryCheck.s LEVEL 2 PASS 3
      0  15f6					      include	"memoryCheck.s"	; code to make sure the program isn't too large and enters screen memory
      1  15f6		       05 f5	   BYTES_USED =	.-$1001	; location counter minus starting location = total bytes used
      2  15f6		       1e 00	   SCREEN_MEMORY_START =	$1e00
 1525 bytes used
      3  15f6					      echo	[BYTES_USED]d, "bytes used"
 Ending program at memory location (base 10):  5622
      4  15f6					      echo	"Ending program at memory location (base 10): ", [.]d
      5  15f6				  -	      if	. >= SCREEN_MEMORY_START	; if program entering screen memory
      6  15f6				  -	      echo	"Throwing error because program is too large, and has entered screen memory!"
      7  15f6				  -	      err
      8  15f6					      endif
------- FILE src/main.s
    154  15f6
    155  15f6
    156  1c00					      org	character_set_begin
    157  1c00		       81 ff ff 81*	      BYTE.b	129,255,255,129,129,255,255,129	; ladder 0
    158  1c08		       ff 81 a5 81*	      BYTE.b	255,129,165,129,189,165,129,255	; squarebot 1
    159  1c10		       ff ff 00 00*	      BYTE.b	255,255,0,0,0,0,0,0	; platform 2
    160  1c18		       ff ff ff ff*	      BYTE.b	255,255,255,255,255,255,255,255	; wall 3
    161  1c20		       7e e7 81 81*	      BYTE.b	126,231,129,129,225,129,129,255	; exit (door) 4
    162  1c28		       18 24 18 18*	      BYTE.b	24,36,24,24,30,24,30,24	; key powerup 5
    163  1c30		       ff ff ef ef*	      BYTE.b	255,255,239,239,239,227,255,255	;locked wall 6
    164  1c38		       ff bd fd b7*	      BYTE.b	255,189,253,183,127,239,231,255	; breakable wall 7
    165  1c40		       00 00 18 3c*	      BYTE.b	0,0,24,60,126,126,0,0	; spike 8
    166  1c48		       00 70 48 78*	      BYTE.b	0,112,72,120,72,72,112,0	; booster powerup 9
