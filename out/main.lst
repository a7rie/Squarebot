------- FILE src/main.s LEVEL 1 PASS 3
      1  1c98 ????						; title screen program -- use hand-made compression method (esentially just RLE, see rleEncoding.py)
      2  1c98 ????				      processor	6502
      3  1c98 ????
      4 U001f ????				      seg.u	ZP
      5 U0000					      org	$0
      6 U0000
      7 U0000
      8 U0000		       00 00	   screen_cursor ds.w	1	; stores the current screen memory address
      9 U0002		       00 00	   color_cursor ds.w	1	; store current color memory address
     10 U0004		       00 00	   current_level ds.w	1
     11 U0006		       00 00	   next_level ds.w	1
     12 U0008		       00	   level_reset ds.b	1
     13 U0009		       00	   level_completed ds.b	1
     14 U000a		       00	   level_data_index ds.b	1	; for temporarily saving index registers
     15 U000b		       00 00	   new_position ds.w	1	; use to store position of (proposed) new location for squarebot
     16 U000d		       00 00	   new_color_position ds.w	1	; use to store position of (proposed) new location for squarebot
     17 U000f		       00	   current_time ds.b	1	; store only the last byte of the jiffy clock
     18 U0010		       00 00	   squarebot_position ds.w	1
     19 U0012		       00 00	   squarebot_color_position ds.w	1
     20 U0014		       00	   jump_remaining ds.b	1	; number of times the character should continue to move upwards in the current jump
     21 U0015		       00 00 00    tileStore  ds.b	3	; UUUUDDDD LLLLRRRR 0000MMMM
     22 U0018							;colorStore ds.b 3 ; 0UUU0DDD 0LLL0RRR 00000MMM   not the most efficient storage but it needs to also be efficient to decompress
     23 U0018		       00 00	   attached_powerups ds.b	2	; 4 bits for each side, ordered U,D,L,R.
     24 U001a							; 0=none  1=readyBooster  2=activeBooster  3=key 4=spike(not implemented)  add more powerups here   8=ignitedBooster
     25 U001a		       00 00	   temp       ds.w	1	; for temporary storage of things. mainly used in updateGameState
     26 U001c		       00 00 00    charandr   ds.b	3	; for the incredibly complex operation of anding chars
     27  1c98 ????				      seg
     28  1c98 ????
     29  1c98 ????						; constants
     30  1c98 ????	       00 20	   BLANK_CHAR =	$20
     31  1c98 ????
     32  1c98 ????	       00 00	   SCREEN_CURSOR_BEGINNING_LOW_BYTE =	$00
     33  1c98 ????	       00 1e	   SCREEN_CURSOR_BEGINNING_HIGH_BYTE =	$1e
     34  1c98 ????
     35  1c98 ????						; last screen location
     36  1c98 ????	       00 fa	   END_OF_SCREEN_LOW_BYTE =	$fa
     37  1c98 ????	       00 1f	   END_OF_SCREEN_HIGH_BYTE =	$1f
     38  1c98 ????
     39  1c98 ????						; beginning of color memory
     40  1c98 ????	       00 00	   COLOR_CURSOR_BEGINNING_LOW_BYTE =	$00
     41  1c98 ????	       00 96	   COLOR_CURSOR_BEGINNING_HIGH_BYTE =	$96
     42  1c98 ????	       00 00	   RED_COLOR_CODE =	0
     43  1c98 ????
     44  1c98 ????	       00 20	   SPACE_KEY  =	$20
     45  1c98 ????	       00 09	   W_KEY      =	$09
     46  1c98 ????	       00 11	   A_KEY      =	$11
     47  1c98 ????	       00 29	   S_KEY      =	$29
     48  1c98 ????	       00 12	   D_KEY      =	$12
     49  1c98 ????	       00 0d	   SECRET_KEY =	$0d	; press P to skip to next  level
     50  1c98 ????	       00 0a	   RESET_KEY  =	$0a	; press R to restart level i assume
     51  1c98 ????	       00 03	   JUMP_SIZE  =	$3	; number of characters a jump causes
     52  1c98 ????	       00 16	   ROW_SIZE   =	$16
     53  1c98 ????						; memory locations
     54  1c98 ????	       10 01	   user_memory_start =	$1001
     55  1c98 ????	       00 c5	   currently_pressed_key =	$c5
     56  1c98 ????	       00 a0	   jiffy_clock =	$A0
     57  1c98 ????	       90 05	   character_info_register =	$9005
     58  1c98 ????	       1c 00	   character_set_begin =	$1c00
     59  1c98 ????
     60  1c98 ????						; begin location counter at 4096 (user memory)
     61  1001					      org	user_memory_start
------- FILE stub.s LEVEL 2 PASS 3
      0  1001					      include	"stub.s"	; stub contains BASIC sys cmd to run the machine language code
      1  1001		       00 9e	   SYS_CMD_TOKEN =	$9e
      2  1001		       00 0a	   STUB_LINE_NUMBER =	10
      3  1001							; BASIC stub -- SYS cmd to run machine language
      4  1001		       0b 10		      dc.w	nextstmt	; link; beginning of basic
      5  1003		       0a 00		      dc.w	STUB_LINE_NUMBER	; line number
      6  1005		       9e 34 31 30*	      dc.b	SYS_CMD_TOKEN, [start]d, 0	; token for sys with operand as address to "start" label
      7  100b				   nextstmt
      8  100b		       00 00		      dc.w	0
------- FILE src/main.s
     63  100d
     64  100d				   start
     65  100d							; use combination of RAM (first 128 chars at 7168) & ROM character set
     66  100d		       a9 ff		      lda	#255
     67  100f		       8d 05 90 	      sta	character_info_register
     68  1012
     69  1012							; initialize some variables in the zero page
     70  1012		       a9 01		      lda	#1
     71  1014		       85 08		      sta	level_reset
     72  1016		       a9 00		      lda	#0
     73  1018		       85 09		      sta	level_completed
     74  101a
     75  101a		       a9 3a		      lda	#<level_data_start
     76  101c		       85 04		      sta	current_level
     77  101e		       a9 17		      lda	#>level_data_start
     78  1020		       85 05		      sta	current_level+1
     79  1022
     80  1022		       a9 00		      lda	#0
     81  1024		       85 14		      sta	jump_remaining
     82  1026		       85 18		      sta	attached_powerups
     83  1028		       85 19		      sta	attached_powerups+1
     84  102a		       85 15		      sta	tileStore
     85  102c		       85 16		      sta	tileStore+1
     86  102e		       85 17		      sta	tileStore+2
     87  1030
------- FILE titleScreen.s LEVEL 2 PASS 3
      0  1030					      include	"titleScreen.s"
      1  1030				   display_title_screen
      2  1030		       a9 00		      lda	#SCREEN_CURSOR_BEGINNING_LOW_BYTE
      3  1032		       85 00		      sta	screen_cursor
      4  1034		       a9 1e		      lda	#SCREEN_CURSOR_BEGINNING_HIGH_BYTE	; store 1e in location 01
      5  1036		       85 01		      sta	screen_cursor+1
      6  1038
      7  1038		       a9 00		      lda	#COLOR_CURSOR_BEGINNING_LOW_BYTE
      8  103a		       85 02		      sta	color_cursor
      9  103c		       a9 96		      lda	#COLOR_CURSOR_BEGINNING_HIGH_BYTE
     10  103e		       85 03		      sta	color_cursor+1
     11  1040
     12  1040		       a0 00		      ldy	#$0	; to use for indirect indexed addressing
     13  1042		       a2 00		      ldx	#$0
     14  1044
     15  1044		       20 50 10 	      jsr	draw_title_screen_loop
     16  1047
     17  1047				   infinite_loop
     18  1047		       a5 c5		      lda	currently_pressed_key
     19  1049		       c9 20		      cmp	#SPACE_KEY
     20  104b		       f0 5c		      beq	gameLoop
     21  104d		       4c 47 10 	      jmp	infinite_loop
     22  1050
     23  1050
     24  1050				   draw_title_screen_loop
     25  1050		       bd d2 16 	      lda	compressed_screen_data_start,X	; accumulator stores num times to repeat the byte
     26  1053		       20 5e 10 	      jsr	draw_character	; draw the character that many times
     27  1056		       e8		      inx
     28  1057		       e8		      inx
     29  1058		       20 99 10 	      jsr	check_if_screen_cursor_at_end
     30  105b		       90 f3		      bcc	draw_title_screen_loop
     31  105d		       60		      rts
     32  105e
     33  105e
     34  105e							; draw the character in Y register for (value of accumulator) number of times
     35  105e				   draw_character
     36  105e							; if accumulator == 0, return; otherwise, subtract 1 from accumulator and continue drawing the letter at Y
     37  105e		       f0 1d		      beq	draw_character_end
     38  1060		       38		      sec
     39  1061		       e9 01		      sbc	#1
     40  1063		       48		      pha		; push accumulator onto stack
     41  1064
     42  1064							; store current char at screen cursor location
     43  1064		       a0 00		      ldy	#0
     44  1066		       bd d3 16 	      lda	compressed_screen_data_start+1,X	; load cur char to draw
     45  1069		       18		      clc
     46  106a		       69 80		      adc	#128
     47  106c		       91 00		      sta	(screen_cursor),Y	; draw it on screen
     48  106e
     49  106e							; add color to the screen location if it's not a space
     50  106e							; because our title screen only has one color, and only displays it for characters that arent space, we can get away with this "optimization",
     51  106e							; and avoid adding color data
     52  106e		       c9 20		      cmp	#BLANK_CHAR
     53  1070		       f0 04		      beq	dont_color
     54  1072		       a9 00		      lda	#RED_COLOR_CODE
     55  1074		       91 02		      sta	(color_cursor),Y
     56  1076
     57  1076				   dont_color
     58  1076		       20 7e 10 	      jsr	add_one_to_screen_cursor
     59  1079		       68		      pla		; put the current 'count' (remaining times to draw character) back on accumulator
     60  107a		       4c 5e 10 	      jmp	draw_character
     61  107d
     62  107d				   draw_character_end
     63  107d		       60		      rts
     64  107e
     65  107e
     66  107e
     67  107e				   add_one_to_screen_cursor
     68  107e		       18		      clc
     69  107f		       a5 00		      lda	screen_cursor	; load and add to low byte
     70  1081		       69 01		      adc	#$1
     71  1083		       85 00		      sta	screen_cursor
     72  1085		       a5 01		      lda	screen_cursor+1
     73  1087		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
     74  1089		       85 01		      sta	screen_cursor+1
     75  108b
     76  108b							; add to color cursor as well
     77  108b		       18		      clc
     78  108c		       a5 02		      lda	color_cursor	; load and add to low byte
     79  108e		       69 01		      adc	#$1
     80  1090		       85 02		      sta	color_cursor
     81  1092		       a5 03		      lda	color_cursor+1
     82  1094		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
     83  1096		       85 03		      sta	color_cursor+1
     84  1098		       60		      rts
     85  1099
     86  1099				   check_if_screen_cursor_at_end		; set carry flag if screen_cursor at position $1ff9 (8185
     87  1099		       a5 00		      lda	screen_cursor	; load value at screen_cursor low byte
     88  109b		       c9 fa		      cmp	#END_OF_SCREEN_LOW_BYTE
     89  109d		       d0 06		      bne	check_if_screen_cursor_at_end_return_false	; if low byte doesnt match, return with carry flag as neg
     90  109f
     91  109f		       a5 01		      lda	screen_cursor+1
     92  10a1		       c9 1f		      cmp	#END_OF_SCREEN_HIGH_BYTE
     93  10a3		       f0 02		      beq	check_if_screen_cursor_at_end_return_true	; if high byte matches, set carry flag
     94  10a5
     95  10a5				   check_if_screen_cursor_at_end_return_false
     96  10a5		       18		      clc
     97  10a6		       60		      rts
     98  10a7
     99  10a7				   check_if_screen_cursor_at_end_return_true
    100  10a7		       38		      sec
    101  10a8		       60		      rts
------- FILE src/main.s
     89  10a9
     90  10a9							; title screen code jumps here once space pressed
     91  10a9				   gameLoop
     92  10a9		       20 f1 10 	      jsr	update_level
     93  10ac		       a9 00		      lda	#0
     94  10ae		       85 08		      sta	level_reset
     95  10b0		       20 0a 12 	      jsr	update_game_state
     96  10b3		       20 d7 10 	      jsr	check_for_secret_key
     97  10b6		       20 e6 10 	      jsr	check_for_reset_key
     98  10b9		       20 ce 10 	      jsr	wait_until_next_frame
     99  10bc		       20 ce 10 	      jsr	wait_until_next_frame
    100  10bf		       20 ce 10 	      jsr	wait_until_next_frame
    101  10c2		       20 ce 10 	      jsr	wait_until_next_frame
    102  10c5		       20 ce 10 	      jsr	wait_until_next_frame
    103  10c8		       20 ce 10 	      jsr	wait_until_next_frame
    104  10cb		       4c a9 10 	      jmp	gameLoop
    105  10ce
    106  10ce
    107  10ce				   wait_until_next_frame		; wait one jiffy before completing game loop
    108  10ce		       a5 a2		      lda	jiffy_clock+2
    109  10d0		       c5 0f		      cmp	current_time
    110  10d2		       f0 fa		      beq	wait_until_next_frame
    111  10d4		       85 0f		      sta	current_time
    112  10d6		       60		      rts
    113  10d7
    114  10d7							; update level_completed and level_reset if secret_key pressed
    115  10d7				   check_for_secret_key
    116  10d7		       a5 c5		      lda	currently_pressed_key
    117  10d9		       c9 0d		      cmp	#SECRET_KEY
    118  10db		       d0 08		      bne	check_for_secret_key_return
    119  10dd		       a9 01		      lda	#1
    120  10df		       85 09		      sta	level_completed
    121  10e1		       a9 01		      lda	#1
    122  10e3		       85 08		      sta	level_reset
    123  10e5				   check_for_secret_key_return
    124  10e5		       60		      rts
    125  10e6
    126  10e6				   check_for_reset_key
    127  10e6		       a5 c5		      lda	currently_pressed_key
    128  10e8		       c9 0a		      cmp	#RESET_KEY
    129  10ea		       d0 f9		      bne	check_for_secret_key_return	; todo -- reset  a bunch of state (has_key, )
    130  10ec		       a9 01		      lda	#1
    131  10ee		       85 08		      sta	level_reset
    132  10f0				   check_for_reset_key_return
    133  10f0		       60		      rts
    134  10f1
------- FILE updateLevel.s LEVEL 2 PASS 3
      0  10f1					      include	"updateLevel.s"
      1  10f1		       00 01	   LEVEL_IS_DONE =	1
      2  10f1		       00 00	   LEVEL_NOT_DONE =	0
      3  10f1		       00 01	   SHOULD_RESET =	1
      4  10f1		       00 00	   SHOULD_NOT_RESET =	0
      5  10f1
      6  10f1							; only first 4 bits really matter here; refer to readme for guide on lvl format
      7  10f1		       00 00	   BLANK_SPACE =	0	; 000000000
      8  10f1		       00 10	   STARTING_POINT =	16	; 00010000
      9  10f1		       00 20	   WALL       =	32	; 00100000
     10  10f1		       00 30	   BREAKABLE_WALL =	48	; 00110000
     11  10f1		       00 40	   LOCKED_WALL =	64	; 01000000
     12  10f1		       00 50	   LADDER     =	80	; 01010000
     13  10f1		       00 60	   EXIT       =	96	; 01100000
     14  10f1		       00 70	   PLATFORM   =	112	; 01110000
     15  10f1		       00 80	   KEY	      =	128	; 10000000
     16  10f1		       00 90	   SPIKE      =	144	; 10010000
     17  10f1		       00 a0	   BOOSTER    =	160	; 10100000
     18  10f1
     19  10f1		       00 00	   WALL_COLOR =	0
     20  10f1		       00 00	   BREAKABLE_WALL_COLOR =	0
     21  10f1		       00 00	   LOCKED_WALL_COLOR =	0
     22  10f1		       00 00	   LADDER_COLOR =	0	;6
     23  10f1		       00 00	   EXIT_COLOR =	0	;6
     24  10f1		       00 00	   PLATFORM_COLOR =	0	;4
     25  10f1		       00 00	   SPIKE_COLOR =	0	;2
     26  10f1		       00 00	   KEY_P_COLOR =	0	;7
     27  10f1		       00 00	   SPIKE_P_COLOR =	0	;6
     28  10f1		       00 00	   BOOSTER_P_COLOR =	0	;6
     29  10f1		       00 02	   SQUAREBOT_COLOR =	2
     30  10f1
     31  10f1		       00 00	   BLANK_TILE_CHAR =	$00	; use this instead of BLANK_CHAR, allows me to save space with tileStore
     32  10f1		       00 01	   LADDER_CHAR =	$01
     33  10f1		       00 02	   PLATFORM_CHAR =	$02
     34  10f1		       00 03	   WALL_CHAR  =	$03
     35  10f1		       00 04	   EXIT_CHAR  =	$04
     36  10f1		       00 05	   LOCKED_WALL_CHAR =	$05
     37  10f1		       00 06	   BREAKABLE_WALL_CHAR =	$06
     38  10f1		       00 07	   BOOSTER_P_CHAR =	$07
     39  10f1		       00 08	   KEY_P_CHAR =	$08
     40  10f1		       00 09	   SPIKE_P_CHAR =	$09
     41  10f1		       00 0a	   BOOSTER_A_CHAR =	$0A
     42  10f1		       00 0b	   BOOSTER_AA_CHAR =	$0B
     43  10f1		       00 0c	   KEY_A_CHAR =	$0C
     44  10f1		       00 0d	   SPIKE_A_CHAR =	$0D
     45  10f1		       00 0e	   CHAR_U     =	$0E
     46  10f1		       00 0f	   CHAR_D     =	$0F
     47  10f1		       00 10	   CHAR_L     =	$10
     48  10f1		       00 11	   CHAR_R     =	$11
     49  10f1		       00 12	   SQUAREBOT_CHAR =	$12
     50  10f1
     51  10f1
     52  10f1				   update_level
     53  10f1							; check if the level is completed; set current_level to next_level if so
     54  10f1		       a5 09		      lda	level_completed
     55  10f3		       c9 01		      cmp	#LEVEL_IS_DONE	; (try optimizing later)
     56  10f5		       d0 0c		      bne	dont_update
     57  10f7
     58  10f7							; level is done; reset level completed
     59  10f7		       a9 00		      lda	#LEVEL_NOT_DONE
     60  10f9		       85 09		      sta	level_completed
     61  10fb
     62  10fb							; now set current_level to next_level
     63  10fb		       a5 06		      lda	next_level
     64  10fd		       85 04		      sta	current_level
     65  10ff		       a5 07		      lda	next_level+1
     66  1101		       85 05		      sta	current_level+1
     67  1103
     68  1103				   dont_update
     69  1103							; now check if level reset was set
     70  1103		       a5 08		      lda	level_reset
     71  1105		       c9 00		      cmp	#0
     72  1107		       d0 01		      bne	continue_update	; if not, go back to game loop
     73  1109		       60		      rts
     74  110a
     75  110a				   continue_update
     76  110a							; if it was, update the level
     77  110a		       a9 00		      lda	#SCREEN_CURSOR_BEGINNING_LOW_BYTE
     78  110c		       85 00		      sta	screen_cursor
     79  110e		       a9 1e		      lda	#SCREEN_CURSOR_BEGINNING_HIGH_BYTE
     80  1110		       85 01		      sta	screen_cursor+1
     81  1112
     82  1112		       a9 00		      lda	#COLOR_CURSOR_BEGINNING_LOW_BYTE
     83  1114		       85 02		      sta	color_cursor
     84  1116		       a9 96		      lda	#COLOR_CURSOR_BEGINNING_HIGH_BYTE
     85  1118		       85 03		      sta	color_cursor+1
     86  111a
     87  111a		       a2 00		      ldx	#0
     88  111c		       a0 00		      ldy	#0
     89  111e		       84 0a		      sty	level_data_index
     90  1120
     91  1120		       a9 00		      lda	#0
     92  1122		       85 14		      sta	jump_remaining
     93  1124		       85 18		      sta	attached_powerups
     94  1126		       85 19		      sta	attached_powerups+1
     95  1128		       85 15		      sta	tileStore
     96  112a		       85 16		      sta	tileStore+1
     97  112c		       85 17		      sta	tileStore+2
     98  112e
     99  112e							; draw (or redraw on reset) the current level
    100  112e				   draw_level_loop
    101  112e							; y stores our index in the current level data
    102  112e		       a4 0a		      ldy	level_data_index
    103  1130		       b1 04		      lda	(current_level),y	; accumulator stores the number of times to repeat the next byte
    104  1132
    105  1132		       20 4e 11 	      jsr	draw_sequence
    106  1135
    107  1135		       a4 0a		      ldy	level_data_index
    108  1137		       c8		      iny		; set y to point to next length byte (iterate 2 at a time)
    109  1138		       c8		      iny
    110  1139		       84 0a		      sty	level_data_index
    111  113b
    112  113b
    113  113b		       20 99 10 	      jsr	check_if_screen_cursor_at_end
    114  113e		       90 ee		      bcc	draw_level_loop
    115  1140
    116  1140
    117  1140							; update next level pointer to point to byte after current level
    118  1140		       a5 04		      lda	current_level
    119  1142		       18		      clc
    120  1143		       65 0a		      adc	level_data_index
    121  1145		       85 06		      sta	next_level
    122  1147		       a5 05		      lda	current_level+1
    123  1149		       69 00		      adc	#0
    124  114b		       85 07		      sta	next_level+1
    125  114d		       60		      rts
    126  114e
    127  114e
    128  114e
    129  114e				   draw_sequence
    130  114e							; if acc == 0, return; otherwise subtract 1, draw the next 2 chars
    131  114e		       f0 1c		      beq	draw_sequence_end
    132  1150		       38		      sec
    133  1151		       e9 01		      sbc	#1
    134  1153		       48		      pha		; push accumulator onto stack
    135  1154
    136  1154		       a4 0a		      ldy	level_data_index
    137  1156		       c8		      iny		; (so we can access the "element" byte after the length byte)
    138  1157		       b1 04		      lda	(current_level),y	; get formatted byte (see squarebot doc)
    139  1159		       0a		      asl		; lol
    140  115a		       0a		      asl
    141  115b		       0a		      asl
    142  115c		       0a		      asl
    143  115d		       20 6d 11 	      jsr	draw_high_bits	; draw char represented by the 4 high bits
    144  1160
    145  1160		       a4 0a		      ldy	level_data_index
    146  1162		       c8		      iny
    147  1163
    148  1163		       b1 04		      lda	(current_level),y
    149  1165		       20 6d 11 	      jsr	draw_high_bits
    150  1168
    151  1168		       68		      pla
    152  1169		       4c 4e 11 	      jmp	draw_sequence
    153  116c
    154  116c				   draw_sequence_end
    155  116c		       60		      rts
    156  116d
    157  116d
    158  116d							; put the character in the high 4 bits of accumulator on screen (see readme), and move the color and screen cursors ahead
    159  116d				   draw_high_bits
    160  116d		       29 f0		      and	#240	; shave off last 4 bits
    161  116f
    162  116f		       c9 00		      cmp	#BLANK_SPACE
    163  1171		       d0 08		      bne	check_if_starting_point
    164  1173		       a9 00		      lda	#BLANK_TILE_CHAR	; todo; replace with actual chars
    165  1175		       a2 01		      ldx	#1
    166  1177		       20 ff 11 	      jsr	draw_char_in_accumulator
    167  117a		       60		      rts
    168  117b
    169  117b				   check_if_starting_point
    170  117b		       c9 10		      cmp	#STARTING_POINT
    171  117d		       d0 18		      bne	check_if_wall
    172  117f
    173  117f							; set squarebot to starting point
    174  117f		       a5 00		      lda	screen_cursor
    175  1181		       85 10		      sta	squarebot_position
    176  1183		       a5 01		      lda	screen_cursor+1
    177  1185		       85 11		      sta	squarebot_position+1
    178  1187
    179  1187		       a5 02		      lda	color_cursor
    180  1189		       85 12		      sta	squarebot_color_position
    181  118b		       a5 03		      lda	color_cursor+1
    182  118d		       85 13		      sta	squarebot_color_position+1
    183  118f
    184  118f		       a9 12		      lda	#SQUAREBOT_CHAR
    185  1191		       a2 02		      ldx	#SQUAREBOT_COLOR
    186  1193		       20 ff 11 	      jsr	draw_char_in_accumulator
    187  1196
    188  1196		       60		      rts
    189  1197
    190  1197
    191  1197				   check_if_wall
    192  1197		       c9 20		      cmp	#WALL
    193  1199		       d0 08		      bne	check_if_breakable_wall
    194  119b		       a9 03		      lda	#WALL_CHAR
    195  119d		       a2 00		      ldx	#WALL_COLOR
    196  119f		       20 ff 11 	      jsr	draw_char_in_accumulator
    197  11a2		       60		      rts
    198  11a3
    199  11a3				   check_if_breakable_wall
    200  11a3		       c9 30		      cmp	#BREAKABLE_WALL
    201  11a5		       d0 08		      bne	check_if_locked_wall
    202  11a7		       a9 06		      lda	#BREAKABLE_WALL_CHAR
    203  11a9		       a2 00		      ldx	#BREAKABLE_WALL_COLOR
    204  11ab		       20 ff 11 	      jsr	draw_char_in_accumulator
    205  11ae		       60		      rts
    206  11af
    207  11af				   check_if_locked_wall
    208  11af		       c9 40		      cmp	#LOCKED_WALL
    209  11b1		       d0 08		      bne	check_if_ladder
    210  11b3		       a9 05		      lda	#LOCKED_WALL_CHAR
    211  11b5		       a2 00		      ldx	#LOCKED_WALL_COLOR
    212  11b7		       20 ff 11 	      jsr	draw_char_in_accumulator
    213  11ba		       60		      rts
    214  11bb
    215  11bb				   check_if_ladder
    216  11bb		       c9 50		      cmp	#LADDER
    217  11bd		       d0 08		      bne	check_if_exit
    218  11bf		       a9 01		      lda	#LADDER_CHAR
    219  11c1		       a2 00		      ldx	#LADDER_COLOR
    220  11c3		       20 ff 11 	      jsr	draw_char_in_accumulator
    221  11c6		       60		      rts
    222  11c7
    223  11c7				   check_if_exit
    224  11c7		       c9 60		      cmp	#EXIT
    225  11c9		       d0 08		      bne	check_if_platform
    226  11cb		       a9 04		      lda	#EXIT_CHAR
    227  11cd		       a2 00		      ldx	#EXIT_COLOR
    228  11cf		       20 ff 11 	      jsr	draw_char_in_accumulator
    229  11d2		       60		      rts
    230  11d3
    231  11d3				   check_if_platform
    232  11d3		       c9 70		      cmp	#PLATFORM
    233  11d5		       d0 08		      bne	check_if_key
    234  11d7		       a9 02		      lda	#PLATFORM_CHAR
    235  11d9		       a2 00		      ldx	#PLATFORM_COLOR
    236  11db		       20 ff 11 	      jsr	draw_char_in_accumulator
    237  11de		       60		      rts
    238  11df
    239  11df				   check_if_key
    240  11df		       c9 80		      cmp	#KEY
    241  11e1		       d0 08		      bne	check_if_spike
    242  11e3		       a9 08		      lda	#KEY_P_CHAR
    243  11e5		       a2 00		      ldx	#KEY_P_COLOR
    244  11e7		       20 ff 11 	      jsr	draw_char_in_accumulator
    245  11ea		       60		      rts
    246  11eb
    247  11eb				   check_if_spike
    248  11eb		       c9 90		      cmp	#SPIKE
    249  11ed		       d0 08		      bne	check_if_booster
    250  11ef		       a9 09		      lda	#SPIKE_P_CHAR
    251  11f1		       a2 00		      ldx	#SPIKE_P_COLOR
    252  11f3		       20 ff 11 	      jsr	draw_char_in_accumulator
    253  11f6		       60		      rts
    254  11f7
    255  11f7				   check_if_booster
    256  11f7		       a9 07		      lda	#BOOSTER_P_CHAR
    257  11f9		       a2 00		      ldx	#BOOSTER_P_COLOR
    258  11fb		       20 ff 11 	      jsr	draw_char_in_accumulator
    259  11fe		       60		      rts
    260  11ff
    261  11ff
    262  11ff
    263  11ff							; char in accumulator goes in screen cursor, color in x register goes in color cursor, then update cursors
    264  11ff
    265  11ff				   draw_char_in_accumulator
    266  11ff		       a0 00		      ldy	#0
    267  1201		       91 00		      sta	(screen_cursor),y
    268  1203
    269  1203		       8a		      txa
    270  1204		       91 02		      sta	(color_cursor),y
    271  1206
    272  1206		       20 7e 10 	      jsr	add_one_to_screen_cursor	; add to both screen and color cursor
    273  1209		       60		      rts
------- FILE src/main.s
------- FILE updateGameState_new.s LEVEL 2 PASS 3
      0  120a					      include	"updateGameState_new.s"
      1  120a		       00 e4	   START_OF_FIRST_ROW_LOW_BYTE =	$e4
      2  120a		       00 1f	   START_OF_FIRST_ROW_HIGH_BYTE =	$1f
      3  120a
      4  120a				   update_game_state
      5  120a		       a5 10		      lda	squarebot_position	; likely unnecessary
      6  120c		       85 0b		      sta	new_position
      7  120e		       a5 11		      lda	squarebot_position+1
      8  1210		       85 0c		      sta	new_position+1
      9  1212		       a5 12		      lda	squarebot_color_position
     10  1214		       85 0d		      sta	new_color_position
     11  1216		       a5 13		      lda	squarebot_color_position+1
     12  1218		       85 0e		      sta	new_color_position+1
     13  121a
     14  121a				   check_if_d_pressed
     15  121a		       a5 c5		      lda	currently_pressed_key
     16  121c		       c9 12		      cmp	#D_KEY
     17  121e		       d0 61		      bne	check_if_a_pressed
     18  1220				   d_pressed
     19  1220		       a9 00		      lda	#$0
     20  1222		       85 1a		      sta	temp	; preset temp to 0 here so collision_handler logic is simpler
     21  1224		       20 50 15 	      jsr	get_right
     22  1227		       c9 04		      cmp	#EXIT_CHAR	; check here if we finish the level so we can rts to game loop
     23  1229		       d0 07		      bne	cont_r
     24  122b		       a9 01		      lda	#1	; finish level
     25  122d		       85 09		      sta	level_completed
     26  122f		       85 08		      sta	level_reset
     27  1231		       60		      rts
     28  1232				   cont_r
     29  1232		       20 e5 12 	      jsr	collision_handler	; check rest of collision
     30  1235		       90 48		      bcc	hop_to_handle_jump_logic	; collided
     31  1237		       a5 1a		      lda	temp	; check for powerup (from collision_handler)
     32  1239		       c9 00		      cmp	#$0	; collision handler will put a 0 here unless we hit a powerup
     33  123b		       f0 12		      beq	post_powerup_r
     34  123d		       29 0f		      and	#$0F	; save right
     35  123f		       85 1a		      sta	temp
     36  1241		       a9 f0		      lda	#$F0	; its a powerup, add the powerup to attached_powerup
     37  1243		       25 19		      and	attached_powerups+1
     38  1245		       65 1a		      adc	temp
     39  1247		       85 19		      sta	attached_powerups+1
     40  1249		       a9 f0		      lda	#$F0	; clear right of powerup
     41  124b		       25 16		      and	tileStore+1
     42  124d		       85 16		      sta	tileStore+1
     43  124f				   post_powerup_r
     44  124f		       20 28 14 	      jsr	delete_squarebot	; delete character
     45  1252		       20 aa 15 	      jsr	move_new_position_right	; new position is where we want to move
     46  1255		       20 82 16 	      jsr	get_tiles_r
     47  1258		       a5 19		      lda	attached_powerups+1	; if left powerup is readyBooster, change it to ignitedBooster, since apply_powerup_logic doesn't have directional context
     48  125a		       29 f0		      and	#$F0
     49  125c		       c9 10		      cmp	#$10
     50  125e		       d0 0b		      bne	no_booster_r
     51  1260		       a5 19		      lda	attached_powerups+1
     52  1262		       29 0f		      and	#$0F
     53  1264		       69 80		      adc	#$80	; turn on the ignition
     54  1266		       85 19		      sta	attached_powerups+1
     55  1268		       20 1e 13 	      jsr	apply_powerup_logic
     56  126b				   no_booster_r
     57  126b		       20 64 14 	      jsr	update_squarebot	; update squarebot_position and its color pos
     58  126e		       20 75 14 	      jsr	update_chars	; redraw adjacent characters
     59  1271		       20 17 15 	      jsr	draw_squarebot	; put squarebot on screen
     60  1274							;perhaps we wait a jiffy
     61  1274		       a5 19		      lda	attached_powerups+1	; booster time, if we activated booster we move again in the same frame before handling jump logic
     62  1276		       29 f0		      and	#$F0
     63  1278		       c9 20		      cmp	#$20
     64  127a		       f0 a4		      beq	d_pressed
     65  127c		       4c e4 12 	      jmp	handle_jump_logic	; now we handle going up and down
     66  127f
     67  127f				   hop_to_handle_jump_logic
     68  127f		       90 63		      bcc	handle_jump_logic	;dang code is long, hoping to use this trick as few times as possible
     69  1281
     70  1281				   check_if_a_pressed
     71  1281		       c9 11		      cmp	#A_KEY
     72  1283		       d0 5f		      bne	handle_jump_logic
     73  1285				   a_pressed
     74  1285		       a9 00		      lda	#$0
     75  1287		       85 1a		      sta	temp	; preset temp to 0 here so collision_handler logic is simpler
     76  1289		       20 55 15 	      jsr	get_left
     77  128c		       c9 04		      cmp	#EXIT_CHAR	; finish level check
     78  128e		       d0 07		      bne	cont_l
     79  1290		       a9 01		      lda	#1	; finish level
     80  1292		       85 09		      sta	level_completed
     81  1294		       85 08		      sta	level_reset
     82  1296		       60		      rts
     83  1297				   cont_l
     84  1297		       20 e5 12 	      jsr	collision_handler	; check collision
     85  129a		       90 48		      bcc	handle_jump_logic
     86  129c		       a5 1a		      lda	temp
     87  129e		       c9 00		      cmp	#$0
     88  12a0		       f0 12		      beq	post_powerup_l
     89  12a2		       29 f0		      and	#$F0	; save left
     90  12a4		       85 1a		      sta	temp
     91  12a6		       a9 0f		      lda	#$0F	; assume we hit a powerup
     92  12a8		       25 19		      and	attached_powerups+1
     93  12aa		       65 1a		      adc	temp
     94  12ac		       85 19		      sta	attached_powerups+1
     95  12ae		       a9 0f		      lda	#$0F	; clear left of powerup
     96  12b0		       25 16		      and	tileStore+1
     97  12b2		       85 16		      sta	tileStore+1
     98  12b4				   post_powerup_l
     99  12b4		       20 28 14 	      jsr	delete_squarebot	; delete character
    100  12b7		       20 c5 15 	      jsr	move_new_position_left
    101  12ba		       20 aa 16 	      jsr	get_tiles_l
    102  12bd		       a5 19		      lda	attached_powerups+1
    103  12bf		       29 0f		      and	#$0F
    104  12c1		       c9 01		      cmp	#$01
    105  12c3		       d0 0b		      bne	no_booster_l
    106  12c5		       a5 19		      lda	attached_powerups+1
    107  12c7		       29 f0		      and	#$F0
    108  12c9		       69 08		      adc	#$08	; turn on the ignition
    109  12cb		       85 19		      sta	attached_powerups+1
    110  12cd		       20 1e 13 	      jsr	apply_powerup_logic
    111  12d0				   no_booster_l
    112  12d0		       20 64 14 	      jsr	update_squarebot	; update squarebot_position and its color pos
    113  12d3		       20 75 14 	      jsr	update_chars	; redraw adjacent characters
    114  12d6		       20 17 15 	      jsr	draw_squarebot	; put squarebot on screen
    115  12d9							;perhaps we wait a jiffy
    116  12d9		       a5 19		      lda	attached_powerups+1	; booster time, if we activated booster we move again in the same frame before handling jump logic
    117  12db		       29 0f		      and	#$0F
    118  12dd		       c9 02		      cmp	#$02
    119  12df		       f0 a4		      beq	a_pressed
    120  12e1		       4c e4 12 	      jmp	handle_jump_logic	; now we handle going up and down  
    121  12e4
    122  12e4				   handle_jump_logic
    123  12e4		       60		      rts
    124  12e5
    125  12e5				   collision_handler		; accumulator is the character in the position that squarebot wants to move to
    126  12e5							; set carry flag if we can move to this char, otherwise clear it
    127  12e5							; if its a powerup, set temp to be the attached_powerup id + attached_powerup id <<4, otherwise return since temp is already 0
    128  12e5		       c9 00		      cmp	#BLANK_TILE_CHAR
    129  12e7		       f0 31		      beq	return_true
    130  12e9		       c9 02		      cmp	#PLATFORM_CHAR
    131  12eb		       f0 2d		      beq	return_true	; moving down will double check anyway
    132  12ed							;I'll figure out ladders later
    133  12ed		       c9 03		      cmp	#WALL_CHAR
    134  12ef		       f0 2b		      beq	return_false
    135  12f1		       c9 06		      cmp	#BREAKABLE_WALL_CHAR
    136  12f3		       f0 27		      beq	return_false
    137  12f5		       c9 05		      cmp	#LOCKED_WALL_CHAR
    138  12f7		       f0 23		      beq	return_false
    139  12f9							;else its a powerup
    140  12f9		       c9 07		      cmp	#BOOSTER_P_CHAR
    141  12fb		       d0 07		      bne	rpk
    142  12fd		       a9 11		      lda	#$11	;set both hex characters to avoid dumb shifts taking up lots of space
    143  12ff		       85 1a		      sta	temp
    144  1301		       4c 1a 13 	      jmp	return_true
    145  1304				   rpk
    146  1304		       c9 08		      cmp	#KEY_P_CHAR
    147  1306		       d0 07		      bne	rps
    148  1308		       a9 33		      lda	#$33
    149  130a		       85 1a		      sta	temp
    150  130c		       4c 1a 13 	      jmp	return_true
    151  130f				   rps
    152  130f		       c9 09		      cmp	#SPIKE_P_CHAR
    153  1311		       d0 09		      bne	return_false
    154  1313		       a9 44		      lda	#$44
    155  1315		       85 1a		      sta	temp
    156  1317		       4c 1a 13 	      jmp	return_true
    157  131a
    158  131a				   return_true
    159  131a		       38		      sec
    160  131b		       60		      rts
    161  131c
    162  131c				   return_false
    163  131c		       18		      clc
    164  131d		       60		      rts
    165  131e
    166  131e				   apply_powerup_logic
    167  131e							; ready bosoter: does nothing
    168  131e							; ignited booster: breaks breakable walls and changes to active booster 
    169  131e							; active booster: breaks breakable walls and changes to ready booster
    170  131e							; key: spends itself to break locked walls
    171  131e		       a5 18		      lda	attached_powerups
    172  1320		       85 1a		      sta	temp
    173  1322		       20 61 15 	      jsr	get_up
    174  1325		       0a		      asl
    175  1326		       0a		      asl
    176  1327		       0a		      asl
    177  1328		       0a		      asl
    178  1329		       85 1b		      sta	temp+1
    179  132b		       20 5c 15 	      jsr	get_down
    180  132e		       65 1b		      adc	temp+1
    181  1330		       85 1b		      sta	temp+1
    182  1332		       20 75 13 	      jsr	power_pair_logic
    183  1335		       a5 1a		      lda	temp
    184  1337		       85 18		      sta	attached_powerups
    185  1339		       a5 1b		      lda	temp+1
    186  133b		       4a		      lsr
    187  133c		       4a		      lsr
    188  133d		       4a		      lsr
    189  133e		       4a		      lsr
    190  133f		       20 95 15 	      jsr	set_up	; setting a tile effectively changes that character
    191  1342		       a5 1b		      lda	temp+1
    192  1344		       29 0f		      and	#$0F
    193  1346		       20 89 15 	      jsr	set_down
    194  1349
    195  1349		       a5 19		      lda	attached_powerups+1
    196  134b		       85 1a		      sta	temp
    197  134d		       20 55 15 	      jsr	get_left
    198  1350		       0a		      asl
    199  1351		       0a		      asl
    200  1352		       0a		      asl
    201  1353		       0a		      asl
    202  1354		       85 1b		      sta	temp+1
    203  1356		       20 50 15 	      jsr	get_right
    204  1359		       65 1b		      adc	temp+1
    205  135b		       85 1b		      sta	temp+1
    206  135d		       20 75 13 	      jsr	power_pair_logic
    207  1360		       a5 1a		      lda	temp
    208  1362		       85 19		      sta	attached_powerups+1
    209  1364		       a5 1b		      lda	temp+1
    210  1366		       4a		      lsr
    211  1367		       4a		      lsr
    212  1368		       4a		      lsr
    213  1369		       4a		      lsr
    214  136a		       20 79 15 	      jsr	set_left
    215  136d		       a5 1b		      lda	temp+1
    216  136f		       29 0f		      and	#$0F
    217  1371		       20 6d 15 	      jsr	set_right
    218  1374		       60		      rts
    219  1375
    220  1375				   power_pair_logic
    221  1375		       a5 1a		      lda	temp
    222  1377		       29 f0		      and	#$F0
    223  1379		       c9 80		      cmp	#$80	; check ignited booster
    224  137b		       d0 19		      bne	ppl1b
    225  137d		       a5 1b		      lda	temp+1
    226  137f		       29 0f		      and	#$0F	; check opposite tile
    227  1381		       c9 06		      cmp	#BREAKABLE_WALL_CHAR
    228  1383		       d0 06		      bne	ppl1ab
    229  1385		       a5 1b		      lda	temp+1
    230  1387		       29 f0		      and	#$F0
    231  1389		       85 1b		      sta	temp+1	; delete wall
    232  138b				   ppl1ab
    233  138b		       a5 1a		      lda	temp
    234  138d		       29 0f		      and	#$0F
    235  138f		       69 20		      adc	#$20	; set active booster
    236  1391		       85 1a		      sta	temp
    237  1393		       4c ce 13 	      jmp	ppl2
    238  1396				   ppl1b
    239  1396		       c9 20		      cmp	#$20	; check active booster
    240  1398		       d0 19		      bne	ppl1k
    241  139a		       a5 1b		      lda	temp+1
    242  139c		       29 0f		      and	#$0F	; check opposite tile
    243  139e		       c9 06		      cmp	#BREAKABLE_WALL_CHAR
    244  13a0		       d0 06		      bne	ppl1rb
    245  13a2		       a5 1b		      lda	temp+1
    246  13a4		       29 f0		      and	#$F0
    247  13a6		       85 1b		      sta	temp+1	; delete wall
    248  13a8				   ppl1rb
    249  13a8		       a5 1a		      lda	temp
    250  13aa		       29 0f		      and	#$0F
    251  13ac		       69 10		      adc	#$10	; set ready booster
    252  13ae		       85 1a		      sta	temp
    253  13b0		       4c ce 13 	      jmp	ppl2
    254  13b3				   ppl1k
    255  13b3		       c9 30		      cmp	#$30	; check key
    256  13b5		       d0 17		      bne	ppl2
    257  13b7		       a5 1b		      lda	temp+1
    258  13b9		       29 f0		      and	#$F0
    259  13bb		       c9 50		      cmp	#[LOCKED_WALL_CHAR << 4]
    260  13bd		       d0 0f		      bne	ppl2
    261  13bf		       a5 1a		      lda	temp
    262  13c1		       29 0f		      and	#$0F
    263  13c3		       85 1a		      sta	temp	; delete key
    264  13c5		       a5 1b		      lda	temp+1
    265  13c7		       29 0f		      and	#$0F
    266  13c9		       85 1b		      sta	temp+1	; delete wall
    267  13cb		       4c ce 13 	      jmp	ppl2
    268  13ce
    269  13ce				   ppl2
    270  13ce		       a5 1a		      lda	temp
    271  13d0		       29 0f		      and	#$0F
    272  13d2		       c9 08		      cmp	#$08	; check ignited booster
    273  13d4		       d0 19		      bne	ppl2b
    274  13d6		       a5 1b		      lda	temp+1
    275  13d8		       29 f0		      and	#$F0
    276  13da		       c9 60		      cmp	#[BREAKABLE_WALL_CHAR << 4]
    277  13dc		       d0 06		      bne	ppl2ab
    278  13de		       a5 1b		      lda	temp+1
    279  13e0		       29 0f		      and	#$0F
    280  13e2		       85 1b		      sta	temp+1	; delete wall
    281  13e4				   ppl2ab
    282  13e4		       a5 1a		      lda	temp
    283  13e6		       29 f0		      and	#$F0
    284  13e8		       69 02		      adc	#$02	; set active booster
    285  13ea		       85 1a		      sta	temp
    286  13ec		       4c 27 14 	      jmp	pplend
    287  13ef				   ppl2b
    288  13ef		       c9 02		      cmp	#$02	; check active booster
    289  13f1		       d0 19		      bne	ppl2k
    290  13f3		       a5 1b		      lda	temp+1
    291  13f5		       29 f0		      and	#$F0
    292  13f7		       c9 60		      cmp	#[BREAKABLE_WALL_CHAR << 4]
    293  13f9		       d0 06		      bne	ppl2rb
    294  13fb		       a5 1b		      lda	temp+1
    295  13fd		       29 0f		      and	#$0F
    296  13ff		       85 1b		      sta	temp+1	; delete wall
    297  1401				   ppl2rb
    298  1401		       a5 1a		      lda	temp
    299  1403		       29 f0		      and	#$F0
    300  1405		       69 01		      adc	#$01	; set ready booster
    301  1407		       85 1a		      sta	temp
    302  1409		       4c 27 14 	      jmp	pplend
    303  140c				   ppl2k
    304  140c		       c9 03		      cmp	#$03	; key
    305  140e		       d0 17		      bne	pplend
    306  1410		       a5 1b		      lda	temp+1
    307  1412		       29 0f		      and	#$0F
    308  1414		       c9 05		      cmp	#LOCKED_WALL_CHAR
    309  1416		       d0 0f		      bne	pplend
    310  1418		       a5 1a		      lda	temp
    311  141a		       29 f0		      and	#$F0
    312  141c		       85 1a		      sta	temp	; delete key
    313  141e		       a5 1b		      lda	temp+1
    314  1420		       29 f0		      and	#$F0
    315  1422		       85 1b		      sta	temp+1	; delete wall
    316  1424		       4c 27 14 	      jmp	pplend
    317  1427
    318  1427				   pplend
    319  1427		       60		      rts
    320  1428
    321  1428
    322  1428				   delete_squarebot
    323  1428		       20 16 16 	      jsr	get_squarebot_draw_position
    324  142b
    325  142b		       a0 17		      ldy	#[ROW_SIZE + 1]
    326  142d		       20 68 15 	      jsr	get_mid
    327  1430		       91 10		      sta	(squarebot_position),y
    328  1432		       a9 00		      lda	#0
    329  1434		       91 12		      sta	(squarebot_color_position),y
    330  1436
    331  1436		       a0 01		      ldy	#1
    332  1438		       20 61 15 	      jsr	get_up
    333  143b		       91 10		      sta	(squarebot_position),y
    334  143d		       a9 00		      lda	#0
    335  143f		       91 12		      sta	(squarebot_color_position),y
    336  1441
    337  1441		       a0 2d		      ldy	#[[ROW_SIZE*2] + 1]
    338  1443		       20 5c 15 	      jsr	get_down
    339  1446		       91 10		      sta	(squarebot_position),y
    340  1448		       a9 00		      lda	#0
    341  144a		       91 12		      sta	(squarebot_color_position),y
    342  144c
    343  144c		       a0 16		      ldy	#ROW_SIZE
    344  144e		       20 55 15 	      jsr	get_left
    345  1451		       91 10		      sta	(squarebot_position),y
    346  1453		       a9 00		      lda	#0
    347  1455		       91 12		      sta	(squarebot_color_position),y
    348  1457
    349  1457		       a0 18		      ldy	#[ROW_SIZE + 2]
    350  1459		       20 50 15 	      jsr	get_right
    351  145c		       91 10		      sta	(squarebot_position),y
    352  145e		       a9 00		      lda	#0
    353  1460
    354  1460		       20 31 16 	      jsr	get_squarebot_game_position
    355  1463
    356  1463		       60		      rts
    357  1464
    358  1464
    359  1464				   update_squarebot
    360  1464		       a5 0b		      lda	new_position
    361  1466		       85 10		      sta	squarebot_position
    362  1468		       a5 0c		      lda	new_position+1
    363  146a		       85 11		      sta	squarebot_position+1
    364  146c
    365  146c		       a5 0d		      lda	new_color_position
    366  146e		       85 12		      sta	squarebot_color_position
    367  1470		       a5 0e		      lda	new_color_position+1
    368  1472		       85 13		      sta	squarebot_color_position+1
    369  1474		       60		      rts
    370  1475
    371  1475
    372  1475				   update_chars
    373  1475		       20 61 15 	      jsr	get_up
    374  1478		       0a		      asl
    375  1479		       0a		      asl
    376  147a		       0a		      asl		; multiply by 8
    377  147b		       85 1c		      sta	charandr
    378  147d
    379  147d		       a5 18		      lda	attached_powerups
    380  147f		       4a		      lsr
    381  1480		       4a		      lsr
    382  1481		       4a		      lsr
    383  1482		       4a		      lsr
    384  1483		       c9 00		      cmp	#0
    385  1485		       f0 05		      beq	update_blank_u
    386  1487		       69 09		      adc	#9
    387  1489		       0a		      asl
    388  148a		       0a		      asl
    389  148b		       0a		      asl		; we could simplify this but at this rate a few more asls isn't going to be the main thing slowing down the code
    390  148c				   update_blank_u
    391  148c		       85 1d		      sta	charandr+1
    392  148e
    393  148e		       a9 70		      lda	#[CHAR_U << 3]
    394  1490		       85 1e		      sta	charandr+2
    395  1492
    396  1492		       20 f2 14 	      jsr	update_char
    397  1495							;keep in mind we haven't rotated it yet
    398  1495
    399  1495		       20 5c 15 	      jsr	get_down
    400  1498		       0a		      asl
    401  1499		       0a		      asl
    402  149a		       0a		      asl
    403  149b		       85 1c		      sta	charandr
    404  149d
    405  149d		       a5 18		      lda	attached_powerups
    406  149f		       25 0f		      and	$0F
    407  14a1		       c9 00		      cmp	#0
    408  14a3		       f0 05		      beq	update_blank_d
    409  14a5		       69 09		      adc	#9
    410  14a7		       0a		      asl
    411  14a8		       0a		      asl
    412  14a9		       0a		      asl
    413  14aa				   update_blank_d
    414  14aa		       85 1d		      sta	charandr+1
    415  14ac
    416  14ac		       a9 78		      lda	#[CHAR_D << 3]
    417  14ae		       85 1e		      sta	charandr+2
    418  14b0
    419  14b0		       20 f2 14 	      jsr	update_char
    420  14b3
    421  14b3		       20 55 15 	      jsr	get_left
    422  14b6		       0a		      asl
    423  14b7		       0a		      asl
    424  14b8		       0a		      asl
    425  14b9		       85 1c		      sta	charandr
    426  14bb
    427  14bb		       a5 19		      lda	attached_powerups+1
    428  14bd		       4a		      lsr
    429  14be		       4a		      lsr
    430  14bf		       4a		      lsr
    431  14c0		       4a		      lsr
    432  14c1		       c9 00		      cmp	#0
    433  14c3		       f0 05		      beq	update_blank_l
    434  14c5		       69 09		      adc	#9
    435  14c7		       0a		      asl
    436  14c8		       0a		      asl
    437  14c9		       0a		      asl
    438  14ca				   update_blank_l
    439  14ca		       85 1d		      sta	charandr+1
    440  14cc
    441  14cc		       a9 80		      lda	#[CHAR_L << 3]
    442  14ce		       85 1e		      sta	charandr+2
    443  14d0
    444  14d0		       20 f2 14 	      jsr	update_char
    445  14d3
    446  14d3		       20 50 15 	      jsr	get_right
    447  14d6		       0a		      asl
    448  14d7		       0a		      asl
    449  14d8		       0a		      asl
    450  14d9		       85 1c		      sta	charandr
    451  14db
    452  14db		       a5 19		      lda	attached_powerups+1
    453  14dd		       25 0f		      and	$0F
    454  14df		       c9 00		      cmp	#0
    455  14e1		       f0 05		      beq	update_blank_r
    456  14e3		       69 09		      adc	#9
    457  14e5		       0a		      asl
    458  14e6		       0a		      asl
    459  14e7		       0a		      asl
    460  14e8				   update_blank_r
    461  14e8		       85 1d		      sta	charandr+1
    462  14ea
    463  14ea		       a9 88		      lda	#[CHAR_R << 3]
    464  14ec		       85 1e		      sta	charandr+2
    465  14ee
    466  14ee		       20 f2 14 	      jsr	update_char
    467  14f1
    468  14f1		       60		      rts		;casual 98 line function
    469  14f2
    470  14f2
    471  14f2				   update_char
    472  14f2		       a2 00		      ldx	#0
    473  14f4				   update_char_loop
    474  14f4		       8a		      txa
    475  14f5		       65 1c		      adc	charandr
    476  14f7		       a8		      tay
    477  14f8		       b9 00 1c 	      lda	(#character_set_begin),y
    478  14fb		       85 1a		      sta	temp
    479  14fd
    480  14fd		       8a		      txa
    481  14fe		       65 1d		      adc	charandr+1
    482  1500		       a8		      tay
    483  1501		       b9 00 1c 	      lda	(#character_set_begin),y
    484  1504		       45 1a		      eor	temp
    485  1506		       85 1a		      sta	temp
    486  1508
    487  1508		       8a		      txa
    488  1509		       65 1e		      adc	charandr+2
    489  150b		       a8		      tay
    490  150c		       a5 1a		      lda	temp
    491  150e		       99 00 1c 	      sta	(#character_set_begin),y
    492  1511
    493  1511		       e8		      inx
    494  1512		       e0 08		      cpx	#8
    495  1514		       d0 de		      bne	update_char_loop
    496  1516		       60		      rts
    497  1517
    498  1517							; if there is a powerup:
    499  1517							; for each of 8 bytes:
    500  1517							; load tile byte
    501  1517							; eor with powerup tile byte
    502  1517							; store in char byte
    503  1517
    504  1517				   draw_squarebot
    505  1517		       20 16 16 	      jsr	get_squarebot_draw_position
    506  151a
    507  151a		       a9 0e		      lda	#CHAR_U
    508  151c		       a0 01		      ldy	#1
    509  151e		       91 10		      sta	(squarebot_position),y
    510  1520		       a9 00		      lda	#0
    511  1522		       91 12		      sta	(squarebot_color_position),y
    512  1524
    513  1524		       a9 0f		      lda	#CHAR_D
    514  1526		       a0 2d		      ldy	#[[ROW_SIZE*2]+1]
    515  1528		       91 10		      sta	(squarebot_position),y
    516  152a		       a9 00		      lda	#0
    517  152c		       91 12		      sta	(squarebot_color_position),y
    518  152e
    519  152e		       a9 10		      lda	#CHAR_L
    520  1530		       a0 16		      ldy	#ROW_SIZE
    521  1532		       91 10		      sta	(squarebot_position),y
    522  1534		       a9 00		      lda	#0
    523  1536		       91 12		      sta	(squarebot_color_position),y
    524  1538
    525  1538		       a9 11		      lda	#CHAR_R
    526  153a		       a0 18		      ldy	#[ROW_SIZE+2]
    527  153c		       91 10		      sta	(squarebot_position),y
    528  153e		       a9 00		      lda	#0
    529  1540		       91 12		      sta	(squarebot_color_position),y
    530  1542
    531  1542		       a9 12		      lda	#SQUAREBOT_CHAR
    532  1544		       a0 17		      ldy	#[ROW_SIZE+1]
    533  1546		       91 10		      sta	(squarebot_position),y
    534  1548		       a9 02		      lda	#SQUAREBOT_COLOR
    535  154a		       91 12		      sta	(squarebot_color_position),y
    536  154c
    537  154c		       20 31 16 	      jsr	get_squarebot_game_position
    538  154f		       60		      rts
    539  1550
    540  1550							;real how it works:
    541  1550
    542  1550							;l/r movement:
    543  1550							;store l/r tile you want to move to
    544  1550							;if you win, win
    545  1550							;check collision:
    546  1550							;  store powerup in temp
    547  1550							;  return whether you can move or not
    548  1550							;if you can't move, goto j/f movement
    549  1550							;apply powerup
    550  1550							;get new position
    551  1550							;refresh tiles
    552  1550							;apply powerup logic
    553  1550							;delete old position
    554  1550							;update position
    555  1550							;redraw chars
    556  1550							;draw new position
    557  1550							;wait a jiffy maybe
    558  1550							;check booster
    559  1550							;
    560  1550							;j/f movement
    561  1550							;do similar thing
------- FILE src/main.s
------- FILE updateGameStateHelper.s LEVEL 2 PASS 3
      0  1550					      include	"updateGameStateHelper.s"
      1  1550							; Helper functions for updateGameState
      2  1550
      3  1550				   get_right
      4  1550		       a5 16		      lda	tileStore+1
      5  1552		       29 0f		      and	#$0F
      6  1554		       60		      rts
      7  1555
      8  1555				   get_left
      9  1555		       a5 16		      lda	tileStore+1
     10  1557		       4a		      lsr
     11  1558		       4a		      lsr
     12  1559		       4a		      lsr
     13  155a		       4a		      lsr
     14  155b		       60		      rts
     15  155c
     16  155c				   get_down
     17  155c		       a5 15		      lda	tileStore
     18  155e		       29 0f		      and	#$0F
     19  1560		       60		      rts
     20  1561
     21  1561				   get_up
     22  1561		       a5 15		      lda	tileStore
     23  1563		       4a		      lsr
     24  1564		       4a		      lsr
     25  1565		       4a		      lsr
     26  1566		       4a		      lsr
     27  1567		       60		      rts
     28  1568
     29  1568				   get_mid
     30  1568		       a5 17		      lda	tileStore+2
     31  156a		       25 0f		      and	$0F
     32  156c		       60		      rts
     33  156d
     34  156d
     35  156d				   set_right
     36  156d		       85 1a		      sta	temp
     37  156f		       a9 f0		      lda	#$F0
     38  1571		       25 16		      and	tileStore+1
     39  1573		       18		      clc
     40  1574		       65 1a		      adc	temp
     41  1576		       85 16		      sta	tileStore+1
     42  1578		       60		      rts
     43  1579
     44  1579				   set_left
     45  1579		       0a		      asl
     46  157a		       0a		      asl
     47  157b		       0a		      asl
     48  157c		       0a		      asl
     49  157d		       85 1a		      sta	temp
     50  157f		       a9 0f		      lda	#$0F
     51  1581		       25 16		      and	tileStore+1
     52  1583		       18		      clc
     53  1584		       65 1a		      adc	temp
     54  1586		       85 16		      sta	tileStore+1
     55  1588		       60		      rts
     56  1589
     57  1589				   set_down
     58  1589		       85 1a		      sta	temp
     59  158b		       a9 f0		      lda	#$F0
     60  158d		       25 15		      and	tileStore
     61  158f		       18		      clc
     62  1590		       65 1a		      adc	temp
     63  1592		       85 15		      sta	tileStore
     64  1594		       60		      rts
     65  1595
     66  1595				   set_up
     67  1595		       0a		      asl
     68  1596		       0a		      asl
     69  1597		       0a		      asl
     70  1598		       0a		      asl
     71  1599		       85 1a		      sta	temp
     72  159b		       a9 0f		      lda	#$0F
     73  159d		       25 15		      and	tileStore
     74  159f		       18		      clc
     75  15a0		       65 1a		      adc	temp
     76  15a2		       85 15		      sta	tileStore
     77  15a4		       60		      rts
     78  15a5
     79  15a5				   set_mid
     80  15a5		       29 0f		      and	#$0F
     81  15a7		       85 17		      sta	tileStore+2
     82  15a9		       60		      rts
     83  15aa
     84  15aa				   move_new_position_right
     85  15aa		       18		      clc
     86  15ab		       a5 0b		      lda	new_position	; load and add to low byte
     87  15ad		       69 01		      adc	#$1
     88  15af		       85 0b		      sta	new_position
     89  15b1		       a5 0c		      lda	new_position+1
     90  15b3		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
     91  15b5		       85 0c		      sta	new_position+1
     92  15b7		       18		      clc
     93  15b8		       a5 0d		      lda	new_color_position	; load and add to low byte
     94  15ba		       69 01		      adc	#$1
     95  15bc		       85 0d		      sta	new_color_position
     96  15be		       a5 0e		      lda	new_color_position+1
     97  15c0		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
     98  15c2		       85 0e		      sta	new_color_position+1
     99  15c4		       60		      rts
    100  15c5
    101  15c5				   move_new_position_left
    102  15c5		       38		      sec
    103  15c6		       a5 0b		      lda	new_position
    104  15c8		       e9 01		      sbc	#$1
    105  15ca		       85 0b		      sta	new_position
    106  15cc		       a5 0c		      lda	new_position+1
    107  15ce		       e9 00		      sbc	#$0
    108  15d0		       85 0c		      sta	new_position+1
    109  15d2		       38		      sec
    110  15d3		       a5 0d		      lda	new_color_position
    111  15d5		       e9 01		      sbc	#$1
    112  15d7		       85 0d		      sta	new_color_position
    113  15d9		       a5 0e		      lda	new_color_position+1
    114  15db		       e9 00		      sbc	#$0
    115  15dd		       85 0e		      sta	new_color_position+1
    116  15df		       60		      rts
    117  15e0
    118  15e0
    119  15e0				   move_new_position_up
    120  15e0		       38		      sec
    121  15e1		       a5 0b		      lda	new_position
    122  15e3		       e9 16		      sbc	#ROW_SIZE
    123  15e5		       85 0b		      sta	new_position
    124  15e7		       a5 0c		      lda	new_position+1
    125  15e9		       e9 00		      sbc	#$0
    126  15eb		       85 0c		      sta	new_position+1
    127  15ed		       38		      sec
    128  15ee		       a5 0d		      lda	new_color_position
    129  15f0		       e9 16		      sbc	#ROW_SIZE
    130  15f2		       85 0d		      sta	new_color_position
    131  15f4		       a5 0e		      lda	new_color_position+1
    132  15f6		       e9 00		      sbc	#$0
    133  15f8		       85 0e		      sta	new_color_position+1
    134  15fa		       60		      rts
    135  15fb
    136  15fb				   move_new_position_down
    137  15fb		       18		      clc
    138  15fc		       a5 0b		      lda	new_position	; load and add to low byte
    139  15fe		       69 16		      adc	#ROW_SIZE
    140  1600		       85 0b		      sta	new_position
    141  1602		       a5 0c		      lda	new_position+1
    142  1604		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
    143  1606		       85 0c		      sta	new_position+1
    144  1608		       18		      clc
    145  1609		       a5 0d		      lda	new_color_position	; load and add to low byte
    146  160b		       69 16		      adc	#ROW_SIZE
    147  160d		       85 0d		      sta	new_color_position
    148  160f		       a5 0e		      lda	new_color_position+1
    149  1611		       69 00		      adc	#$0	; add if carry flag is set (low byte overflowed)
    150  1613		       85 0e		      sta	new_color_position+1
    151  1615		       60		      rts
    152  1616
    153  1616				   get_squarebot_draw_position
    154  1616		       38		      sec
    155  1617		       a5 10		      lda	squarebot_position
    156  1619		       e9 17		      sbc	#[ROW_SIZE+1]
    157  161b		       85 10		      sta	squarebot_position
    158  161d		       a5 11		      lda	squarebot_position+1
    159  161f		       e9 00		      sbc	#0
    160  1621		       85 11		      sta	squarebot_position+1
    161  1623		       38		      sec
    162  1624		       a5 12		      lda	squarebot_color_position
    163  1626		       e9 17		      sbc	#[ROW_SIZE+1]
    164  1628		       85 12		      sta	squarebot_color_position
    165  162a		       a5 13		      lda	squarebot_color_position+1
    166  162c		       e9 00		      sbc	#0
    167  162e		       85 13		      sta	squarebot_color_position+1
    168  1630		       60		      rts
    169  1631
    170  1631				   get_squarebot_game_position
    171  1631		       18		      clc
    172  1632		       a5 10		      lda	squarebot_position
    173  1634		       69 17		      adc	#[ROW_SIZE+1]
    174  1636		       85 10		      sta	squarebot_position
    175  1638		       a5 11		      lda	squarebot_position+1
    176  163a		       69 00		      adc	#0
    177  163c		       85 11		      sta	squarebot_position+1
    178  163e		       18		      clc
    179  163f		       a5 12		      lda	squarebot_color_position
    180  1641		       69 17		      adc	#[ROW_SIZE+1]
    181  1643		       85 12		      sta	squarebot_color_position
    182  1645		       a5 13		      lda	squarebot_color_position+1
    183  1647		       69 00		      adc	#0
    184  1649		       85 13		      sta	squarebot_color_position+1
    185  164b		       60		      rts
    186  164c
    187  164c				   get_new_draw_position
    188  164c		       38		      sec
    189  164d		       a5 0b		      lda	new_position
    190  164f		       e9 17		      sbc	#[ROW_SIZE+1]
    191  1651		       85 0b		      sta	new_position
    192  1653		       a5 0c		      lda	new_position+1
    193  1655		       e9 00		      sbc	#0
    194  1657		       85 0c		      sta	new_position+1
    195  1659		       38		      sec
    196  165a		       a5 0d		      lda	new_color_position
    197  165c		       e9 17		      sbc	#[ROW_SIZE+1]
    198  165e		       85 0d		      sta	new_color_position
    199  1660		       a5 0e		      lda	new_color_position+1
    200  1662		       e9 00		      sbc	#0
    201  1664		       85 0e		      sta	new_color_position+1
    202  1666		       60		      rts
    203  1667
    204  1667				   get_new_game_position
    205  1667		       18		      clc
    206  1668		       a5 0b		      lda	new_position
    207  166a		       69 17		      adc	#[ROW_SIZE+1]
    208  166c		       85 0b		      sta	new_position
    209  166e		       a5 0c		      lda	new_position+1
    210  1670		       69 00		      adc	#0
    211  1672		       85 0c		      sta	new_position+1
    212  1674		       18		      clc
    213  1675		       a5 0d		      lda	new_color_position
    214  1677		       69 17		      adc	#[ROW_SIZE+1]
    215  1679		       85 0d		      sta	new_color_position
    216  167b		       a5 0e		      lda	new_color_position+1
    217  167d		       69 00		      adc	#0
    218  167f		       85 0e		      sta	new_color_position+1
    219  1681		       60		      rts
    220  1682
    221  1682				   get_tiles_r
    222  1682		       20 4c 16 	      jsr	get_new_draw_position	; moves new_position and its color pos up and left one tile
    223  1685		       20 68 15 	      jsr	get_mid
    224  1688		       20 79 15 	      jsr	set_left
    225  168b		       20 50 15 	      jsr	get_right
    226  168e		       20 a5 15 	      jsr	set_mid
    227  1691		       a0 01		      ldy	#1
    228  1693		       b1 0b		      lda	(new_position),y
    229  1695		       20 95 15 	      jsr	set_up
    230  1698		       a0 2d		      ldy	#[[ROW_SIZE*2]+1]
    231  169a		       b1 0b		      lda	(new_position),y
    232  169c		       20 89 15 	      jsr	set_down
    233  169f		       a0 18		      ldy	#[ROW_SIZE+2]
    234  16a1		       b1 0b		      lda	(new_position),y
    235  16a3		       20 6d 15 	      jsr	set_right
    236  16a6		       20 67 16 	      jsr	get_new_game_position	; move new_position and its color pos back
    237  16a9		       60		      rts
    238  16aa
    239  16aa				   get_tiles_l
    240  16aa		       20 4c 16 	      jsr	get_new_draw_position
    241  16ad		       20 68 15 	      jsr	get_mid
    242  16b0		       20 6d 15 	      jsr	set_right
    243  16b3		       20 55 15 	      jsr	get_left
    244  16b6		       20 a5 15 	      jsr	set_mid
    245  16b9		       a0 01		      ldy	#1
    246  16bb		       b1 0b		      lda	(new_position),y
    247  16bd		       20 95 15 	      jsr	set_up
    248  16c0		       a0 2d		      ldy	#[[ROW_SIZE*2]+1]
    249  16c2		       b1 0b		      lda	(new_position),y
    250  16c4		       20 89 15 	      jsr	set_down
    251  16c7		       a0 16		      ldy	#ROW_SIZE
    252  16c9		       b1 0b		      lda	(new_position),y
    253  16cb		       20 79 15 	      jsr	set_left
    254  16ce		       20 67 16 	      jsr	get_new_game_position
    255  16d1		       60		      rts
------- FILE src/main.s
    138  16d2
    139  16d2				   compressed_screen_data_start
    140  16d2					      incbin	"../data/titleScreenData_compressed"	; got via 'bsave ""'
    141  173a
    142  173a				   level_data_start
    143  173a					      incbin	"../data/levels/binary_levels/jesse_1"
    144  17be					      incbin	"../data/levels/binary_levels/booster_test"
    145  17cc					      incbin	"../data/levels/binary_levels/key_test"
    146  17e2					      incbin	"../data/levels/binary_levels/2"
    147  17fa					      incbin	"../data/levels/binary_levels/3"
    148  1852					      incbin	"../data/levels/binary_levels/4"
    149  187e					      incbin	"../data/levels/binary_levels/5"
    150  18aa					      incbin	"../data/levels/binary_levels/6"
    151  18dc
------- FILE memoryCheck.s LEVEL 2 PASS 3
      0  18dc					      include	"memoryCheck.s"	; code to make sure the program isn't too large and enters screen memory
      1  18dc		       08 db	   BYTES_USED =	.-$1001	; location counter minus starting location = total bytes used
      2  18dc		       1e 00	   SCREEN_MEMORY_START =	$1e00
 2267 bytes used
      3  18dc					      echo	[BYTES_USED]d, "bytes used"
 Ending program at memory location (base 10):  6364
      4  18dc					      echo	"Ending program at memory location (base 10): ", [.]d
      5  18dc				  -	      if	. >= SCREEN_MEMORY_START	; if program entering screen memory
      6  18dc				  -	      echo	"Throwing error because program is too large, and has entered screen memory!"
      7  18dc				  -	      err
      8  18dc					      endif
------- FILE src/main.s
    153  18dc
    154  18dc
    155  1c00					      org	character_set_begin
    156  1c00		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; blank 0
    157  1c08		       7e 42 7e 42*	      BYTE.b	$7E, $42, $7E, $42, $7E, $42, $7E, $42	; ladder 1
    158  1c10		       ff 5a 00 00*	      BYTE.b	$FF, $5A, $00, $00, $00, $00, $00, $00	; platform 2
    159  1c18		       ff ff ff ff*	      BYTE.b	$FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF	; wall 3
    160  1c20		       ff 9d a3 ac*	      BYTE.b	$FF, $9D, $A3, $AC, $A5, $99, $C3, $FF	; exit (door) 4
    161  1c28		       ff ff c3 c3*	      BYTE.b	$FF, $FF, $C3, $C3, $E7, $E7, $E7, $FF	; locked wall 5
    162  1c30		       ff ee f1 ef*	      BYTE.b	$FF, $EE, $F1, $EF, $57, $8F, $F3, $FF	; breakable wall 6
    163  1c38		       3c 42 99 bd*	      BYTE.b	$3C, $42, $99, $BD, $89, $91, $42, $3C	; booster powerup 7
    164  1c40		       3c 42 99 99*	      BYTE.b	$3C, $42, $99, $99, $91, $99, $42, $3C	; key powerup 8
    165  1c48		       3c 42 91 99*	      BYTE.b	$3C, $42, $91, $99, $BD, $81, $42, $3C	; spike powerup 9
    166  1c50		       08 38 f0 f0*	      BYTE.b	$08, $38, $F0, $F0, $F0, $F0, $38, $08	; ready booster attachment (R) 10
    167  1c58		       08 38 f1 ff*	      BYTE.b	$08, $38, $F1, $FF, $FE, $F1, $38, $08	; active booster attachment (R) 11
    168  1c60		       00 00 fe fe*	      BYTE.b	$00, $00, $FE, $FE, $6A, $0A, $0E, $00	; key attachment (R) 12
    169  1c68		       80 c0 f0 fe*	      BYTE.b	$80, $C0, $F0, $FE, $F0, $C0, $80, $00	; spike attachment (R) 13
    170  1c70		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; charU 14
    171  1c78		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; charD 15
    172  1c80		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; charL 16
    173  1c88		       00 00 00 00*	      BYTE.b	$00, $00, $00, $00, $00, $00, $00, $00	; charR 17
    174  1c90		       ff 81 a5 81*	      BYTE.b	$FF, $81, $A5, $81, $BD, $81, $81, $FF	; squarebot 18
